[{"title":"DSP开发那些事","path":"//dsp-programming.html","content":"开发环境DSP使用Code Compose Studio，stm32使用MDK Keil或者stm32CubeIDE 芯片DSP一般是32位的（最小可寻址内存单元通常不支持单字节（8 位 char）访问，而是以 16 位或 32 位 为单位操作，数据总线是32位或者16位的），DSP尤其擅长浮点数的处理；stm32是32位的，它支持的数据类型也比较广（最小寻址支持8位） 链接文件CMD文件相当于stm32里边的链接文件（*.sct），这个文件告诉编译器程序怎么链接，不过DSP支持RAM的烧录模式，stm32只能烧到FLASH里边 开发库跟stm32很像，也有寄存器和库函数两个版本，其中所有外设的寄存器对象会放在xxx_globalvariabledefs.c里边，如：f2837xS_globalvariabledefs.c、F28M35x_GlobalVariableDefs.c；库函数接口则放在driverlib里边 可视化编程DSP使用sysconfig工具，相当于stm32CubeMX，可以使用图形化的方式配置外设功能 调试DSP使用XDS xxx &#x2F; JTAG调试工具，DSP的调试器大部分都支持两个Serial Port（虚拟一个串口，一个调试一个用作串口通信）；而stm32使用ST-Link或者JTAG 多核DSP支持多核编程，每个核心可以并行跑不一样的程序，如TMS320F28377S 的双核（CPU1 和 CPU2）可以独立运行不同的程序，而stm32不支持多核编程","tags":["DSP"],"categories":["嵌入式"]},{"title":"Windows制作exe安装包","path":"//windows-exe-packing-tutorial.html","content":"安装访问Inno Setup官网，下载最新版本innosetup-6.2.2.exe，下载完成后双击安装，根据英文提示完成相应的配置，如图①、②、③、④、⑤、⑥，安装完成后打开 创建脚本在打开的Welcome窗口，选择Create a new script file using Script Wizard，然后点击OK 按照提示完成一步一步完成脚本参数配置，如下图①、② …… ⑬ 、⑭ 按快捷键（Ctrl + F9）或者点击工具栏从左到右第四个图标，编译脚本，生成exe安装包 最终生成exe文件，这个安装包会带有向导脚本里边填写的信息，如版本号、公司、文件说明等 脚本解析有了脚本以后直接修改脚本就可以了（按需修改），不用每次都要填写向导脚本的流程，这里介绍脚本一些关键的变量和参数 宏定义以下宏定义用于定义程序名、软件版本、发布者、发布者网站信息、关联的文件格式等 12345678#define MyAppName &quot;Example&quot;#define MyAppVersion &quot;1.0.0&quot;#define MyAppPublisher &quot;iotstuff&quot;#define MyAppURL &quot;https://iotstuff.cn&quot;#define MyAppExeName &quot;Example.exe&quot;#define MyAppAssocName MyAppName + &quot; File&quot;#define MyAppAssocExt &quot;.myp&quot;#define MyAppAssocKey StringChange(MyAppAssocName, &quot; &quot;, &quot;) + MyAppAssocExt Setupsetup用于定义一些基本的软件包信息 12345678910111213141516AppId=&#123;&#123;75FF5697-7D83-46D7-824A-F4259ADE4FC3&#125;AppName=&#123;#MyAppName&#125;AppVersion=&#123;#MyAppVersion&#125;AppPublisher=&#123;#MyAppPublisher&#125;AppPublisherURL=&#123;#MyAppURL&#125;AppSupportURL=&#123;#MyAppURL&#125;AppUpdatesURL=&#123;#MyAppURL&#125;DefaultDirName=&#123;autopf&#125;\\&#123;#MyAppName&#125;ChangesAssociations=yesDisableProgramGroupPage=yesOutputDir=E:\\OutputBaseFilename=ExampleSetupIconFile=E:\\logo.icoCompression=lzmaSolidCompression=yesWizardStyle=modern Languagessetup程序的默认语言设置 1Name: &quot;english&quot;; MessagesFile: &quot;compiler:Default.isl&quot; Tasks编译任务相关参数定义 1Name: &quot;desktopicon&quot;; Description: &quot;&#123;cm:CreateDesktopIcon&#125;&quot;; GroupDescription: &quot;&#123;cm:AdditionalIcons&#125;&quot;; Flags: unchecked Files输出的exe压缩包路径定义 12Source: &quot;E:\\build\\&#123;#MyAppExeName&#125;&quot;; DestDir: &quot;&#123;app&#125;&quot;; Flags: ignoreversionSource: &quot;E:\\build\\*&quot;; DestDir: &quot;&#123;app&#125;&quot;; Flags: ignoreversion recursesubdirs createallsubdirs Registry注册表相关信息，保存一些需要持久化的软件包信息 12345Root: HKA; Subkey: &quot;Software\\Classes\\&#123;#MyAppAssocExt&#125;\\OpenWithProgids&quot;; ValueType: string; ValueName: &quot;&#123;#MyAppAssocKey&#125;&quot;; ValueData: &quot;&quot;; Flags: uninsdeletevalueRoot: HKA; Subkey: &quot;Software\\Classes\\&#123;#MyAppAssocKey&#125;&quot;; ValueType: string; ValueName: &quot;&quot;; ValueData: &quot;&#123;#MyAppAssocName&#125;&quot;; Flags: uninsdeletekeyRoot: HKA; Subkey: &quot;Software\\Classes\\&#123;#MyAppAssocKey&#125;\\DefaultIcon&quot;; ValueType: string; ValueName: &quot;&quot;; ValueData: &quot;&#123;app&#125;\\&#123;#MyAppExeName&#125;,0&quot;Root: HKA; Subkey: &quot;Software\\Classes\\&#123;#MyAppAssocKey&#125;\\shell\\open\\command&quot;; ValueType: string; ValueName: &quot;&quot;; ValueData: &quot;&quot;&quot;&#123;app&#125;\\&#123;#MyAppExeName&#125;&quot;&quot; &quot;&quot;%1&quot;&quot;&quot;Root: HKA; Subkey: &quot;Software\\Classes\\Applications\\&#123;#MyAppExeName&#125;\\SupportedTypes&quot;; ValueType: string; ValueName: &quot;.myp&quot;; ValueData: &quot;&quot; Icons程序logo自定义 12Name: &quot;&#123;autoprograms&#125;\\&#123;#MyAppName&#125;&quot;; Filename: &quot;&#123;app&#125;\\&#123;#MyAppExeName&#125;&quot;Name: &quot;&#123;autodesktop&#125;\\&#123;#MyAppName&#125;&quot;; Filename: &quot;&#123;app&#125;\\&#123;#MyAppExeName&#125;&quot;; Tasks: desktopicon Run可执行程序路径定义 1Filename: &quot;&#123;app&#125;\\&#123;#MyAppExeName&#125;&quot;; Description: &quot;&#123;cm:LaunchProgram,&#123;#StringChange(MyAppName, &#x27;&amp;&#x27;, &#x27;&amp;&amp;&#x27;)&#125;&#125;&quot;; Flags: nowait postinstall skipifsilent","tags":["Windows","exe","Inno Setup"],"categories":["程序设计"]},{"title":"C语言高级用法：可变参数函数接口","path":"//c-variadic-template-interface.html","content":"需求使用C语言发送任意个通道的波形数据，要求：接口固定，但参数个数不固定，DSP的开发环境只能用C语言 实现stdarg是C语言标准库的一部分，我们通过它来实现类似C++的函数模板 1#include &lt;stdarg.h&gt; 比如给上位机发送数据，一个通道为一个float，可变参数num代表可以发n个通道的波形数据 12345678910111213141516171819202122232425262728293031323334// 发送可变参数float帧（JustFloat格式，无帧头帧尾）void SCIA_sendFrame_JustFloat(int num, ...)&#123; while(isTransmitting) &#123; &#125; txBufferIndex = 0; txDataCount = 0; va_list args; va_start(args, num); int i; for(i = 0; i &lt; num; i++) &#123; float value = (float)va_arg(args, double); FloatUnion data; data.DataFloat = value; txBuffer[txDataCount++] = (uint8_t)(data.DataUint16[0] &amp; 0xFF); txBuffer[txDataCount++] = (uint8_t)((data.DataUint16[0] &gt;&gt; 8) &amp; 0xFF); txBuffer[txDataCount++] = (uint8_t)(data.DataUint16[1] &amp; 0xFF); txBuffer[txDataCount++] = (uint8_t)((data.DataUint16[1] &gt;&gt; 8) &amp; 0xFF); &#125; va_end(args); // 添加JustFloat帧尾（原来用过的: 0x00 0x00 0x80 0x7F） txBuffer[txDataCount++] = 0x00; txBuffer[txDataCount++] = 0x00; txBuffer[txDataCount++] = 0x80; txBuffer[txDataCount++] = 0x7F; isTransmitting = true; txBufferIndex = 0; SCI_enableInterrupt(SCIA_BASE, SCI_INT_TXFF);&#125; 定义可变参数，获取可变参数个数（这个是在运行时阶段获取的，跟C++的模板函数不一样） 123456va_list args;va_start(args, num);......va_end(args); 参数的访问和使用：从0-num遍历可变参数列表，float在可变参数中提升为double，遍历动作要在va_start和va_end之内，va_arg是一个出栈动作，并不是基于索引的 12345678910for(i = 0; i &lt; num; i++)&#123; float value = (float)va_arg(args, double); FloatUnion data; data.DataFloat = value; txBuffer[txDataCount++] = (uint8_t)(data.DataUint16[0] &amp; 0xFF); txBuffer[txDataCount++] = (uint8_t)((data.DataUint16[0] &gt;&gt; 8) &amp; 0xFF); txBuffer[txDataCount++] = (uint8_t)(data.DataUint16[1] &amp; 0xFF); txBuffer[txDataCount++] = (uint8_t)((data.DataUint16[1] &gt;&gt; 8) &amp; 0xFF);&#125; 总结 可变参数列表是一个数据栈，C语言函数运行调用时，参数从右到左压栈，取参数是从左到右出栈，跟函数参数调用的顺序保持一致 C++的函数模板是编译时确定的，通常会生成多份函数实例，但C语言的可变参数模板只有一份实例 C语言可以通过宏来实现C++那样的模板","tags":["C","函数"],"categories":["程序设计"]},{"title":"Linux下调试和使用Camera","path":"//linux-camera.html","content":"工具安装v4l-utils，以Ubuntu20.04为例，arm linux需要交叉编译v4l-utils源码 1sudo apt install v4l-utils 调试查看摄像头设备节点 12dmesg | grep videols /dev/video* 用v4l2命令查看摄像头节点 1v4l2-ctl --list-devices 查看设备节点支持的视频流编码格式 1v4l2-ctl --device=/dev/video0 --list-formats 可以看到video0支持MJPG和YUYV两种视频流格式 1v4l2-ctl --device=/dev/video0 --list-formats-ext 这条命令详细列举了摄像头在不同格式和分辨率下对应的帧率情况 嵌入式平台，如rk3588上查看高清摄像头支持情况 确定设备节点支持的像素格式 1v4l2-ctl -d /dev/video12 --get-fmt-video 使用初始化以MJPEG格式为例 12345678910111213141516171819202122232425262728293031323334353637383940bool CameraCapture::initDevice()&#123; fd = open(deviceName.toLocal8Bit().constData(), O_RDWR | O_NONBLOCK, 0); if (fd == -1) &#123; qWarning() &lt;&lt; &quot;Cannot open&quot; &lt;&lt; deviceName; return false; &#125; // Check capabilities struct v4l2_capability cap; if (ioctl(fd, VIDIOC_QUERYCAP, &amp;cap) == -1) &#123; qWarning() &lt;&lt; &quot;Failed to query capabilities&quot;; return false; &#125; if (!(cap.capabilities &amp; V4L2_CAP_VIDEO_CAPTURE)) &#123; qWarning() &lt;&lt; &quot;Device does not support video capture&quot;; return false; &#125; if (!(cap.capabilities &amp; V4L2_CAP_STREAMING)) &#123; qWarning() &lt;&lt; &quot;Device does not support streaming&quot;; return false; &#125; // Set format struct v4l2_format fmt = &#123;&#125;; fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; fmt.fmt.pix.width = 1280; fmt.fmt.pix.height = 720; fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_MJPEG; fmt.fmt.pix.field = V4L2_FIELD_NONE; if (ioctl(fd, VIDIOC_S_FMT, &amp;fmt) == -1) &#123; qWarning() &lt;&lt; &quot;Failed to set format&quot;; return false; &#125; return true;&#125; 申请缓存向内核态申请缓冲队列，用于缓存v4l2数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950bool CameraCapture::initMMap()&#123; struct v4l2_requestbuffers req = &#123;&#125;; req.count = 4; req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; req.memory = V4L2_MEMORY_MMAP; if (ioctl(fd, VIDIOC_REQBUFS, &amp;req) == -1) &#123; qWarning() &lt;&lt; &quot;Failed to request buffers&quot;; return false; &#125; if (req.count &lt; 2) &#123; qWarning() &lt;&lt; &quot;Insufficient buffer memory&quot;; return false; &#125; buffers = new buffer[req.count]; nBuffers = req.count; for (unsigned int i = 0; i &lt; req.count; ++i) &#123; struct v4l2_buffer buf = &#123;&#125;; buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; buf.memory = V4L2_MEMORY_MMAP; buf.index = i; if (ioctl(fd, VIDIOC_QUERYBUF, &amp;buf) == -1) &#123; qWarning() &lt;&lt; &quot;Failed to query buffer&quot;; return false; &#125; buffers[i].length = buf.length; buffers[i].start = mmap(NULL, buf.length, PROT_READ | PROT_WRITE, MAP_SHARED, fd, buf.m.offset); if (buffers[i].start == MAP_FAILED) &#123; qWarning() &lt;&lt; &quot;Failed to map buffer&quot;; return false; &#125; // Queue the buffer if (ioctl(fd, VIDIOC_QBUF, &amp;buf) == -1) &#123; qWarning() &lt;&lt; &quot;Failed to queue buffer&quot;; return false; &#125; &#125; return true;&#125; 采集指令内核开始采集缓存v4l2视频流数据 1234567// Start capturingenum v4l2_buf_type type = V4L2_BUF_TYPE_VIDEO_CAPTURE;if (ioctl(fd, VIDIOC_STREAMON, &amp;type) == -1) &#123; emit error(&quot;Failed to start streaming&quot;); uninitDevice(); return false;&#125; 数据帧处理拿到内核态mmap数据 123456789101112131415161718192021222324252627282930313233343536373839void CameraCapture::captureFrame()&#123; fd_set fds; FD_ZERO(&amp;fds); FD_SET(fd, &amp;fds); struct timeval tv = &#123;&#125;; tv.tv_sec = 2; tv.tv_usec = 0; int r = select(fd + 1, &amp;fds, nullptr, nullptr, &amp;tv); if (r == -1) &#123; emit errorOccurred(&quot;select错误&quot;); &#125; else if (r == 0) &#123; emit errorOccurred(&quot;采集超时&quot;); &#125; struct v4l2_buffer buf = &#123;&#125;; buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; buf.memory = V4L2_MEMORY_MMAP; if (ioctl(fd, VIDIOC_DQBUF, &amp;buf) == -1) &#123; emit errorOccurred(&quot;获取帧失败&quot;); &#125; QByteArray frameData(static_cast&lt;char*&gt;(buffers[buf.index].start), buf.bytesused); // 重新将缓冲区放入队列 if (ioctl(fd, VIDIOC_QBUF, &amp;buf) == -1) &#123; emit errorOccurred(&quot;缓冲区重新入队失败&quot;); &#125; if (!frameData.isEmpty()) &#123; QImage image = decoder-&gt;decode(frameData); if (!image.isNull()) &#123; emit newFrame(image); &#125; &#125;&#125; MJPEG转换MJPEG数据转可视化图像 123456789101112131415161718192021222324252627282930313233343536QImage MJpegDecoder::decode(const QByteArray &amp;mjpegData) &#123; struct jpeg_decompress_struct cinfo; struct jpeg_error_mgr jerr; cinfo.err = jpeg_std_error(&amp;jerr); jpeg_create_decompress(&amp;cinfo); jpeg_mem_src(&amp;cinfo, reinterpret_cast&lt;const unsigned char*&gt;(mjpegData.constData()), mjpegData.size()); if (jpeg_read_header(&amp;cinfo, TRUE) != JPEG_HEADER_OK) &#123; emit errorOccurred(&quot;JPEG头解析失败&quot;); jpeg_destroy_decompress(&amp;cinfo); return QImage(); &#125; if (jpeg_start_decompress(&amp;cinfo) != TRUE) &#123; emit errorOccurred(&quot;JPEG解码启动失败&quot;); jpeg_destroy_decompress(&amp;cinfo); return QImage(); &#125; QImage image(cinfo.output_width, cinfo.output_height, QImage::Format_RGB888); JSAMPARRAY buffer = (*cinfo.mem-&gt;alloc_sarray)((j_common_ptr)&amp;cinfo, JPOOL_IMAGE, cinfo.output_width * cinfo.output_components, 1); while (cinfo.output_scanline &lt; cinfo.output_height) &#123; jpeg_read_scanlines(&amp;cinfo, buffer, 1); uchar *dest = image.scanLine(cinfo.output_scanline - 1); memcpy(dest, buffer[0], cinfo.output_width * cinfo.output_components); &#125; jpeg_finish_decompress(&amp;cinfo); jpeg_destroy_decompress(&amp;cinfo); return image;&#125; 在位信号判断video节点是否具备采集视频信号的能力（这个大多数情况下都需要，尤其是汽车电子，开机自检硬件设备是否正常） 12345678910111213141516171819202122232425int CameraCapture::is_video_capture_device(const char *device_path) &#123; int fd = open(device_path, O_RDWR); if (fd == -1) &#123; perror(&quot;Failed to open device&quot;); return 0; &#125; struct v4l2_capability cap = &#123;0&#125;; if (ioctl(fd, VIDIOC_QUERYCAP, &amp;cap) == -1) &#123; perror(&quot;Failed to query capabilities&quot;); close(fd); return 0; &#125; close(fd); // 检查是否支持视频捕获 if (cap.capabilities &amp; V4L2_CAP_VIDEO_CAPTURE_MPLANE) &#123; printf(&quot;%s 是一个视频捕获设备（如摄像头） &quot;, device_path); return 1; &#125; else &#123; printf(&quot;%s 不是视频捕获设备 &quot;, device_path); return 0; &#125;&#125; 图像显示图像显示可以用QLabel直接显示或者通过QPainter自绘，这里不再详细展开 12345void MainWindow::updateFrame(const QImage &amp;frame)&#123; imageLabel-&gt;setPixmap(QPixmap::fromImage(frame).scaled( imageLabel-&gt;width(), imageLabel-&gt;height(), Qt::KeepAspectRatio));&#125; 开源工程https://github.com/hywing/v4l2-camera","tags":["Linux","Camera"],"categories":["嵌入式"]},{"title":"Linux设备树详解","path":"//linux-devicetree.html","content":"前言曾经有大神跟我说Linux驱动的本质是读写寄存器，我不以为然，直到后来我认真理解了Linux的设备树机制 …… 节点根节点的定义，以/开头，它可以跨多个文件定义 123/ &#123; ......&#125; SOC信息描述，以RK3399 SOC为例 12model = &quot;Rockchip RK3399 Excavator Board (Linux Opensource)&quot;;compatible = &quot;rockchip,rk3399-excavator-v10-linux&quot;, &quot;rockchip,rk3399&quot;; 普通的节点定义，不带标签意味着它不需要在别处引用 123gpio-keys &#123; ......&#125;; 带标签是为了在别处能够访问，格式：标签名: 节点名，后面跟一个括号{ … }； 1234/* 标签名: 节点名 */gpio_keys: gpio-keys &#123; ......&#125;; 通常使用&amp;标签名来引用一个节点，引用一个节点意味着追加、补充这个节点的配置信息 1234/* 追加、补充这个节点的配置信息 */&amp;gpio_keys &#123; ......&#125;; 匹配信息，用compatible表示，这个相当于节点的身份信息 1compatible = &quot;gpio-keys&quot;; 寄存器寄存器定义格式：&lt;高32位地址 低32位地址 高32位长度 低32位长度&gt;，由于RK3399是64位处理器的缘故，address-cells为1代表4个字节 1234567i2c0: i2c@ff3c0000 &#123; compatible = &quot;rockchip,rk3399-i2c&quot;; reg = &lt;0x0 0xff3c0000 0x0 0x1000&gt;; #address-cells = &lt;1&gt;; #size-cells = &lt;0&gt;; status = &quot;disabled&quot;;&#125;; 时钟源一般可选多个时钟源，看外设的需要，i2c需要2个时钟源：一个给SCL，一个提供寄存器访问，时钟源信息一般在./include/dt-bindings/clock/rk3399-cru.h里边给出，clocks和clock-names是按顺序匹配的 12clocks = &lt;&amp;pmucru SCLK_I2C0_PMU&gt;, &lt;&amp;pmucru PCLK_I2C0_PMU&gt;;clock-names = &quot;i2c&quot;, &quot;pclk&quot;; 中断中断配置存在头文件当中：include&#x2F;dt-bindings&#x2F;interrupt-controller&#x2F;arm-gic.h和include&#x2F;dt-bindings&#x2F;interrupt-controller&#x2F;irq.h 1interrupts = &lt;GIC_SPI 57 IRQ_TYPE_LEVEL_HIGH 0&gt;; GPIORK3399 GPIO0表示第0个bank的GPIO，第0个bank的GPIO索引：0-31，分为A、B、C、D四组，以下对应的是GPIO0_B4管脚：B代表1，1x8+4&#x3D;12 1gpios = &lt;&amp;gpio0 12 GPIO_ACTIVE_LOW&gt;; 以下对应的是GPIO4_C6管脚：C代表2，2x8+6&#x3D;22 1gpios = &lt;&amp;gpio4 22 GPIO_ACTIVE_HIGH&gt;; 引脚引脚复用（也就是说一个引脚它可能是GPIO，也可以是USART_RXD，或者是I2C_SCL） 12pinctrl-names = &quot;default&quot;;pinctrl-0 = &lt;&amp;i2c0_xfer&gt;; 补充定义pinctrl 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&amp;pinctrl &#123; sdmmc-pwrseq &#123; sdcard_enable_h: sdcard-enable-h &#123; rockchip,pins = &lt;1 20 RK_FUNC_GPIO &amp;pcfg_pull_none&gt;; &#125;; &#125;; /* add by cym 20190508 */ lsm330_a &#123; lsm330a_irq_gpio: lsm330a-irq-gpio &#123; rockchip,pins = &lt;1 22 RK_FUNC_GPIO &amp;pcfg_pull_none&gt;; &#125;; &#125;; lsm330_g &#123; lsm330g_irq_gpio: lsm330g-irq-gpio &#123; rockchip,pins = &lt;1 24 RK_FUNC_GPIO &amp;pcfg_pull_none&gt;; &#125;; &#125;; ak8963 &#123; ak8963_irq_gpio: ak8963-irq-gpio &#123; rockchip,pins = &lt;1 0 RK_FUNC_GPIO &amp;pcfg_pull_none&gt;; &#125;; &#125;; cm3218 &#123; cm3218_irq_gpio: cm3218-irq-gpio &#123; rockchip,pins = &lt;4 24 RK_FUNC_GPIO &amp;pcfg_pull_up&gt;; &#125;; &#125;; leds &#123; led1_ctl: led1-ctl &#123; rockchip,pins = &lt;0 12 RK_FUNC_GPIO &amp;pcfg_pull_up&gt;; &#125;; &#125;; buzzer &#123; beep_gpio: beep-gpio &#123; rockchip,pins = &lt;4 22 RK_FUNC_GPIO &amp;pcfg_pull_up&gt;; &#125;; &#125;; gt911 &#123; gt911_gpio: gt911-gpio &#123; rockchip,pins = &lt;1 9 RK_FUNC_GPIO &amp;pcfg_pull_up&gt;,&lt;1 20 RK_FUNC_GPIO &amp;pcfg_pull_up&gt;; &#125;; &#125;; /* end add */ lcd-panel &#123; lcd_panel_reset: lcd-panel-reset &#123; /*rockchip,pins = &lt;2 27 RK_FUNC_GPIO &amp;pcfg_pull_down&gt;;*/ rockchip,pins = &lt;4 RK_PD6 RK_FUNC_GPIO &amp;pcfg_pull_none&gt;; &#125;; lcd_panel_pwr_en: lcd-panel-pwr-en &#123; rockchip,pins = &lt;3 16 RK_FUNC_GPIO &amp;pcfg_pull_down&gt;; lcd_panel_lcd_en:lcd-panel-lcd-en &#123; rockchip,pins = &lt;1 4 RK_FUNC_GPIO &amp;pcfg_pull_down&gt;; &#125;; &#125;; &#125;;&#125;; IO复用需要通过标签名方式来引用，以下代码的sdmmc-pwrseq、lsm330_a、lsm330_g … 是分类的作用 功能模块 节点标签 引脚位置 复用功能 电气属性 SD卡电源控制 sdcard_enable_h GPIO1_B4 (Bank1, Pin20) RK_FUNC_GPIO 无上下拉 (none) 加速度计 lsm330a_irq_gpio GPIO1_B6 (Bank1, Pin22) RK_FUNC_GPIO 无上下拉 (none) 陀螺仪 lsm330g_irq_gpio GPIO1_B8 (Bank1, Pin24) RK_FUNC_GPIO 无上下拉 (none) 磁力计 ak8963_irq_gpio GPIO1_A0 (Bank1, Pin0) RK_FUNC_GPIO 无上下拉 (none) 光传感器 cm3218_irq_gpio GPIO4_D0 (Bank4, Pin24) RK_FUNC_GPIO 上拉 (pull_up) LED控制 led1_ctl GPIO0_B4 (Bank0, Pin12) RK_FUNC_GPIO 上拉 (pull_up) 蜂鸣器 beep_gpio GPIO4_C6 (Bank4, Pin22) RK_FUNC_GPIO 上拉 (pull_up) 触摸屏 gt911_gpio GPIO1_A9 (Bank1, Pin9) RK_FUNC_GPIO 上拉 (pull_up) GPIO1_B4 (Bank1, Pin20) RK_FUNC_GPIO 上拉 (pull_up) LCD面板 lcd_panel_reset GPIO4_D6 (Bank4, Pin30) RK_FUNC_GPIO 无上下拉 (none) lcd_panel_pwr_en GPIO3_D0 (Bank3, Pin16) RK_FUNC_GPIO 下拉 (pull_down) lcd_panel_lcd_en GPIO1_A4 (Bank1, Pin4) RK_FUNC_GPIO 下拉 (pull_down) 节点状态用status字段表示：一般有okay和disabled两种状态 1status = &quot;disabled&quot;; 答疑 引用节点的话可以改变原有的内容吗？还是只能新增 → 答：补充和新增 RK3399的GPIO映射关系：参考上面GPIO小结 → 答：一个BANK（0-31）分为A、B、C、D四组 根节点可以放在多个文件之中吗？ → 答：可以的 术语 dtc：device tree compiler，设备树编译工具 dts：device tree source，设备树源文件 dtsi：device tree source include，设备树头文件 dtb：device tree blob，设备树文件（二进制）","tags":["Linux","设备树"],"categories":["嵌入式"]},{"title":"跨平台SDK设计原则","path":"//crossplatform-sdk.html","content":"路径依赖1.不要重复造轮子，尽量选用久经考验的跨平台库，如boost、yaml、pcap、vtk、cjson等，这样能把设计和测试成本降到最低 2.构建工具优先选用cmake，cmake在Windows、Linux、Mac OS平台都有很好的支持，支持图形化配置 3.编程语言优先选用成熟、稳定的版本，如C++选用2011版本，不要使用太花里胡哨的特性 数据类型1.数据类型尽量能够多平台通用，如cstdint类型、boost跨平台类型 2.字节对齐，注意字节序 3.有些硬件并不支持双精度浮点数，例如全志T3芯片，如果没有精度要求建议浮点数默认float而非double 4.管理内存推荐使用智能指针，减少深拷贝 5.性能不行可以使用数据表，用空间换时间，比如三角函数的计算，避免重复计算开销很大的数据对象 通信协议1.版本号，这个字段是考虑到变更风险，嵌入式领域硬件的变更代价是很大的，往往需要软件来买单（擦屁股） 2.数据校验，防止数据丢失（很多时候不清楚用户在什么样的电磁环境下测试），可以参考modus的协议设计 3.尽量不要依赖配置文件，协议应该能够充分解决依赖 设计原则1.单一接口原则，高内聚，隔离实现，头文件不暴露无关的细节，不想给源码就要剥离你的实现 2.流程尽量简单高效，不给使用者带来额外消耗，比如吃别人的算力（这个是道德底线） 3.代码可读性良好，尽量少用模板，枚举优于宏定义，typedef优于宏替换 4.做好防御性编程（assert、数组边界判断、杜绝空指针悬指针），SDK应该在调试阶段尽量多的发现自身的问题 5.传感器（LiDAR、IMU、Camera、GNSS等）的数据处理都可以理解为一个数据驱动的模型：生产者+消费者","tags":["跨平台","SDK"],"categories":["程序设计"]},{"title":"DSP适配VOFA+ JustFloat协议","path":"//dsp-justfloat-protocal.html","content":"配置SCI配置引脚，支持中断+FIFO 1234567891011121314151617181920212223242526272829void initSCIAFIFO(void)&#123; // 配置GPIO引脚 GPIO_setMasterCore(43, GPIO_CORE_CPU1); GPIO_setPinConfig(GPIO_43_SCIRXDA); GPIO_setDirectionMode(43, GPIO_DIR_MODE_IN); GPIO_setPadConfig(43, GPIO_PIN_TYPE_STD); GPIO_setQualificationMode(43, GPIO_QUAL_ASYNC); GPIO_setMasterCore(42, GPIO_CORE_CPU1); GPIO_setPinConfig(GPIO_42_SCITXDA); GPIO_setDirectionMode(42, GPIO_DIR_MODE_OUT); GPIO_setPadConfig(42, GPIO_PIN_TYPE_STD); GPIO_setQualificationMode(42, GPIO_QUAL_ASYNC); // 配置SCI模块 SCI_disableModule(SCIA_BASE); SCI_performSoftwareReset(SCIA_BASE); SCI_setConfig(SCIA_BASE, DEVICE_LSPCLK_FREQ, 115200, (SCI_CONFIG_WLEN_8 | SCI_CONFIG_STOP_ONE | SCI_CONFIG_PAR_NONE)); // 配置FIFO SCI_enableFIFO(SCIA_BASE); SCI_resetTxFIFO(SCIA_BASE); SCI_setFIFOInterruptLevel(SCIA_BASE, SCI_FIFO_TX8, SCI_FIFO_RX4); SCI_enableModule(SCIA_BASE);&#125; 全局中断配置，在main函数里边初始化中断 12345678910111213141516171819void main(void)&#123; // 初始化设备 Device_init(); Device_initGPIO(); Board_init(); // 初始化SCI initSCIAFIFO(); // 初始化中断 Interrupt_initModule(); Interrupt_initVectorTable(); Interrupt_register(INT_SCIA_TX, sciaTXFIFOISR); Interrupt_enable(INT_SCIA_TX); ...... &#125; 实现发送中断服务函数，跟阻塞式发送不一样的是，我们需要使用非阻塞式接口：SCI_writeCharNonBlocking 12345678910111213141516__interrupt void sciaTXFIFOISR(void)&#123; while((txBufferIndex &lt; txDataCount) &amp;&amp; (SCI_getTxFIFOStatus(SCIA_BASE) != SCI_FIFO_TX15)) &#123; SCI_writeCharNonBlocking(SCIA_BASE, txBuffer[txBufferIndex++]); &#125; if((txBufferIndex &gt;= txDataCount) &amp;&amp; (SCI_getTxFIFOStatus(SCIA_BASE) == SCI_FIFO_TX0)) &#123; isTransmitting = false; SCI_disableInterrupt(SCIA_BASE, SCI_INT_TXFF); &#125; SCI_clearInterruptStatus(SCIA_BASE, SCI_INT_TXFF); Interrupt_clearACKGroup(INTERRUPT_ACK_GROUP9);&#125; JustFloat自定义单帧数据类型：Float类型数据，使用union是为了方便通过uint16_t的方式进行序列化 123456789// 全局变量定义#define TX_BUFFER_SIZE 32#define CH_COUNT 5#define PI 3.14159265358979323846ftypedef union &#123; float DataFloat; uint16_t DataUint16[2];&#125; FloatUnion; 实现单帧数据的发送：确保帧尾能对的上，每一次发送都要发送使能中断，第一次需要手动触发发送中断 123456789101112131415161718192021222324252627282930313233343536373839404142void SCIA_sendFrame(float chn1, float chn2, float chn3, float chn4, float chn5)&#123; while(isTransmitting) &#123; &#125; FloatUnion data[CH_COUNT]; data[0].DataFloat = chn1; data[1].DataFloat = chn2; data[2].DataFloat = chn3; data[3].DataFloat = chn4; data[4].DataFloat = chn5; txBufferIndex = 0; txDataCount = 0; int i; for(i = 0; i &lt; CH_COUNT; i++) &#123; txBuffer[txDataCount++] = (uint8_t)(data[i].DataUint16[0] &amp; 0xFF); txBuffer[txDataCount++] = (uint8_t)((data[i].DataUint16[0] &gt;&gt; 8) &amp; 0xFF); txBuffer[txDataCount++] = (uint8_t)(data[i].DataUint16[1] &amp; 0xFF); txBuffer[txDataCount++] = (uint8_t)((data[i].DataUint16[1] &gt;&gt; 8) &amp; 0xFF); &#125; // 添加帧尾 (00 00 80 7F) txBuffer[txDataCount++] = 0x00; txBuffer[txDataCount++] = 0x00; txBuffer[txDataCount++] = 0x80; txBuffer[txDataCount++] = 0x7F; // 开始传输 isTransmitting = true; txBufferIndex = 0; SCI_enableInterrupt(SCIA_BASE, SCI_INT_TXFF); // 手动触发第一次发送 while((txBufferIndex &lt; txDataCount) &amp;&amp; (SCI_getTxFIFOStatus(SCIA_BASE) != SCI_FIFO_TX15)) &#123; SCI_writeCharNonBlocking(SCIA_BASE, txBuffer[txBufferIndex++]); &#125;&#125; 模拟数据我们来实现模拟数据 1234567891011121314151617181920// 主循环 float angle = 0.0f; // 从0开始 while(1) &#123; float normalized_angle = normalize_angle(angle); float sin_val; float cos_val; // 计算三角函数值并限制范围 sin_val = limit_range(sinf(normalized_angle), -1.0f, 1.0f); cos_val = limit_range(cosf(normalized_angle*2), -1.0f, 1.0f); SCIA_sendFrame(angle, round_to_2_decimal(sin_val), round_to_2_decimal(sin_val+cos_val), limit_range(round_to_2_decimal(sin_val * cos_val), -1.0f, 1.0f), limit_range(round_to_2_decimal(cos_val * cos_val), 0.0f, 1.0f)); angle += 0.1f; DEVICE_DELAY_US(10); &#125; 值得一提的是，三角函数它是通过查表法来实现的，angle值太大会有误差，我们需要设计归一化函数 123456789101112131415161718192021222324252627282930313233343536373839// 将角度归一化到[-2π, 2π]范围内float normalize_angle(float angle)&#123; const float two_pi = 2.0f * PI; float normalized = fmodf(angle, two_pi); if(normalized &lt; -PI) normalized += two_pi; if(normalized &gt; PI) normalized -= two_pi; return normalized;&#125;// 保留2位小数的函数float round_to_2_decimal(float value)&#123; // 使用更稳定的舍入方法 const float factor = 100.0f; float temp = value * factor; // 处理正负数 if(temp &gt;= 0.0f) &#123; temp = floorf(temp + 0.5f); &#125; else &#123; temp = ceilf(temp - 0.5f); &#125; // 避免除以0 if(fabsf(temp) &lt; 1e-6f) &#123; return 0.0f; &#125; return temp / factor;&#125;// 限制数值范围的函数float limit_range(float value, float min, float max)&#123; if(value &gt; max) return max; if(value &lt; min) return min; return value;&#125; 运行效果VOFA+的实时运行效果：显示5个通道的波形数据","tags":["DSP","VOFA+","FIFO","JustFloat"],"categories":["嵌入式","程序设计"]},{"title":"Shell脚本执行不了的问题","path":"//linux-bash-script-problem.html","content":"问题Windows上面提交shell脚本，然后在Linux下检出容易出现脚本执行不了的情况，因为Windows是使用Windows（CR LF）格式的，而Linux采用Unix（LF），bash终端一般识别不了前者，一旦部署到ARM Linux那也肯定出问题 解决 尽量避免在Windows提交shell脚本：实际工作中很多人都喜欢用Windows做开发，尽管开发的是Linux应用 使用vim编辑器，输入命令set ff查看脚本格式，如果是dos格式，则输入命令set ff=unix即可纠正过来","tags":["Linux","Bash"],"categories":["操作系统"]},{"title":"Linux Bash常用快捷键","path":"//linux-bash-common-shortcuts.html","content":"清屏CTRL + L 上一条命令CTRL + P 下一条命令CTRL + N 执行命令CTRL + M CTRL + O 命令补全CTRL + I 删除字符至最前面CTRL + U 删除字符至最后面CTRL + K 删除整个单词（向前）注意：遇到空白符结束 CTRL + W 删除整个单词（向后）注意：遇到空白符结束 CTRL + D 删除一个字符（往前）CTRL + H 光标移动最前CTRL + A 光标移动最后CTRL + E 光标向前移动一格CTRL + F 光标向后移动一格CTRL + B 光标移动当前单词最前Alt + F 光标移动当前单词最后Alt + B 命令查找（向后）CTRL + R 命令查找（向前）CTRL + SHIFT + R 冻结终端CTRL + S 解冻终端CTRL + Q 中止命令CTRL + C 挂起命令CTRL + Z 复制当前命令CTRL + Y","tags":["Linux","Bash"],"categories":["开发工具","操作系统"]},{"title":"三角函数的使用","path":"//trig-functions-usage.html","content":"问题当浮点数很大时，作为三角函数的入参，计算出来的结果会让人大跌眼镜！ X64 Windows平台MSVC2017编译器计算的sin(110000)，上面那个数值明显是不对的 分析查看sinf函数原型，是通过查表法来实现的，也就说芯片内部不可能维护一个巨大的表格，入参很大会有误差 12345678910111213141516171819//! \\brief Single-Precision Floating-Point Sine (radians)//! \\param[in] X single precision floating point argument//! \\return the sine of a floating-point argument X (in radians) using table//! look-up and Taylor series expansion between the look-up table entries.//!//! ote //! -# This is a standard C math function and requires &quot;math.h&quot; to be //! included//! -# For COFF executables float and double are both single precision//! 32-bit floating point types, therefore, the double and float variant of //! this function may be used interchangeably.//!//! &lt;table&gt;//! &lt;caption id=&quot;multi_row&quot;&gt;Performance Data&lt;/caption&gt;//! &lt;tr&gt;&lt;th&gt;Cycles &lt;th&gt; Comment //! &lt;tr&gt;&lt;td&gt; 38 &lt;td&gt; Cycle count includes the call and return//! &lt;/table&gt;//float32_t sinf (float32_t X); 解决需要将角度值限制在±2π范围内（理论上说这个范围内的精度是最好的） 123456789// 将角度归一化到[-2π, 2π]范围内float normalize_angle(float angle)&#123; const float two_pi = 2.0f * PI; float normalized = fmodf(angle, two_pi); if(normalized &lt; -PI) normalized += two_pi; if(normalized &gt; PI) normalized -= two_pi; return normalized;&#125; 调试看归一化后的函数值 总结我们学过高等数学，了解到可以通过泰勒级数逼近的方式来计算三角函数的值，就是不停地计算多项式的值 但是在嵌入式平台一般倾向于使用查表法（空间换时间）来计算 x sin(x) 1 0.841471 2 0.909297 3 0.141120 4 -0.756802","tags":["DSP","三角函数"],"categories":["嵌入式"]},{"title":"Code Composer Studio快捷键","path":"//ccs-shortcuts.html","content":"文本编辑编辑、查找、替换功能快捷键 功能 快捷键 撤销 Cut+Z 重做 Cut+Y 剪切 Ctrl+X 复制 Ctrl+C 粘贴 Ctrl+V 删除 Delete 全选 Ctrl+A 代码块选中 Alt+Shift+A 查找、替换 Ctrl + F 查找下一个匹配的字符串 Ctrl+K 查找上一个匹配的字符串 Ctrl+Shift+K 查看接口注释（文档） F2 查看函数帮助（参数） Alt+&#x2F; 或者 Alt+? 光标向前跳转 Ctrl+Alt+➡ 光标向后跳转 Ctrl+Alt+⬅ 调试调试功能快捷键 功能 快捷键 继续 F8 暂停 Alt+F8 停止运行 Ctrl+F2 单步进入 F5 单步跳过 F6 单步返回 F7 构建所有工程 Ctrl+B 调试 F11 断点新增&#x2F;移除 Ctrl+Shift+B 跳过所有断点 Ctrl+Alt+B 视图按Alt+Shift+Q快捷键会弹出一个菜单列表，可以根据需要选择对应的窗口 功能 快捷键 Scripting Console（脚本控制台） Alt+Shift+Q, I Show View（主视图） Alt+Shift+Q, Q Show View (Breakpoints)（断点窗口） Alt+Shift+Q, B Show View (Cheat Sheets) Alt+Shift+Q, H Show View (Console)（控制台窗口） Alt+Shift+Q, C Show View (Error Log)（错误日志窗口） Alt+Shift+Q, L Show View (History)（历史窗口） Alt+Shift+Q, Z Show View (Outline)（大纲窗口） Alt+Shift+Q, O Show View (Problems)（问题窗口） Alt+Shift+Q, X Show View (Search)（搜索窗口） Alt+Shift+Q, S Show View (Synchronize) Alt+Shift+Q, Y Show View (Variables)（调试变量窗口） Alt+Shift+Q, V","tags":["DSP","CCS"],"categories":["嵌入式","开发工具"]},{"title":"关于DSP数据类型长度和数据转换的思考","path":"//dsp-data-size.html","content":"介绍在dsp中写一个保留2位小数的函数 12345// 保留2位小数的函数float round_to_2_decimal(float value)&#123; return (float)((int)(value * 100 + 0.5f)) / 100.0f;&#125; dsp通过SCI串口传给上位机的浮点数据累加到一定程度莫名其妙的就不能增长了！ 思考上面的数据看上去只有2个字节，数据转换的中间环节肯定出了问题，要么是float要么是int，查看limits.h发现int数据大小有上限，为32767 另外调试也惊喜的发现各类型的数据大小：int居然为1（我觉得应该是编译器的原因，sizeof是运算符，dsp是16位的，所以int的实际大小应该是16x1，float大小为16x2） 解决正确写法：包含stdint.h，使用int32_t类型，这下就能够使用32位的数据了 12345// 保留2位小数的函数float round_to_2_decimal(float value)&#123; return (float)((int32_t)(value * 100 + 0.5f)) / 100.0f;&#125; 当然，也可以使用F2837xd_device.h里边的类型，这里也佐证了int是16位的！ 12345678typedef int int16;typedef long int32;typedef long long int64;typedef unsigned int Uint16;typedef unsigned long Uint32;typedef unsigned long long Uint64;typedef float float32;typedef long double float64; 注意：int32_t也是有范围的：-2,147,483,648 ~ 2,147,483,647，当value大到一定程度时(int32_t)(value * 100 + 0.5f)会得到一个越界的数值，正确的做法如下： 123456789101112// 保留2位小数的函数float round_to_2_decimal(float value)&#123; // 使用更稳定的舍入方法，避免大数精度问题 float temp = value * 100.0f; if(temp &gt;= 0.0f) &#123; temp = floorf(temp + 0.5f); &#125; else &#123; temp = ceilf(temp - 0.5f); &#125; return temp / 100.0f;&#125; 总结为了程序的兼容性和跨平台，建议统一使用stdint.h里边的类型","tags":["DSP","LAUNCHXL-F28379D","int"],"categories":["嵌入式"]},{"title":"LAUNCHXL-F28379D SCI中断配置","path":"//launchxl-f28379d-sci-interrupt-fifo.html","content":"GPIOSCI GPIO映射 GPIO43初始化：由CPU1控制、复用为SCI接收引脚、输入模式、标准推挽&#x2F;浮空配置、异步输入限定模式 12345678//// GPIO43 is the SCI Rx pin.//GPIO_setMasterCore(43, GPIO_CORE_CPU1);GPIO_setPinConfig(GPIO_43_SCIRXDA);GPIO_setDirectionMode(43, GPIO_DIR_MODE_IN);GPIO_setPadConfig(43, GPIO_PIN_TYPE_STD);GPIO_setQualificationMode(43, GPIO_QUAL_ASYNC); GPIO42初始化：由CPU1控制、复用为SCI发送引脚、输出模式、标准推挽&#x2F;浮空配置、异步输出限定模式 12345678//// GPIO42 is the SCI Tx pin.//GPIO_setMasterCore(42, GPIO_CORE_CPU1);GPIO_setPinConfig(GPIO_42_SCITXDA);GPIO_setDirectionMode(42, GPIO_DIR_MODE_OUT);GPIO_setPadConfig(42, GPIO_PIN_TYPE_STD);GPIO_setQualificationMode(42, GPIO_QUAL_ASYNC); GPIO函数功能说明 函数名 参数 返回值 功能说明 GPIO_setMasterCore pin: uint32_t (GPIO引脚号)core: GPIO_CoreSelect (控制器核心) void 设置指定GPIO引脚由哪个核心控制。core可选值:- GPIO_CORE_CPU1- GPIO_CORE_CPU1_CLA1- GPIO_CORE_CPU2- GPIO_CORE_CPU2_CLA1 GPIO_setPinConfig pinConfig: uint32_t (引脚配置值) void 配置GPIO引脚的多路复用功能（配置值在pin_map.h中定义，如GPIO_43_SCIRXDA） GPIO_setDirectionMode pin: uint32_t (GPIO引脚号)pinIO: GPIO_Direction (方向模式) void 设置GPIO引脚方向模式。pinIO可选值:- GPIO_DIR_MODE_IN- GPIO_DIR_MODE_OUT GPIO_setPadConfig pin: uint32_t (GPIO引脚号)pinType: uint32_t (引脚类型) void 设置GPIO引脚的电气特性。pinType可选值:- GPIO_PIN_TYPE_STD- GPIO_PIN_TYPE_PULLUP- GPIO_PIN_TYPE_OD- GPIO_PIN_TYPE_INVERT（可组合使用） GPIO_setQualificationMode pin: uint32_t (GPIO引脚号)qualification: GPIO_QualificationMode void 设置输入限定模式。qualification可选值:- GPIO_QUAL_SYNC- GPIO_QUAL_3SAMPLE- GPIO_QUAL_6SAMPLE- GPIO_QUAL_ASYNC 串口串口参数配置：115200、8、1、N，这个配置很简单，不做详细介绍 123456//// 8 char bits, 1 stop bit, no parity. Baud rate is 115200.//SCI_setConfig(SCIA_BASE, DEVICE_LSPCLK_FREQ, 115200, (SCI_CONFIG_WLEN_8 | SCI_CONFIG_STOP_ONE | SCI_CONFIG_PAR_NONE)); FIFOSCIA FIFO配置 12345678910111213141516SCI_enableModule(SCIA_BASE);SCI_resetChannels(SCIA_BASE);SCI_enableFIFO(SCIA_BASE);//// RX and TX FIFO Interrupts Enabled//SCI_enableInterrupt(SCIA_BASE, (SCI_INT_RXFF | SCI_INT_TXFF));SCI_disableInterrupt(SCIA_BASE, SCI_INT_RXERR);// Set FIFO interrupt levels to 32 charactersSCI_setFIFOInterruptLevel(SCIA_BASE, SCI_FIFO_TX16, SCI_FIFO_RX16);SCI_performSoftwareReset(SCIA_BASE);SCI_resetTxFIFO(SCIA_BASE);SCI_resetRxFIFO(SCIA_BASE); 枚举类型 SCI_TxFIFOLevel 定义了 SCI（串行通信接口）模块发送 FIFO 的中断触发水位线级别，用于配置何时触发发送 FIFO 中断 枚举值 值（十六进制） 含义 典型应用场景 SCI_FIFO_TX0 0x0000 FIFO 完全空时触发中断 高实时性要求，需立即补充数据 SCI_FIFO_TX1 0x0001 FIFO 剩余 15&#x2F;16 满（即已发送1个字节）时触发 低延迟传输 SCI_FIFO_TX2 0x0002 FIFO 剩余 14&#x2F;16 满时触发 … … … SCI_FIFO_TX15 0x000F FIFO 剩余 1&#x2F;16 满（即已发送15个字节）时触发 平衡中断频率和响应速度 SCI_FIFO_TX16 0x0010 FIFO 完全满时触发中断 错误检测（通常避免使用） FIFO配置流程： SCI_enableModule(SCIA_BASE) 使能SCI模块 这是使用SCI通信的第一步，必须先使能模块才能进行其他配置 SCI_resetChannels(SCIA_BASE) 复位SCI通道 清除所有通道相关的配置和状态 确保从一个干净的状态开始配置 SCI_enableFIFO(SCIA_BASE) 使能SCI的FIFO功能 FIFO(First In First Out)缓冲区可以提高数据传输效率 允许在发送和接收时缓存多个数据 SCI_enableInterrupt(SCIA_BASE, (SCI_INT_RXFF | SCI_INT_TXFF)) 使能FIFO相关的中断 SCI_INT_RXFF: 接收FIFO中断，当接收FIFO达到设定水平时触发 SCI_INT_TXFF: 发送FIFO中断，当发送FIFO低于设定水平时触发 使用位或运算(|)同时使能这两个中断 SCI_disableInterrupt(SCIA_BASE, SCI_INT_RXERR) 禁用接收错误中断 SCI_INT_RXERR包括帧错误、溢出错误等 在这个例子中不需要处理这些错误 SCI_setFIFOInterruptLevel(SCIA_BASE, SCI_FIFO_TX16, SCI_FIFO_RX16) 设置FIFO中断触发水平 SCI_FIFO_TX16: 当发送FIFO中数据少于16个时触发中断 SCI_FIFO_RX16: 当接收FIFO中数据达到16个时触发中断 这些值可以根据需要调整，以平衡实时性和系统负载 SCI_performSoftwareReset(SCIA_BASE) 执行SCI软件复位 清除所有配置和状态 确保之前的配置完全生效 SCI_resetTxFIFO(SCIA_BASE) 和 SCI_resetRxFIFO(SCIA_BASE) 分别复位发送和接收FIFO 清空FIFO缓冲区 确保没有残留的旧数据 中断发送和接收中断服务函数：SCI_clearInterruptStatus和Interrupt_clearACKGroup两个步骤是必要的 123456789101112131415161718192021222324252627282930313233343536373839404142434445//// sciaTXFIFOISR - SCIA Transmit FIFO ISR//__interrupt void sciaTXFIFOISR(void)&#123; SCI_clearInterruptStatus(SCIA_BASE, SCI_INT_TXFF); // // Issue PIE ACK // Interrupt_clearACKGroup(INTERRUPT_ACK_GROUP9);&#125;//// sciaRXFIFOISR - SCIA Receive FIFO ISR//__interrupt void sciaRXFIFOISR(void)&#123; uint16_t i; uint16_t rxCount; // Read received data rxCount = SCI_getRxFIFOStatus(SCIA_BASE) &amp; 0x7F; // Get number of words in RX FIFO if(rxCount &gt; 32) rxCount = 32; // Read all received data for(i = 0; i &lt; rxCount; i++) &#123; rDataA[i] = SCI_readCharNonBlocking(SCIA_BASE); &#125; // Echo back all received data for(i = 0; i &lt; rxCount; i++) &#123; SCI_writeCharNonBlocking(SCIA_BASE, rDataA[i]); &#125; SCI_clearOverflowStatus(SCIA_BASE); SCI_clearInterruptStatus(SCIA_BASE, SCI_INT_RXFF); // // Issue PIE ack // Interrupt_clearACKGroup(INTERRUPT_ACK_GROUP9);&#125; 发送和接收中断使能 12345678910111213141516171819202122//// Initialize PIE and clear PIE registers. Disables CPU interrupts.//Interrupt_initModule();//// Initialize the PIE vector table with pointers to the shell Interrupt// Service Routines (ISR).//Interrupt_initVectorTable();//// Interrupts that are used in this example are re-mapped to// ISR functions found within this file.//Interrupt_register(INT_SCIA_RX, sciaRXFIFOISR);Interrupt_register(INT_SCIA_TX, sciaTXFIFOISR); Interrupt_enable(INT_SCIA_RX);Interrupt_enable(INT_SCIA_TX);Interrupt_clearACKGroup(INTERRUPT_ACK_GROUP9); 第一次发送传输时记得手动使能中断函数 1Interrupt_enable(INT_SCIA_TX); 中断的配置流程： Interrupt_initModule() 初始化外设中断扩展模块(PIE) 清除所有PIE寄存器 禁用CPU中断 这是配置中断系统的第一步，确保从一个干净的状态开始 Interrupt_initVectorTable() 初始化PIE中断向量表 将向量表中的所有中断向量指向默认的中断服务程序(ISR) 这确保了即使有未处理的中断，系统也不会崩溃 Interrupt_register(INT_SCIA_RX, sciaRXFIFOISR) 和 Interrupt_register(INT_SCIA_TX, sciaTXFIFOISR) 将特定的中断与对应的中断服务程序（sciaRXFIFOISR和sciaTXFIFOISR）关联起来 INT_SCIA_RX 是SCI接收中断，关联到 sciaRXFIFOISR 函数 INT_SCIA_TX 是SCI发送中断，关联到 sciaTXFIFOISR 函数 这样当这些中断发生时，系统就知道该调用哪个函数来处理 Interrupt_enable(INT_SCIA_RX) 和 Interrupt_enable(INT_SCIA_TX) 启用特定的中断 使能SCI接收和发送中断 只有被使能的中断才会触发对应的ISR Interrupt_clearACKGroup(INTERRUPT_ACK_GROUP9) 清除中断确认组9的中断标志 这确保之前可能存在的未处理中断不会立即触发 中断组9通常包含SCI相关的中断 第一次发送传输需要手动使能中断服务函数，如Interrupt_enable(INT_SCIA_TX) 总结controlSuite里边的SCI loopback例程不大靠谱，导入CCS里边后编译不成功，即使你折腾好运行也是有问题的，建议使用C2000里边的example","tags":["LAUNCHXL-F28379D","SCI","中断","FIFO"],"categories":["嵌入式"]},{"title":"LMT86LP模拟温度传感器","path":"//lmt86lp-temperature-sensor.html","content":"介绍LMT86是精密的CMOS温度传感器，它的大致参数如下： 精度：±0.4误差 范围：-50°C 至 150°C 封装：TO-92S 引脚：VDD、GND、OUT 价格：4RMB 厂商：德州仪器 供电：2.2V 至 5.5V 模块外观大概长这么样 硬件VDD、GND、OUT引脚连线参考，电源端（VDD）加去耦电容、输出端（OUT）加滤波电容 连接ADC采集模拟量 关系表温度值和VOUT的对应关系（-50至149摄氏度） 温度(°C) VOUT(mV) 温度(°C) VOUT(mV) 温度(°C) VOUT(mV) 温度(°C) VOUT(mV) 温度(°C) VOUT(mV) -50 2616 -10 2207 30 1777 70 1335 110 883 -49 2607 -9 2197 31 1766 71 1324 111 872 -48 2598 -8 2186 32 1756 72 1313 112 860 -47 2589 -7 2175 33 1745 73 1301 113 849 -46 2580 -6 2164 34 1734 74 1290 114 837 -45 2571 -5 2154 35 1723 75 1279 115 826 -44 2562 -4 2143 36 1712 76 1268 116 814 -43 2553 -3 2132 37 1701 77 1257 117 803 -42 2543 -2 2122 38 1690 78 1245 118 791 -41 2533 -1 2111 39 1679 79 1234 119 780 -40 2522 0 2100 40 1668 80 1223 120 769 -39 2512 1 2089 41 1657 81 1212 121 757 -38 2501 2 2079 42 1646 82 1201 122 745 -37 2491 3 2068 43 1635 83 1189 123 734 -36 2481 4 2057 44 1624 84 1178 124 722 -35 2470 5 2047 45 1613 85 1167 125 711 -34 2460 6 2036 46 1602 86 1155 126 699 -33 2449 7 2025 47 1591 87 1144 127 688 -32 2439 8 2014 48 1580 88 1133 128 676 -31 2429 9 2004 49 1569 89 1122 129 665 -30 2418 10 1993 50 1558 90 1110 130 653 -29 2408 11 1982 51 1547 91 1099 131 642 -28 2397 12 1971 52 1536 92 1088 132 630 -27 2387 13 1961 53 1525 93 1076 133 618 -26 2376 14 1950 54 1514 94 1065 134 607 -25 2366 15 1939 55 1503 95 1054 135 595 -24 2355 16 1928 56 1492 96 1042 136 584 -23 2345 17 1918 57 1481 97 1031 137 572 -22 2334 18 1907 58 1470 98 1020 138 560 -21 2324 19 1896 59 1459 99 1008 139 549 -20 2313 20 1885 60 1448 100 997 140 537 -19 2302 21 1874 61 1436 101 986 141 525 -18 2292 22 1864 62 1425 102 974 142 514 -17 2281 23 1853 63 1414 103 963 143 502 -16 2271 24 1842 64 1403 104 951 144 490 -15 2260 25 1831 65 1391 105 940 145 479 -14 2250 26 1820 66 1380 106 929 146 467 -13 2239 27 1810 67 1369 107 917 147 455 -12 2228 28 1799 68 1358 108 906 148 443 -11 2218 29 1788 69 1346 109 895 149 432 驱动ADC配置：初始化ADC2用于温度传感器读取 123456789101112131415161718192021222324252627282930313233343536373839404142434445void InitAdc2(void)&#123; extern void DSP28x_usDelay(Uint32 Count); // To powerup the ADC2 the ADC2ENCLK bit should be set first to enable // clocks, followed by powering up the bandgap, reference circuitry, and // ADC2 core. // Before the first conversion is performed a 5ms delay must be observed // after power up to give all analog circuits time to power up and settle // Please note that for the delay function below to operate correctly the // CPU_RATE define statement in the F28M35x_Examples.h file must // contain the correct CPU clock period in nanoseconds. EALLOW; Adc2Regs.ADCCTL1.bit.ADCBGPWD = 1; // Power ADC2 BG Adc2Regs.ADCCTL1.bit.ADCREFPWD = 1; // Power reference Adc2Regs.ADCCTL1.bit.ADCPWDN = 1; // Power ADC2 Adc2Regs.ADCCTL1.bit.ADCENABLE = 1; // Enable ADC2 Adc2Regs.ADCCTL1.bit.ADCREFSEL = 0; // Select interal BG EDIS; DELAY_US(ADC_usDELAY); // Delay before converting ADC2 channels&#125;void TempSensor_Init(void)&#123; EALLOW; // 初始化ADC2（假设已有InitAdc2()函数） InitAdc2(); // 配置ADC2 Adc2Regs.ADCCTL2.bit.ADCNONOVERLAP = 1; // 启用非重叠模式 Adc2Regs.ADCCTL1.bit.INTPULSEPOS = 1; // 中断在结果锁存后触发 Adc2Regs.INTSEL1N2.bit.INT1E = 1; // 启用ADCINT1 Adc2Regs.INTSEL1N2.bit.INT1CONT = 0; // 禁用连续模式 Adc2Regs.INTSEL1N2.bit.INT1SEL = 0; // EOC0触发ADCINT1 // 配置SOC0 Adc2Regs.ADCSOC0CTL.bit.CHSEL = 0; // ADC2A0通道 Adc2Regs.ADCSOC0CTL.bit.TRIGSEL = 0; // 软件触发 Adc2Regs.ADCSOC0CTL.bit.ACQPS = 6; // 采样窗口7个ADC时钟周期 EDIS;&#125; 温度电压映射关系数组 12345678910111213141516171819202122232425262728293031323334353637383940414243444546static const LMT86_LUT_Entry lmt86_lut[] = &#123; // 负温度区 (-50°C 到 -1°C) &#123;-50, 2616&#125;, &#123;-49, 2607&#125;, &#123;-48, 2598&#125;, &#123;-47, 2589&#125;, &#123;-46, 2580&#125;, &#123;-45, 2571&#125;, &#123;-44, 2562&#125;, &#123;-43, 2553&#125;, &#123;-42, 2543&#125;, &#123;-41, 2533&#125;, &#123;-40, 2522&#125;, &#123;-39, 2512&#125;, &#123;-38, 2501&#125;, &#123;-37, 2491&#125;, &#123;-36, 2481&#125;, &#123;-35, 2470&#125;, &#123;-34, 2460&#125;, &#123;-33, 2449&#125;, &#123;-32, 2439&#125;, &#123;-31, 2429&#125;, &#123;-30, 2418&#125;, &#123;-29, 2408&#125;, &#123;-28, 2397&#125;, &#123;-27, 2387&#125;, &#123;-26, 2376&#125;, &#123;-25, 2366&#125;, &#123;-24, 2355&#125;, &#123;-23, 2345&#125;, &#123;-22, 2334&#125;, &#123;-21, 2324&#125;, &#123;-20, 2313&#125;, &#123;-19, 2302&#125;, &#123;-18, 2292&#125;, &#123;-17, 2281&#125;, &#123;-16, 2271&#125;, &#123;-15, 2260&#125;, &#123;-14, 2250&#125;, &#123;-13, 2239&#125;, &#123;-12, 2228&#125;, &#123;-11, 2218&#125;, &#123;-10, 2207&#125;, &#123;-9, 2197&#125;, &#123;-8, 2186&#125;, &#123;-7, 2175&#125;, &#123;-6, 2164&#125;, &#123;-5, 2154&#125;, &#123;-4, 2143&#125;, &#123;-3, 2132&#125;, &#123;-2, 2122&#125;, &#123;-1, 2111&#125;, // 正温度区 (0°C 到 150°C) &#123;0, 2100&#125;, &#123;1, 2089&#125;, &#123;2, 2079&#125;, &#123;3, 2068&#125;, &#123;4, 2057&#125;, &#123;5, 2047&#125;, &#123;6, 2036&#125;, &#123;7, 2025&#125;, &#123;8, 2014&#125;, &#123;9, 2004&#125;, &#123;10, 1993&#125;, &#123;11, 1982&#125;, &#123;12, 1971&#125;, &#123;13, 1961&#125;, &#123;14, 1950&#125;, &#123;15, 1939&#125;, &#123;16, 1928&#125;, &#123;17, 1918&#125;, &#123;18, 1907&#125;, &#123;19, 1896&#125;, &#123;20, 1885&#125;, &#123;21, 1874&#125;, &#123;22, 1864&#125;, &#123;23, 1853&#125;, &#123;24, 1842&#125;, &#123;25, 1831&#125;, &#123;26, 1820&#125;, &#123;27, 1810&#125;, &#123;28, 1799&#125;, &#123;29, 1788&#125;, &#123;30, 1777&#125;, &#123;31, 1766&#125;, &#123;32, 1756&#125;, &#123;33, 1745&#125;, &#123;34, 1734&#125;, &#123;35, 1723&#125;, &#123;36, 1712&#125;, &#123;37, 1701&#125;, &#123;38, 1690&#125;, &#123;39, 1679&#125;, &#123;40, 1668&#125;, &#123;41, 1657&#125;, &#123;42, 1646&#125;, &#123;43, 1635&#125;, &#123;44, 1624&#125;, &#123;45, 1613&#125;, &#123;46, 1602&#125;, &#123;47, 1591&#125;, &#123;48, 1580&#125;, &#123;49, 1569&#125;, &#123;50, 1558&#125;, &#123;51, 1547&#125;, &#123;52, 1536&#125;, &#123;53, 1525&#125;, &#123;54, 1514&#125;, &#123;55, 1503&#125;, &#123;56, 1492&#125;, &#123;57, 1481&#125;, &#123;58, 1470&#125;, &#123;59, 1459&#125;, &#123;60, 1448&#125;, &#123;61, 1436&#125;, &#123;62, 1425&#125;, &#123;63, 1414&#125;, &#123;64, 1403&#125;, &#123;65, 1391&#125;, &#123;66, 1380&#125;, &#123;67, 1369&#125;, &#123;68, 1358&#125;, &#123;69, 1346&#125;, &#123;70, 1335&#125;, &#123;71, 1324&#125;, &#123;72, 1313&#125;, &#123;73, 1301&#125;, &#123;74, 1290&#125;, &#123;75, 1279&#125;, &#123;76, 1268&#125;, &#123;77, 1257&#125;, &#123;78, 1245&#125;, &#123;79, 1234&#125;, &#123;80, 1223&#125;, &#123;81, 1212&#125;, &#123;82, 1201&#125;, &#123;83, 1189&#125;, &#123;84, 1178&#125;, &#123;85, 1167&#125;, &#123;86, 1155&#125;, &#123;87, 1144&#125;, &#123;88, 1133&#125;, &#123;89, 1122&#125;, &#123;90, 1110&#125;, &#123;91, 1099&#125;, &#123;92, 1088&#125;, &#123;93, 1076&#125;, &#123;94, 1065&#125;, &#123;95, 1054&#125;, &#123;96, 1042&#125;, &#123;97, 1031&#125;, &#123;98, 1020&#125;, &#123;99, 1008&#125;, &#123;100, 997&#125;, &#123;101, 986&#125;, &#123;102, 974&#125;, &#123;103, 963&#125;, &#123;104, 951&#125;, &#123;105, 940&#125;, &#123;106, 929&#125;, &#123;107, 917&#125;, &#123;108, 906&#125;, &#123;109, 895&#125;, &#123;110, 883&#125;, &#123;111, 872&#125;, &#123;112, 860&#125;, &#123;113, 849&#125;, &#123;114, 837&#125;, &#123;115, 826&#125;, &#123;116, 814&#125;, &#123;117, 803&#125;, &#123;118, 791&#125;, &#123;119, 780&#125;, &#123;120, 769&#125;, &#123;121, 757&#125;, &#123;122, 745&#125;, &#123;123, 734&#125;, &#123;124, 722&#125;, &#123;125, 711&#125;, &#123;126, 699&#125;, &#123;127, 688&#125;, &#123;128, 676&#125;, &#123;129, 665&#125;, &#123;130, 653&#125;, &#123;131, 642&#125;, &#123;132, 630&#125;, &#123;133, 618&#125;, &#123;134, 607&#125;, &#123;135, 595&#125;, &#123;136, 584&#125;, &#123;137, 572&#125;, &#123;138, 560&#125;, &#123;139, 549&#125;, &#123;140, 537&#125;, &#123;141, 525&#125;, &#123;142, 514&#125;, &#123;143, 502&#125;, &#123;144, 490&#125;, &#123;145, 479&#125;, &#123;146, 467&#125;, &#123;147, 455&#125;, &#123;148, 443&#125;, &#123;149, 432&#125;, &#123;150, 420&#125;&#125;; 使用线性插值计算温度 12345678910111213141516171819// 使用线性插值计算温度static float VoltageToTemperature(float voltage_mV)&#123; Uint16 i; float slope; // 边界检查 if (voltage_mV &gt;= lmt86_lut[0].voltage) return lmt86_lut[0].temp; if (voltage_mV &lt;= lmt86_lut[LMT86_LUT_SIZE-1].voltage) return lmt86_lut[LMT86_LUT_SIZE-1].temp; // 线性搜索(实际使用时建议改为二分查找) for (i=0; i&lt;LMT86_LUT_SIZE-1; i++) &#123; if (voltage_mV &lt;= lmt86_lut[i].voltage &amp;&amp; voltage_mV &gt;= lmt86_lut[i+1].voltage) &#123; // 线性插值 slope = (lmt86_lut[i+1].temp - lmt86_lut[i].temp) / (float)(lmt86_lut[i+1].voltage - lmt86_lut[i].voltage); return lmt86_lut[i].temp + slope * (voltage_mV - lmt86_lut[i].voltage); &#125; &#125; return 0.0f; // 不应执行到此处&#125; 读取当前温度(°C) 123456// 读取当前温度(°C)float TempSensor_ReadTemperature(Uint16 adcValue)&#123; float voltage_mV = ADC_ToVoltage(adcValue); return VoltageToTemperature(voltage_mV);&#125;","tags":["传感器","ADC"],"categories":["嵌入式"]},{"title":"Code Composer Studio导入DSP工程编译报错","path":"//ccs-dsp-project-compile-problem.html","content":"编译报错从controlSUITE里边导入一个example工程，发现make找不到 123456789101112131415**** Build of configuration Flash for project ctom_ipcdrivers_m3 ****make all make all Cannot run program &quot;make&quot;: Launching failedError: Program &quot;make&quot; not found in PATHPATH=[D:/software/ti/ccs1281/ccs/eclipse/jre/bin/server;D:/software/ti/ccs1281/ccs/eclipse/jre/bin;C:\\Program Files\\Eclipse Adoptium\\jdk-17.0.15.6-hotspot\\bin;C:\\Program Files (x86)\\VMware\\VMware Workstation\\bin\\;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Windows\\System32\\OpenSSH\\;C:\\Program Files\\Git\\cmd;C:\\Program Files\\dotnet\\;C:\\Strawberry\\c\\bin;C:\\Strawberry\\perl\\site\\bin;C:\\Strawberry\\perl\\bin;C:\\Program Files (x86)\\STMicroelectronics\\STM32 ST-LINK Utility\\ST-LINK Utility;D:\\software odejs\\;C:\\Program Files\\TortoiseGit\\bin;C:\\Program Files\\PuTTY\\;C:\\Users\\heaven\\AppData\\Local\\Programs\\Python\\Python311\\Scripts\\;C:\\Users\\heaven\\AppData\\Local\\Programs\\Python\\Python311\\;C:\\Users\\heaven\\AppData\\Local\\Programs\\Python\\Python310\\Scripts\\;C:\\Users\\heaven\\AppData\\Local\\Programs\\Python\\Python310\\;C:\\Users\\heaven\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\heaven\\.dotnet\\tools;C:\\Program Files\\CMake\\bin;C:\\Users\\heaven\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Program Files\\ListDll;D:\\software\\esp32-idf\\Espressif\\tools;C:\\Users\\heaven\\AppData\\Roaming pm;D:\\software;C: xp\\LinkServer_1.6.133;C:\\Program Files\\Windows Kits\\10\\Debuggers\\x64\\;D:\\software\\cursor\\resources\\app\\bin;D:\\software\\ti\\ccs1281\\ccs\\eclipse]Error: Program &quot;make&quot; is not found in PATHPATH=[D:/software/ti/ccs1281/ccs/eclipse/jre/bin/server;D:/software/ti/ccs1281/ccs/eclipse/jre/bin;C:\\Program Files\\Eclipse Adoptium\\jdk-17.0.15.6-hotspot\\bin;C:\\Program Files (x86)\\VMware\\VMware Workstation\\bin\\;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Windows\\System32\\OpenSSH\\;C:\\Program Files\\Git\\cmd;C:\\Program Files\\dotnet\\;C:\\Strawberry\\c\\bin;C:\\Strawberry\\perl\\site\\bin;C:\\Strawberry\\perl\\bin;C:\\Program Files (x86)\\STMicroelectronics\\STM32 ST-LINK Utility\\ST-LINK Utility;D:\\software odejs\\;C:\\Program Files\\TortoiseGit\\bin;C:\\Program Files\\PuTTY\\;C:\\Users\\heaven\\AppData\\Local\\Programs\\Python\\Python311\\Scripts\\;C:\\Users\\heaven\\AppData\\Local\\Programs\\Python\\Python311\\;C:\\Users\\heaven\\AppData\\Local\\Programs\\Python\\Python310\\Scripts\\;C:\\Users\\heaven\\AppData\\Local\\Programs\\Python\\Python310\\;C:\\Users\\heaven\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\heaven\\.dotnet\\tools;C:\\Program Files\\CMake\\bin;C:\\Users\\heaven\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Program Files\\ListDll;D:\\software\\esp32-idf\\Espressif\\tools;C:\\Users\\heaven\\AppData\\Roaming pm;D:\\software;C: xp\\LinkServer_1.6.133;C:\\Program Files\\Windows Kits\\10\\Debuggers\\x64\\;D:\\software\\cursor\\resources\\app\\bin;D:\\software\\ti\\ccs1281\\ccs\\eclipse]**** Build Finished **** 分析找不到说明要么环境变量PATH没有对，要么是工程配置有问题，但是自己新建的工程可以编译，那大概率是老旧的工程导入的时候不兼容 解决在工程Properties里边找到Build页面，配置Builder栏：勾选Use default build command，重新编译即可","tags":["DSP"],"categories":["嵌入式"]},{"title":"番茄工作法(Pomodoro Technique)","path":"//pomodoro-technique.html","content":"前言番茄工作法是一种时间管理的方法论，如果你经常有很多事情想做，实现起来又很混乱、不知所措，那么你需要有这样的一种机制来管理你的时间（生命） 介绍番茄工作法（Pomodoro Technique）是一种高效的时间管理方法，由弗朗西斯科·西里洛于1992年创立，核心思想是注重短时间的投入换取高效的产出 实践待办清单 把一天或者一个上午&#x2F;下午要做的事情做个统计列表，尽量分割成最小成果产出单元（工作包），不要依赖太多的前置条件，否则你很难完成 序号 待办事项 备注 1 统计xxx项目需要采购哪些硬件、软件、机械部件，整理文档交给采购 采购 2 整理xxx项目产品原型文档 产品 3 编写按键板驱动 编码 4 移植触摸屏驱动 编码 5 测试RK3588平板的输入功能（按键板、触摸屏） 测试 6 编写OTA升级程序 编码 一个番茄 25-30分钟设定为一个番茄时间，期间你要专注地做自己的事情，避免任何事情的打扰，尽量劳有所获 休息时间 控制在5-15分钟，你可以上厕所、泡壶茶、打电话、做下健身操；如果你很累（没有产出），去茶水间冥想或者面壁都是一个不错的选择 好番茄 好番茄的特点： 没有打扰，有产出有成果！你很专注，自我感觉很好 不沉迷、不留恋，即便你多么想继续干下去，你都要停下来休息，为下一个番茄做准备 不做任何与当前任务无关的事情！ 烂番茄 烂番茄的特点： 玛德，又坚持不下去了，我真是个傻逼！ 又有傻逼来打扰我了！ 迷恋在任务当中无法自拔 统计每日都要做复盘，看看任务的达成率 建议备注一下番茄的状态（成功、失败、完成、未完成）和有失败的理由（说明） 序号 待办事项 备注 状态 说明 1 统计xxx项目需要采购哪些硬件、软件、机械部件，整理文档交给采购 采购 已完成 已经交付采购 2 整理xxx项目产品原型文档 产品 已完成 已经整理好文档 3 编写按键板驱动 编码 未完成 肚子疼，上了趟测试，看医生了 4 移植触摸屏驱动 编码 未完成 计划耽搁 5 测试RK3588平板的输入功能（按键板、触摸屏） 测试 未完成 计划耽搁 6 编写OTA升级程序 编码 失败 wifi功能没好，没有网络环境 总结生命很宝贵，每个人都只有一次机会，尽量别浪费自己的时间，你不能在虚度光阴之后才想起时间很宝贵；因此，要确保时间管理的方法论高效执行！请注意以下几点： 保持专注（主人翁精神） 把握好任务的颗粒度（如果你的番茄没有产出的话，我觉得多少有点不大合理，个人见解） 休息充分（劳逸结合）","tags":["高效办公"],"categories":["方法论"]},{"title":"VS2019离线安装镜像制作","path":"//vs2019-offline-iso.html","content":"前言现在VS（Visual Studio）默认都是在线安装的方式，虽然是方便、简单了很多，但对于一些封闭的局域网环境极为不友好（至于为什么要用局域网这个很难讲得清楚），所以这篇文章主要介绍离线包如何制作 介绍Visual Studio是微软出品的一款强大的IDE，可以开发c、c++、c#、python等各种语言的各类应用程序，包括桌面程序、WEB、移动端app、游戏、甚至是PLC（被Windows程序员戏称为全家桶、宇宙第一IDE）；微软提供了极为方便的开发工具（编辑器、调试器、内存分析工具等），使用它你可以很快速的进行编码、测试、部署工作 下载链接以Windows10为例，先根据自己的需求选择对应的版本，比如我这里选择社区版 社区版：Thank You for Downloading Visual Studio Community Edition (microsoft.com) 专业版：Thank You for Downloading Visual Studio Professional Edition (microsoft.com) 企业版：Thank You for Downloading Visual Studio Enterprise Edition (microsoft.com) 制作离线包在打开的cmd命令行中输入命令，安装C++的桌面开发环境（Windows10 SDK）的命令示例： 1vs_Community.exe --layout &quot;C:\\vs2019&quot; --add Microsoft.VisualStudio.Workload.NativeDesktop --includeRecommended --lang zh-CN 参数--layout用于指定Visual Studio资源文件存放路径 1--layout &quot;C:\\vs2019&quot; 参数--add用于增加指定ID的组件，指令ID代表的组件含义如下 序号 ID 组件 含义 1 Microsoft.VisualStudio.Workload.Azure Azure 开发 使用 .NET 和 .NET Framework 开发云应用和创建资源的 Azure SDK、工具和项目。 还包括用于容器化应用程序的工具，包括 Docker 支持 2 Microsoft.VisualStudio.Workload.Data 数据存储和处理 使用 SQL Server、Azure Data Lake 或 Hadoop 连接、开发和测试数据解决方案 3 Microsoft.VisualStudio.Workload.DataScience 数据科学和分析应用程序 用于创建数据科学应用程序的语言和工具，包括 Python 和 F# 4 Microsoft.VisualStudio.Workload.NativeDesktop .NET 桌面开发 将 C#、Visual Basic 和 F# 与 .NET 和 NET Framework 一起使用，生成 WPF、Windows 窗体和控制台应用程序 5 Microsoft.VisualStudio.Workload.ManagedGame 使用 Unity 的游戏开发 使用 Unity（功能强大的跨平台开发环境）创建 2D 和 3D 游戏 6 Microsoft.VisualStudio.Workload.NativeCrossPlat 使用 C++ 的 Linux 开发 创建和调试在 Linux 环境中运行的应用程序 7 Microsoft.VisualStudio.Workload.NativeDesktop 使用 C++ 的桌面开发 使用所选工具（包括 MSVC、Clang、CMake 或 MSBuild）生成适用于 Windows 的新式 C++ 应用 参数--includeRecommended指定工作负载的组件配置，以下是微软官网的解析 参数--lang用于指定Visual Studio的安装语言，我这里选中国汉语 1--lang zh-CN 先下载Installer的组件 接下来下载各个组件包，下载速度贼慢，需要耐心等待 安装完成 制作iso，推荐使用UltraISO软碟通进行压缩 装载光盘镜像后体积大概有2.39G，这样后面你就可以拿这个安装包去别的机器做自动化部署了（下面这台机器是倍福的工控机IPC-Windows10） 参考Visual Studio Community 工作负载和组件 ID | Microsoft Learn","tags":["VS2019","ISO"],"categories":["开发工具"]},{"title":"软件项目需求说明书简要模板","path":"//software-project-requirements-specification.html","content":"引言编写目的上位机软件可提供的功能： 功能点1：…… 功能点2：…… 功能点3：…… 本文档涉及到的用户角色有： 模块负责人 项目负责人 开发小组负责人 测试人员 本说明书是xxx软件开发的收据，对后续软件开发起指导作用，也是项目测试和验收的依据 范围本说明书描述了软件项目的开发背景、用途、相关人员及测试验收标准（输出物可以是软件包、文档、代码等） 验收标准1：…… 验收标准2：…… 验收标准3：…… 定义关键术语的定义 xxx：xxx是一个什么样的功能…… yyy：yyy是一个什么样的功能…… 项目概述产品描述概括描述业务场景、产品的大致功能 ……. 产品功能展开说明软件产品的功能 xxx yyy zzz 用户特点本软件的用户类型大致可以分为以下几类： xxx yyy zzz 具体需求功能需求 xxx yyy zzz 设计约束 xxx yyy zzz 属性可用性 xxx yyy zzz 安全性 xxx yyy zzz 可维护性 xxx yyy zzz 可扩展性 xxx yyy zzz 测试相关黑盒测试 各个子系统功能完整性测试 输入输出是否符合业务场景 白盒测试 代码游走审查 单元测试","tags":["软件","需求说明书"],"categories":["方法论"]},{"title":"开源鸿蒙开发者大会2025","path":"//openharmony-developer-sumit2025.html","content":"5月24日，开源鸿蒙开发者大会2025（OHDC.2025）在深圳隆重开幕","tags":["开源","鸿蒙","开发者大会"],"categories":["开源社区"]},{"title":"MQTT服务器连接不上的问题","path":"//mqtt-server-not-connected.html","content":"问题描述环境：阿里云服务器Ubuntu 22.04.3 LTS，安装mosquitto后，在虚拟机端订阅消息出现报错（以前用阿里云Ubuntu20.04 LTS的服务器装上就能用），以下服务器ip是我乱填的 123mosquitto_sub -t /iotstuff -h 129.25.125.124 -p 1883Error: Connection refused 解决办法云服务器ECS -&gt; 安全组 -&gt; 安全组详情，看看有没有添加1883端口为白名单，出方向和入方向都要配置 查看服务器的端口占用情况 1netstat -lnpt 发现moquitto侦听的ip是127.0.0.1:1883，其中127.0.0.1代表的是本地的局域网ip，如果想要在公网访问是不行的，打开mosquitto.conf文件，设置允许公网访问 1listener 1883 允许客户端不需要用户名和密码进行访问 1allow_anonymous true 重启mosquitto服务后发现虚拟机端订阅消息就能连上 1service mosquitto restart 如果还是连不上，check一下系统防火墙状态 12ufw status # 查看防火墙状态ufw add 1883 # 添加1883端口到白名单 参考mosquitto.conf man page | Eclipse Mosquitto","tags":["服务器","MQTT","阿里云"],"categories":["程序设计"]},{"title":"TMS320F28379D浮点数内存格式问题","path":"//tms320f28379d-float.html","content":"字节序小端：低字节放低地址空间，高字节放高地址空间，小端模式符合读取、理解习惯，大部分MCU、X64 CPU都采用小端 大端：高字节放低地址空间，低字节放高地址空间，大端模式符合书写、拼读、传输习惯，比如网络字节序一般使用大端模式 代码测试浮点数的存储格式 123456789101112131415161718typedef union &#123; float DataFloat; uint16_t DataUint16[2]; unsigned char DataUint8[4];&#125; FloatUnion;void main(void)&#123; FloatUnion fu; fu.DataFloat = 123.456f; uint16_t val1 = fu.DataUint16[0]; uint16_t val2 = fu.DataUint16[1]; unsigned char val3 = fu.DataUint8[0]; unsigned char val4 = fu.DataUint8[1]; unsigned char val5 = fu.DataUint8[2]; unsigned char val6 = fu.DataUint8[3]; &#125; 测试调试查看Memory Brownser，16-Bit Hex格式下对应的数据从低到高：0xF979 0x42F6 对应的结果是0x42F6E979（高字节放高地址空间），按 IEEE 754 单精度浮点格式还原： 符号位（1位）：0 0 表示正数，1 表示负数。 指数位（8位）：10000101 十进制值：133（无符号整数），对应的指数为133 - 127 &#x3D; 6。 尾数位（23位）：11101101110100101111001 隐含前导的 1.（即实际尾数为 1.11101101110100101111001）。 计算结果跟123.456f吻合 121.11101101110100101111001 ≈ 1.9290001391.929000139 × 2^6 = 1.929000139 × 64 ≈ 123.456 可以看到uint16_t能还原原始的数据内容，第一个索引是59769（0xE979），第二个索引是17142（0x42F6） unsigned char不行，第一个索引是59769（0xE979），第二个索引是17142（0x42F6）2、3索引对应的数据都是0 另外unsigned char直接赋值也会有问题，很明显第三、四个DataUnit8是取到后面的内存去了 总结 DSP TMS320F28379D使用小端模式存储数据 不能简单用4个unsigned char理解float，但可以用2个uint16_t理解float，用指针强转的朋友留意！","tags":["DSP","TMS320F28379D","小端模式","浮点数"],"categories":["嵌入式"]},{"title":"自动化调参工具：VOFA+使用教程","path":"//automation-tool-vofa-plus.html","content":"介绍VOFA+是一个精致的数据可视化上位机软件，支持多个数据接口（串口、网口）、自定义数据引擎和定制数据可视化控件，是一个不可多得的自动化调参软件（示波器类似物），个人觉得它将串口调参的功能发挥到了极致 前端数据引擎和数据接口参数配置：选择FireWater引擎，数据接口选串口，串口配置115200 8N1 通道数据展示：通道开关+名称+颜色+小数点位置 可以控制缓冲区里边可视化数据点数：点击红色原点进行波形放大、缩小 文本展示区，可以实时展示接收+发送内容 控件可以点击左侧的控件栏，左键选中控件并拖到波形展示区域 主窗口支持多个Tab分页，可以将不同的数据分类展示，支持分类的重命名 绑定数据通道绑定X轴已经Y轴，只要在控件右键弹出菜单就可以配置X轴、Y轴，其它控件同理 指定上位机的时间戳为X轴，当然你可以用数据通道指定的X轴（不用上位机的时间戳） 以FireWater数据引擎+串口数据接口为例：使用指定格式输出数据：”%f,%f,%f,%f ”，只要往printf输出格式化数据就行，以下嵌入式代码用于生成自定义的正弦波数据，printf的参数配置需要和上位机的串口配置一致 123456789101112131415161718192021222324252627282930313233// 打印表头printf(&quot;Angle,Sin(x),Cos(x),Sin(x)*Cos(x),Cos(x)*Cos(x)\\r &quot;);// 生成三角函数数据float angle = 0.0f; // 角度(度)float angleRad; // 角度(弧度)float sinVal, cosVal; // sin(x)和cos(x)值float sinCosVal, cosSquareVal; // sin(x)*cos(x)和cos(x)*cos(x)值for(;;) &#123; // 每15度输出一次数据 while(angle &lt;= 360.0f) &#123; // 转换为弧度 angleRad = angle * 0.01745329f; // 0.01745329 = π/180 // 计算三角函数值 sinVal = sin(angleRad); cosVal = cos(angleRad); sinCosVal = sinVal * cosVal; cosSquareVal = cosVal * cosVal; // 使用指定格式输出数据：&quot;%f,%f,%f,%f &quot; printf(&quot;%f,%f,%f,%f\\r &quot;, sinVal, cosVal, sinCosVal, cosSquareVal); // 角度增加15度 angle += 15.0f; // 延时，避免输出太快 DEVICE_DELAY_US(500); // 延时100ms &#125; angle = 0;&#125; DSP实现printf函数功能，使用前先初始化SCIA 123456789101112131415161718192021222324252627void initSCI(void)&#123; GPIO_setPinConfig(GPIO_28_SCIRXDA); GPIO_setPinConfig(GPIO_29_SCITXDA); GPIO_setPadConfig(28, GPIO_PIN_TYPE_STD); GPIO_setPadConfig(29, GPIO_PIN_TYPE_STD); SCI_disableModule(SCIA_BASE); SCI_performSoftwareReset(SCIA_BASE); SCI_setConfig(SCIA_BASE, DEVICE_LSPCLK_FREQ, 115200, (SCI_CONFIG_WLEN_8 | SCI_CONFIG_STOP_ONE | SCI_CONFIG_PAR_NONE)); SCI_disableLoopback(SCIA_BASE); SCI_disableFIFO(SCIA_BASE); SCI_enableModule(SCIA_BASE);&#125;#include &lt;stdio.h&gt;#include &quot;driverlib/sci.h&quot;int fputc(int c, register FILE *stream)&#123; SCI_writeCharBlockingNonFIFO(SCIA_BASE, (uint16_t)c); while(SCI_getTxFIFOStatus(SCIA_BASE) != SCI_FIFO_TX0); return c;&#125; 波形实时展示效果 总结 理论上也能支持CAN接口，要是支持CAN就完美了 推荐使用SCI发送中断的方式进行串口数据发送","tags":["自动化","调参工具","VOFA+"],"categories":["开发工具"]},{"title":"LAUNCHXL-F28379D链接文件功能详解","path":"//launchxl-f28379d-link-script.html","content":"CMD文件主要是有FLASH和RAM两种下载模式：FLASH是把程序烧录到FLASH中运行，RAM模式则是把程序烧录到RAM里边运行，以TMS320F28379D为例，它支持2837xD_FLASH_lnk_cpu1.cmd和2837xD_RAM_lnk_cpu1.cmd两种下载调试模式，下载模式可以在对应工程的Properties -&gt; General -&gt; Linker command file里边指定 FLASHFLASH模式主要包括MEMORY和SECTIONS两个字段；至于内存块怎么用，SECTIONS会告诉你 123456789MEMORY&#123;&#125;SECTIONS&#123;&#125; 一般MEMORY会分成两个PAGE：PAGE0和PAGE1，PAGE0存放program代码（FLASH），PAGE1存放data代码（RAM）；每个PAGE包含若干个内存块，每个内存块的字段名、起始地址和大小空间会在MEMORY里边给出，原则上合起来的空间不能超过物理内存空间大小 12345678910111213141516171819202122232425262728MEMORY&#123;PAGE 0 : /* 程序存储区(Flash) */ BEGIN : origin = 0x080000, length = 0x000002 FLASHA : origin = 0x080002, length = 0x001FFE /* 方案一：合并FLASHB/C/D为一个更大的区域（已应用） */ FLASHBCD : origin = 0x082000, length = 0x006000 /* 24KB (合并B+C+D) */ /* 方案二：分别保留各区（如需用方案二，注释上面的FLASHBCD，取消下面三行的注释） FLASHB : origin = 0x082000, length = 0x002000 FLASHC : origin = 0x084000, length = 0x002000 FLASHD : origin = 0x086000, length = 0x002000 */ FLASHE : origin = 0x088000, length = 0x008000 FLASHF : origin = 0x090000, length = 0x008000 RESET : origin = 0x3FFFC0, length = 0x000002PAGE 1 : /* 数据存储区(RAM) */ RAMM0 : origin = 0x000123, length = 0x0002DD RAMM1 : origin = 0x000400, length = 0x0003F8 RAMLS0 : origin = 0x008000, length = 0x000800 RAMLS5 : origin = 0x00A800, length = 0x000800 RAMGS0 : origin = 0x00C000, length = 0x001000 RAMGS1 : origin = 0x00D000, length = 0x001000 CPU1TOCPU2RAM : origin = 0x03FC00, length = 0x000400&#125; 至于内存块怎么用，SECTIONS会告诉你，SECTIONS会把MEMORY里边定义的内存块安排得明明白白，以下代码跟ARM里边的link script差不多，我们可以看到下边代码段（eabi、text、const）主要是存放在FLASH空间，数据段（bss、func、stack、data）主要是存放RAM空间 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960SECTIONS&#123; /*--- 启动代码段 ---*/ codestart : &gt; BEGIN, PAGE = 0 .reset : &gt; RESET, PAGE = 0, TYPE = DSECT /*--- EABI段 ---*/ .cinit : &gt; FLASHA, PAGE = 0, ALIGN(8) /* 方案一：使用更大的合并区（已应用） */ .text : &gt; FLASHBCD, PAGE = 0, ALIGN(8) /* 方案二：分配到多个区（如需用方案二，注释上面的.text行，取消下面这行的注释） .text : &gt;&gt; FLASHB | FLASHC | FLASHD, PAGE = 0, ALIGN(8) */ .const : &gt; FLASHF, PAGE = 0, ALIGN(8) .init_array : &gt; FLASHA, PAGE = 0, ALIGN(8) .bss : &gt; RAMLS5, PAGE = 1, ALIGN(8) .sysmem : &gt; RAMGS1, PAGE = 1, ALIGN(8) /*--- RAM函数段 ---*/ .TI.ramfunc : &#123; *(.TI.ramfunc) *(.ramfunc) &#125; LOAD = FLASHE, PAGE = 0 /* 将FLASHD改为FLASHE，避免冲突 */ RUN = RAMLS0, PAGE = 1 LOAD_START(RamfuncsLoadStart), LOAD_END(RamfuncsLoadEnd), LOAD_SIZE(RamfuncsLoadSize), RUN_START(RamfuncsRunStart), RUN_SIZE(RamfuncsRunSize), RUN_END(RamfuncsRunEnd), ALIGN(8) /*--- 数据段 ---*/ .stack : &gt; RAMGS0, PAGE = 1 /* 改为更大的内存区 */ .data : &gt; RAMGS0, PAGE = 1 .cio : &gt; RAMLS5, PAGE = 1 /*--- COFF兼容段 ---*/ .pinit : &gt; FLASHA, PAGE = 0, ALIGN(8) .ebss : &gt; RAMLS5, PAGE = 1 .econst : &gt; FLASHA, PAGE = 0, ALIGN(8) .esysmem : &gt; RAMGS1, PAGE = 1 /*--- IPC通信段 ---*/ GROUP : &gt; CPU1TOCPU2RAM, PAGE = 1 &#123; PUTBUFFER PUTWRITEIDX GETREADIDX &#125; /*--- 明确指定ramgs0/ramgs1段，消除警告 ---*/ ramgs0 : &gt; RAMGS0, PAGE = 1 ramgs1 : &gt; RAMGS1, PAGE = 1&#125; link script里边每个字段的功能 段名称 内存位置 页面 说明 codestart BEGIN PAGE &#x3D; 0 代码起始部分，位于Flash初始地址，包含程序入口点 .reset RESET PAGE &#x3D; 0 复位向量段，TYPE &#x3D; DSECT表示只是描述性的，不占用实际空间 .cinit FLASHA PAGE &#x3D; 0 C语言全局变量初始化表，ALIGN(8)表示按8字节对齐 .text FLASHBCD PAGE &#x3D; 0 主要代码段，放在合并的大Flash区域(24KB)以容纳更多代码 .const FLASHF PAGE &#x3D; 0 常量数据段，存放在Flash中的只读数据 .init_array FLASHA PAGE &#x3D; 0 用于C++全局对象构造函数的表 .bss RAMLS5 PAGE &#x3D; 1 未初始化的全局和静态变量段，位于RAM中 .sysmem RAMGS1 PAGE &#x3D; 1 动态内存分配的堆区域，用于malloc()等函数 .TI.ramfunc FLASHE→RAMLS0 PAGE &#x3D; 0→1 RAM函数段，特殊处理：在Flash中存储但运行时复制到RAM中执行 .stack RAMGS0 PAGE &#x3D; 1 系统堆栈段，已移至更大的内存区域RAMGS0 .data RAMGS0 PAGE &#x3D; 1 已初始化的全局和静态变量段 .cio RAMLS5 PAGE &#x3D; 1 C标准I&#x2F;O缓冲区 .pinit FLASHA PAGE &#x3D; 0 用于C++全局对象初始化的表(旧格式) .ebss RAMLS5 PAGE &#x3D; 1 扩展的.bss段，COFF格式兼容性 .econst FLASHA PAGE &#x3D; 0 扩展的常量段，COFF格式兼容性，存放在Flash中 .esysmem RAMGS1 PAGE &#x3D; 1 扩展的系统内存段，COFF格式兼容性 GROUP (CPU1TOCPU2RAM) CPU1TOCPU2RAM PAGE &#x3D; 1 CPU1到CPU2的通信缓冲区，包含多个子段 ramgs0&#x2F;ramgs1 RAMGS0&#x2F;RAMGS1 PAGE &#x3D; 1 明确指定这些内存区域的段名，以消除链接警告 RAMRAM模式主要包括MEMORY和SECTIONS两个字段，这个跟FLASH模式是一样的，但不同的是： 123456789MEMORY&#123;&#125;SECTIONS&#123;&#125; 一般MEMORY会分成两个PAGE：PAGE0和PAGE1，PAGE0存放program代码（RAM），PAGE1存放data代码（RAM），可以看到为了优化调试运行速度，所有的应用及数据都放在RAM运行了 1234567891011121314151617181920212223242526272829303132333435363738394041424344MEMORY&#123;PAGE 0 : BEGIN : origin = 0x000000, length = 0x000002 RAMM0 : origin = 0x000123, length = 0x0002DD RAMD0 : origin = 0x00B000, length = 0x000800 RAMLS0 : origin = 0x008000, length = 0x000800 RAMLS1 : origin = 0x008800, length = 0x000800 RAMLS2 : origin = 0x009000, length = 0x000800 RAMLS3 : origin = 0x009800, length = 0x000800 RAMLS4 : origin = 0x00A000, length = 0x000800 RESET : origin = 0x3FFFC0, length = 0x000002PAGE 1 : BOOT_RSVD : origin = 0x000002, length = 0x000121 RAMM1 : origin = 0x000400, length = 0x0003F8 RAMD1 : origin = 0x00B800, length = 0x000800 RAMLS0 : origin = 0x008000, length = 0x000800 RAMLS5 : origin = 0x00A800, length = 0x000800 RAMGS0 : origin = 0x00C000, length = 0x001000 RAMGS1 : origin = 0x00D000, length = 0x001000 RAMGS2 : origin = 0x00E000, length = 0x001000 /* 合并RAMGS3~5为一个大区 */ RAMGS3_5 : origin = 0x00F000, length = 0x003000 /* 注释掉原有的RAMGS3~5 RAMGS3 : origin = 0x00F000, length = 0x001000 RAMGS4 : origin = 0x010000, length = 0x001000 RAMGS5 : origin = 0x011000, length = 0x001000 */ RAMGS6 : origin = 0x012000, length = 0x001000 RAMGS7 : origin = 0x013000, length = 0x001000 RAMGS8 : origin = 0x014000, length = 0x001000 RAMGS9 : origin = 0x015000, length = 0x001000 RAMGS10 : origin = 0x016000, length = 0x001000 RAMGS11 : origin = 0x017000, length = 0x001000 RAMGS12 : origin = 0x018000, length = 0x001000 RAMGS13 : origin = 0x019000, length = 0x001000 RAMGS14 : origin = 0x01A000, length = 0x001000 RAMGS15 : origin = 0x01B000, length = 0x000FF8 CPU2TOCPU1RAM : origin = 0x03F800, length = 0x000400 CPU1TOCPU2RAM : origin = 0x03FC00, length = 0x000400 CANA_MSG_RAM : origin = 0x049000, length = 0x000800 CANB_MSG_RAM : origin = 0x04B000, length = 0x000800&#125; 我们可以看到下边代码段（eabi、text、const）以及数据段（bss、func、stack、data）全都存RAM空间 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647SECTIONS&#123; codestart : &gt; BEGIN, PAGE = 0 .reset : &gt; RESET, PAGE = 0, TYPE = DSECT /* 让.text段放入合并后的大区 */ .text : &gt; RAMGS3_5, PAGE = 1 .cinit : &gt; RAMM0, PAGE = 0 .switch : &gt; RAMM0, PAGE = 0 .bss : &gt; RAMLS5, PAGE = 1, ALIGN(8) .init_array : &gt; RAMM0, PAGE = 0 .const : &gt; RAMLS5, PAGE = 1 .data : &gt; RAMLS5, PAGE = 1 .sysmem : &gt; RAMLS5, PAGE = 1 .TI.ramfunc : &gt; RAMLS0, PAGE = 1, ALIGN(8) .stack : &gt; RAMM1, PAGE = 1, ALIGN(8) .pinit : &gt; RAMM0, PAGE = 0 .ebss : &gt; RAMLS5, PAGE = 1 .econst : &gt; RAMLS5, PAGE = 1 .esysmem : &gt; RAMLS5, PAGE = 1 Filter_RegsFile : &gt; RAMGS0, PAGE = 1 ramgs0 : &gt; RAMGS0, PAGE = 1 ramgs1 : &gt; RAMGS1, PAGE = 1 /* SDFM例程段移到后面未用的RAM区 */ Filter1_RegsFile : &gt; RAMGS6, PAGE = 1, fill=0x1111 Filter2_RegsFile : &gt; RAMGS7, PAGE = 1, fill=0x2222 Filter3_RegsFile : &gt; RAMGS8, PAGE = 1, fill=0x3333 Filter4_RegsFile : &gt; RAMGS9, PAGE = 1, fill=0x4444 Difference_RegsFile : &gt; RAMGS10, PAGE = 1, fill=0x3333 GROUP : &gt; CPU1TOCPU2RAM, PAGE = 1 &#123; PUTBUFFER PUTWRITEIDX GETREADIDX &#125; GROUP : &gt; CPU2TOCPU1RAM, PAGE = 1 &#123; GETBUFFER : TYPE = DSECT GETWRITEIDX : TYPE = DSECT PUTREADIDX : TYPE = DSECT &#125;&#125; 每个SECTIONS字段功能详解 段名称 内存位置 页面 说明 codestart BEGIN PAGE &#x3D; 0 代码起始部分，通常包含程序入口点和初始化代码 .reset RESET PAGE &#x3D; 0 复位向量段，用于处理CPU复位后的跳转地址，TYPE &#x3D; DSECT表示只是描述性的，不占用实际空间 .text RAMGS3_5 PAGE &#x3D; 1 主要代码段，包含程序的执行代码，放在合并的大内存区域中以容纳更多代码 .cinit RAMM0 PAGE &#x3D; 0 C语言全局变量初始化表段，用于存储全局变量的初始值 .switch RAMM0 PAGE &#x3D; 0 用于C语言switch语句的跳转表 .bss RAMLS5 PAGE &#x3D; 1 未初始化的全局和静态变量段，ALIGN(8)表示按8字节对齐 .init_array RAMM0 PAGE &#x3D; 0 用于C++全局对象构造函数的表 .const RAMLS5 PAGE &#x3D; 1 常量数据段，存放程序中的常量值 .data RAMLS5 PAGE &#x3D; 1 已初始化的全局和静态变量段 .sysmem RAMLS5 PAGE &#x3D; 1 动态内存分配的堆区域，用于malloc()等函数 .TI.ramfunc RAMLS0 PAGE &#x3D; 1 RAM函数段，存放需要在RAM中执行的高性能函数 .stack RAMM1 PAGE &#x3D; 1 系统堆栈段，用于函数调用和局部变量 .pinit RAMM0 PAGE &#x3D; 0 用于C++全局对象初始化的表(旧格式) .ebss RAMLS5 PAGE &#x3D; 1 扩展的.bss段，COFF格式兼容性 .econst RAMLS5 PAGE &#x3D; 1 扩展的常量段，COFF格式兼容性 .esysmem RAMLS5 PAGE &#x3D; 1 扩展的系统内存段，COFF格式兼容性 Filter_RegsFile RAMGS0 PAGE &#x3D; 1 滤波器寄存器文件，用于数字滤波器的配置数据 ramgs0&#x2F;ramgs1 RAMGS0&#x2F;RAMGS1 PAGE &#x3D; 1 明确指定这些内存区域的段名，以便在代码中直接引用 Filter1_RegsFile等 RAMGS6-10 PAGE &#x3D; 1 SDFM(Sigma-Delta滤波器模块)例程数据区，fill值用于特定的初始化模式 GROUP (CPU1TOCPU2RAM) CPU1TOCPU2RAM PAGE &#x3D; 1 CPU1到CPU2的通信缓冲区，包含多个子段用于数据传输和同步 GROUP (CPU2TOCPU1RAM) CPU2TOCPU1RAM PAGE &#x3D; 1 CPU2到CPU1的通信缓冲区，TYPE &#x3D; DSECT表示这些段在CPU1中只是描述性的","tags":["DSP","LAUNCHXL-F28379D","链接脚本"],"categories":["程序设计"]},{"title":"LAUNCHXL-F28379D自定义数据格式打印","path":"//launchxl-f28379d-custom-printf.html","content":"前言调试设备时往往需要有一个高效简单的printf函数帮助追踪错误日志、运行状态，DSP开发也不例外 介绍自带printf如果是按照stm32的方式通过自定义fputc来实现的话，它是可以打印字符串的，但是一旦自定义数值格式输出就报错（Interrupt_illegalOperationHandler） 123456789#include &lt;stdio.h&gt;#include &quot;driverlib/sci.h&quot;int fputc(int c, register FILE *stream)&#123; SCI_writeCharBlockingNonFIFO(SCIA_BASE, (uint16_t)c); while(SCI_getTxFIFOStatus(SCIA_BASE) != SCI_FIFO_TX0); return c;&#125; 配置SCI使用sysconfig配置SCIA串口引脚、参数，SCIA对应的是板子分配的默认串口：RXD和TXD分别对应GPIO43、GPIO42 自定义printf自定义打印函数实现，分别实现dsp_putchar、dsp_puts、print_int、print_float、dsp_printf几个函数 dsp_putchar通过SCI发送单个字符，和标准库putchar对应 1234void dsp_putchar(char c) &#123; SCI_writeCharBlockingNonFIFO(SCIA_BASE, (uint16_t)c); while(SCI_getTxFIFOStatus(SCIA_BASE) != SCI_FIFO_TX0);&#125; dsp_puts通过SCI发送字符串，和标准库puts对应 12345void dsp_puts(const char *str) &#123; while(*str) &#123; dsp_putchar(*str++); &#125;&#125; print_int将整数转换为字符并输出 123456789101112131415161718192021222324252627282930313233void print_int(int32_t num) &#123; char buffer[12]; // 足够保存32位整数 int i = 0; int is_negative = 0; // 特殊处理0 if(num == 0) &#123; dsp_putchar(&#x27;0&#x27;); return; &#125; // 处理负数 if(num &lt; 0) &#123; is_negative = 1; num = -num; &#125; // 转换整数到字符 while(num &gt; 0) &#123; buffer[i++] = &#x27;0&#x27; + (num % 10); num /= 10; &#125; // 如果是负数，添加负号 if(is_negative) &#123; dsp_putchar(&#x27;-&#x27;); &#125; // 反向输出字符 while(i &gt; 0) &#123; dsp_putchar(buffer[--i]); &#125;&#125; print_float将浮点数转换为字符并输出（带2位小数） 123456789101112131415161718192021222324void print_float(float num, int decimal_places) &#123; // 处理负数 if(num &lt; 0) &#123; dsp_putchar(&#x27;-&#x27;); num = -num; &#125; // 提取整数部分 int32_t integer_part = (int32_t)num; print_int(integer_part); // 小数点 dsp_putchar(&#x27;.&#x27;); // 处理小数部分 float fractional_part = num - integer_part; int i; for(i = 0; i &lt; decimal_places; i++) &#123; fractional_part *= 10; int digit = (int)fractional_part; dsp_putchar(&#x27;0&#x27; + digit); fractional_part -= digit; &#125;&#125; dsp_printf简单的格式化打印函数 - 支持 %d, %f, %s, %c 123456789101112131415161718192021222324252627282930313233343536373839404142434445void dsp_printf(const char *format, ...) &#123; va_list args; va_start(args, format); while(*format) &#123; // 处理格式化标记 if(*format == &#x27;%&#x27;) &#123; format++; // 根据格式化类型处理参数 switch(*format) &#123; case &#x27;d&#x27;: case &#x27;i&#x27;: // 整数 print_int(va_arg(args, int)); break; case &#x27;f&#x27;: // 浮点数 print_float(va_arg(args, double), 2); // 默认2位小数 break; case &#x27;s&#x27;: // 字符串 dsp_puts(va_arg(args, char*)); break; case &#x27;c&#x27;: // 字符 dsp_putchar(va_arg(args, int)); // 注意：char参数被提升为int break; case &#x27;%&#x27;: // 百分号 dsp_putchar(&#x27;%&#x27;); break; default: // 未知格式 dsp_putchar(&#x27;%&#x27;); dsp_putchar(*format); &#125; &#125; else &#123; // 普通字符直接输出 dsp_putchar(*format); &#125; format++; &#125; va_end(args);&#125; 格式化数据测试用例：用dsp_printf生成sin(x), cos(x), sin(x)*cos(x), cos(x)*cos(x)波形，%f表示浮点数、%d表示整形数据，%s表示字符串 123456789101112131415161718192021222324252627282930313233// 打印表头dsp_printf(&quot;Angle,Sin(x),Cos(x),Sin(x)*Cos(x),Cos(x)*Cos(x)\\r &quot;);// 生成三角函数数据float angle = 0.0f; // 角度(度)float angleRad; // 角度(弧度)float sinVal, cosVal; // sin(x)和cos(x)值float sinCosVal, cosSquareVal; // sin(x)*cos(x)和cos(x)*cos(x)值for(;;) &#123; // 每15度输出一次数据 while(angle &lt;= 360.0f) &#123; // 转换为弧度 angleRad = angle * 0.01745329f; // 0.01745329 = π/180 // 计算三角函数值 sinVal = sin(angleRad); cosVal = cos(angleRad); sinCosVal = sinVal * cosVal; cosSquareVal = cosVal * cosVal; // 使用指定格式输出数据：&quot;%f,%f,%f,%f &quot; dsp_printf(&quot;%f,%f,%f,%f\\r &quot;, sinVal, cosVal, sinCosVal, cosSquareVal); // 角度增加15度 angle += 15.0f; // 延时，避免输出太快 DEVICE_DELAY_US(10000); // 延时100ms &#125; angle = 0;&#125; 数据可视化使用vofa+工具显示FireWater的自定义格式的串口数据流 总结自定义dsp_printf更加高效，更加自由，依赖体积更小，无需关心stack大小限制","tags":["DSP","LAUNCHXL-F28379D","printf"],"categories":["程序设计"]},{"title":"Linux系统CAN通信开发指南","path":"//linux-can-usage.html","content":"介绍Linux自带socket CAN驱动，可以使用VCAN功能来模拟CAN数据的收发，这个在原型开发阶段非常有用，拿一台笔记本直接调试CAN设备 使用虚拟CAN加载vcan.ko，这个驱动是操作系统自带的，位置参考：&#x2F;usr&#x2F;lib&#x2F;modules&#x2F;5.15.0-131-generic&#x2F;kernel&#x2F;drivers&#x2F;net&#x2F;can 1sudo modprobe vcan 如果你的Linux操作系统没有vcan驱动，请下载kernel编译一个，VCAN驱动模块配置如下： 添加vcan设备：vcan0 12sudo ip link add dev vcan0 type vcansudo ip link set up vcan0 vcan卡连接、关闭 12ifconfig vcan0 upifconfig vcan0 down 发送随机数据用于开发、调试、测试 12345# 用cansend发送8个字节数据格式while true; do cansend vcan0 123#1122334455667788; sleep 1; done;# 发送随机数while true; do cansend vcan0 $(printf &quot;%X#%02X%02X%02X%02X%02X%02X%02X%02X&quot; $((RANDOM%0x800)) $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256))); sleep 1; done; 接收数据 1candump vcan0 can数据发送和接收情况统计 1ip -details -statistics link show vcan0 数据分析：可以用wireshark工具抓取can帧 真实CAN真实的CAN需要MCU&#x2F;MPU&#x2F;SOC端有CAN控制器（内部集成，引脚有RXD、TXD）、匹配的CAN收发器（CANH、CANL）、与之匹配的终端电阻（高速CAN为120Ω），常见的CAN收发器有： TJA1043 MCP2515 &#x2F; MCP2551 SN65HVD230 启用can设备：使用前先设置波特率，高速CAN为500k 12sudo ip link set can0 type can bitrate 500000sudo ip link set up can0 本地测试直接设置数据回环模式，如果不需要记得关掉，否则数据出不去也进不来！ 1234# 开启本地回环模式sudo ip link set can0 type can loopback on# 关闭本地回环模式sudo ip link set can0 type can loopback off 编码Linux C++实现CAN数据收发、状态检测、独立线程处理 can_bus_interface.hCanWorker负责处理socket CAN连接状态和数据的收发，CanBusInterface则作为一个单例管理CAN通信（开辟线程） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#ifndef CANBUSINTERFACE_H#define CANBUSINTERFACE_H#include &lt;QObject&gt;#include &lt;QSocketNotifier&gt;#include &lt;QThread&gt;#include &lt;QDebug&gt;#include &lt;linux/can.h&gt;#include &lt;string&gt;class CanWorker : public QObject&#123; Q_OBJECTpublic: explicit CanWorker(int socket, QObject *parent = nullptr); ~CanWorker();signals: void frameReceived(const struct can_frame &amp;frame); void errorOccurred(const QString &amp;errorString);private slots: void onSocketActivated(int socket);private: int m_socket; QSocketNotifier *m_notifier;&#125;;class CanBusInterface : public QObject&#123; Q_OBJECTpublic: static CanBusInterface *getInstance();protected: explicit CanBusInterface(QObject *parent = nullptr); ~CanBusInterface();public: bool open(const std::string &amp;interfaceName); void close(); bool isOpen() const; bool sendFrame(const struct can_frame &amp;frame);signals: void frameReceived(const struct can_frame &amp;frame); void errorOccurred(const QString &amp;errorString);private: int m_socket; bool m_isOpen; QThread *m_workerThread; CanWorker *m_worker;&#125;;#endif // CANBUSINTERFACE_H can_bus_interface.cppCanWorker和CanBusInterface的实现部分，socketCAN的配置：socket(PF_CAN, SOCK_RAW, CAN_RAW) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include &quot;can_bus_interface.h&quot;#include &lt;QDebug&gt;#include &lt;QSocketNotifier&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;net/if.h&gt;#include &lt;unistd.h&gt;// CanWorker 实现CanWorker::CanWorker(int socket, QObject *parent) : QObject(parent), m_socket(socket), m_notifier(nullptr)&#123; // 创建socket通知器 m_notifier = new QSocketNotifier(m_socket, QSocketNotifier::Read, this); connect(m_notifier, &amp;QSocketNotifier::activated, this, &amp;CanWorker::onSocketActivated); qRegisterMetaType&lt;can_frame&gt;(&quot;can_frame&quot;);&#125;CanWorker::~CanWorker()&#123; if (m_notifier) &#123; m_notifier-&gt;setEnabled(false); delete m_notifier; &#125;&#125;void CanWorker::onSocketActivated(int socket)&#123; Q_UNUSED(socket); struct can_frame frame; int bytesRead = read(m_socket, &amp;frame, sizeof(frame)); if (bytesRead == sizeof(frame)) &#123; emit frameReceived(frame); &#125; else if (bytesRead &lt; 0) &#123; emit errorOccurred(&quot;Failed to read CAN frame&quot;); &#125;&#125;// CanBusInterface 实现CanBusInterface *CanBusInterface::getInstance()&#123; static CanBusInterface instance; return &amp;instance;&#125;CanBusInterface::CanBusInterface(QObject *parent) : QObject(parent), m_socket(-1), m_isOpen(false), m_workerThread(nullptr), m_worker(nullptr)&#123;&#125;CanBusInterface::~CanBusInterface()&#123; close();&#125;bool CanBusInterface::open(const std::string &amp;interfaceName)&#123; if (m_isOpen) &#123; qWarning() &lt;&lt; &quot;CAN interface is already open&quot;; return true; &#125; // 创建socket m_socket = socket(PF_CAN, SOCK_RAW, CAN_RAW); if (m_socket &lt; 0) &#123; emit errorOccurred(&quot;Failed to create socket&quot;); return false; &#125; // 获取接口索引 struct ifreq ifr; strncpy(ifr.ifr_name, interfaceName.c_str(), IFNAMSIZ - 1); ifr.ifr_name[IFNAMSIZ - 1] = &#x27;\\0&#x27;; if (ioctl(m_socket, SIOCGIFINDEX, &amp;ifr) &lt; 0) &#123; emit errorOccurred(&quot;Failed to get interface index&quot;); ::close(m_socket); m_socket = -1; return false; &#125; // 绑定socket到CAN接口 struct sockaddr_can addr; addr.can_family = AF_CAN; addr.can_ifindex = ifr.ifr_ifindex; if (bind(m_socket, (struct sockaddr *)&amp;addr, sizeof(addr)) &lt; 0) &#123; emit errorOccurred(&quot;Failed to bind socket to interface&quot;); ::close(m_socket); m_socket = -1; return false; &#125; // 创建并启动工作线程 m_workerThread = new QThread(); m_worker = new CanWorker(m_socket); m_worker-&gt;moveToThread(m_workerThread); // 连接信号槽 connect(m_workerThread, &amp;QThread::finished, m_worker, &amp;CanWorker::deleteLater); connect(m_workerThread, &amp;QThread::finished, m_workerThread, &amp;QThread::deleteLater); connect(m_worker, &amp;CanWorker::frameReceived, this, &amp;CanBusInterface::frameReceived); connect(m_worker, &amp;CanWorker::errorOccurred, this, &amp;CanBusInterface::errorOccurred); m_workerThread-&gt;start(); m_isOpen = true; return true;&#125;void CanBusInterface::close()&#123; if (!m_isOpen) return; m_isOpen = false; if (m_workerThread) &#123; m_workerThread-&gt;quit(); m_workerThread-&gt;wait(); m_workerThread = nullptr; m_worker = nullptr; &#125; if (m_socket &gt;= 0) &#123; ::close(m_socket); m_socket = -1; &#125;&#125;bool CanBusInterface::isOpen() const&#123; return m_isOpen;&#125;bool CanBusInterface::sendFrame(const struct can_frame &amp;frame)&#123; if (!m_isOpen) &#123; emit errorOccurred(&quot;CAN interface is not open&quot;); return false; &#125; int bytesWritten = write(m_socket, &amp;frame, sizeof(frame)); if (bytesWritten != sizeof(frame)) &#123; emit errorOccurred(&quot;Failed to write CAN frame&quot;); return false; &#125; return true;&#125; 注意点1：这里需要把can_frame类型注册为Qt能够识别的元数据类型 1qRegisterMetaType&lt;can_frame&gt;(&quot;can_frame&quot;); 注意点2：只有独立的QObject才能使用moveToThread 12345m_workerThread = new QThread();m_worker = new CanWorker(m_socket);m_worker-&gt;moveToThread(m_workerThread);m_workerThread-&gt;start();","tags":["linux","CAN"],"categories":["程序设计"]},{"title":"QtCreator16.0.1设计页面无法打开","path":"//qtcreator-designer-page-problem.html","content":"介绍刚刚安装好的Qt6.8.3，打开Qt Creator 16.0.1发现无法使用设计UI或者QML文件的功能，左侧栏的按钮完全是置灰不可用的状态 解决点击菜单栏 -&gt; 帮助 -&gt; 关于插件，搜索Qt Quick，勾选Qt Quick Designer重启即可，但看样子后面是不太会支持下去了 设计功能重新正常使用：QML编辑和预览","tags":["QtCreator","Qt6"],"categories":["程序设计"]},{"title":"一个简单的QML工程参考示例","path":"//simple-qml-project.html","content":"介绍在RK3588触摸屏上使用QML开发手持设备应用 CMakeQML工程需要包含C、C++、QML、QRC、UI等文件，参考配置如下 1234567891011121314151617181920212223242526272829303132333435363738394041cmake_minimum_required(VERSION 3.5)project(demo LANGUAGES CXX)set(CMAKE_INCLUDE_CURRENT_DIR ON)set(CMAKE_AUTOUIC ON)set(CMAKE_AUTOMOC ON)set(CMAKE_AUTORCC ON)set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED ON)find_package(Qt5 COMPONENTS Core Quick REQUIRED)include_directories($&#123;CMAKE_SOURCE_DIR&#125;)set(SRC_DIR $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;)file(GLOB_RECURSE SRC &quot;$&#123;SRC_DIR&#125;/*.cpp&quot; &quot;$&#123;SRC_DIR&#125;/*.cxx&quot; &quot;$&#123;SRC_DIR&#125;/*.cc&quot; &quot;$&#123;SRC_DIR&#125;/*.c&quot;)file(GLOB_RECURSE HEADERS &quot;$&#123;SRC_DIR&#125;/*.h&quot; &quot;$&#123;SRC_DIR&#125;/*.hpp&quot; &quot;$&#123;SRC_DIR&#125;/*.hxx&quot;)file(GLOB_RECURSE RES &quot;$&#123;SRC_DIR&#125;/*.ui&quot; &quot;$&#123;SRC_DIR&#125;/*.qrc&quot;)add_executable($&#123;PROJECT_NAME&#125; $&#123;SRC&#125; $&#123;HEADERS&#125; $&#123;RES&#125;)target_compile_definitions($&#123;PROJECT_NAME&#125; PRIVATE $&lt;$&lt;OR:$&lt;CONFIG:Debug&gt;,$&lt;CONFIG:RelWithDebInfo&gt;&gt;:QT_QML_DEBUG&gt;)target_link_libraries($&#123;PROJECT_NAME&#125; PRIVATE Qt5::Core Qt5::Quick) 代码main.cpp，与普通的Qt5应用不同的是：运行的主体变成了main.QML，cpp文件只是提供了一个应用入口，通常的做法也是将QML放到qrc里边来提高运行效率 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;QGuiApplication&gt;#include &lt;QQmlApplicationEngine&gt;#include &lt;QQuickWindow&gt;#include &lt;QQmlContext&gt;class MainViewObject : public QObject &#123; Q_OBJECT Q_PROPERTY(QString text READ getText WRITE setText NOTIFY textChanged)public: explicit MainViewObject(QObject *parent = nullptr) : QObject(parent) &#123; &#125; ~MainViewObject() &#123; &#125;protected: QString getText() &#123; return m_text; &#125; void setText(const QString &amp;text) &#123; m_text = text; &#125;signals: void textChanged();private: QString m_text = &quot;hello world&quot;;&#125;;int main(int argc, char *argv[]) &#123; QGuiApplication app(argc, argv); QQmlApplicationEngine engine; MainViewObject main; engine.rootContext()-&gt;setContextProperty(&quot;mainObject&quot;, &amp;main); engine.load(QUrl(QStringLiteral(&quot;qrc:/QML/MainView.QML&quot;))); QObject *rootObject = engine.rootObjects().first(); QQuickWindow *window = qobject_cast&lt;QQuickWindow*&gt;(rootObject); if (window) &#123; window-&gt;show(); &#125; return app.exec();&#125;#include &quot;main.moc&quot; MainView.qml，类js脚本文件，可以看到跟C++编译定义式不一样的是：QML这里很多对象或控件（Window、Label、Image、Rectangle、Row、Timer）都变成了声明式，根据对象的属性直接配置就好，对象之间的联动可以通过信号和槽来实现 1234567891011121314151617181920212223242526import QtQuick 2.12import QtQuick.Controls 2.12import QtQuick.Window 2.12Window &#123; id: mainWindow width: 1280 height: 720 visible: true flags: Qt.Window | Qt.FramelessWindowHint color: &quot;white&quot; Label &#123; id: textLabel font &#123; pixelSize: 36 &#125; text: mainObject.text color: &quot;black&quot; anchors.centerIn: parent width: parent.width * 0.8 horizontalAlignment: Text.AlignHCenter verticalAlignment: Text.AlignVCenter &#125;&#125; 对象交互属性访问C++ -&gt; QML：通过context property传递或者qmlRegisterType方式 第一种方式，C++端注册mainObject对象，可以在QML直接使用C++对象属性 1234QQmlApplicationEngine engine;MainViewObject main;engine.rootContext()-&gt;setContextProperty(&quot;mainObject&quot;, &amp;main);engine.load(QUrl(QStringLiteral(&quot;qrc:/QML/MainView.QML&quot;))); 比如想要在Label对象里边使用mainObject对象的属性，都不需要有显式的import声明 123Label &#123;\ttext: mainObject.text&#125; 另一种方式是，注册QML对象的方式，这种方式可以提供成员函数调用 1234567891011121314151617181920class QmlObject : public QObject &#123; Q_OBJECTpublic: explicit QmlObject(QObject *parent = nullptr) : QObject(parent) &#123; &#125; ~QmlObject() &#123; &#125; Q_INVOKABLE QString getName() &#123; return m_text; &#125;private: QString m_text = &quot;hello world&quot;;&#125;;qmlRegisterType&lt;QmlObject&gt;(&quot;QmlObject&quot;, 1, 0, &quot;QmlObject&quot;); QML对象可以通过上面的对象名称访问成员函数或者属性，不过跟前一种不同的是，这里需要显式调用import 123456789101112131415import QmlObject 1.0Window &#123; id: mainWindow width: 1280 height: 720 visible: true flags: Qt.Window | Qt.FramelessWindowHint color: &quot;white&quot; property int demo: 1314 Component.onCompleted: &#123; console.log(&quot;name : &quot;, QmlObject.getName()) &#125;&#125; QML -&gt; C++ 可以在QML侧定义property或者指定对象的objectName 12345678910111213import QtQuick 2.12import QtQuick.Controls 2.12import QtQuick.Window 2.12Window &#123; property int demo: 1314 Label &#123; id: customLabel text: mainObject.text objectName: &quot;myLabel&quot; &#125;&#125; C++侧访问QML对象属性和子对象 12345QObject *rootObject = engine.rootObjects().first();qDebug() &lt;&lt; &quot;demo : &quot; &lt;&lt; rootObject-&gt;property(&quot;demo&quot;).toInt();auto label = rootObject-&gt;findChild&lt;QObject *&gt;(&quot;myLabel&quot;);label-&gt;setProperty(&quot;text&quot;, &quot;nice to meet you!&quot;); 信号和槽C++侧定义updateText信号 1234567891011121314151617181920212223242526272829303132// 对象定义class MainViewObject : public QObject &#123; Q_OBJECT Q_PROPERTY(QString text READ getText WRITE setText NOTIFY textChanged)public: explicit MainViewObject(QObject *parent = nullptr) : QObject(parent) &#123; &#125; ~MainViewObject() &#123; &#125;protected: QString getText() &#123; return m_text; &#125; void setText(const QString &amp;text) &#123; m_text = text; &#125;signals: void textChanged(); void updateText(const QString &amp;text);private: QString m_text = &quot;hello world&quot;;&#125;;// C++端发出信号emit main.updateText(&quot;hywing&quot;); QML侧捕获updateText信号，需要在Connections里边定义槽函数 12345678910111213141516171819Label &#123; id: textLabel objectName: &quot;myLabel&quot; font &#123; pixelSize: 36 &#125; Connections &#123; target: mainObject function onUpdateText(text) &#123; textLabel.text = text; console.log(text) &#125; &#125; Component.onCompleted: &#123; console.log(&quot;this is myLabel&quot;)\t&#125;&#125; 也可以这样给一个对象绑定一个匿名槽函数，textChanged这个信号必须在MainViewObject里边提供 123456Component.onCompleted: &#123; console.log(&quot;this is myLabel&quot;) mainObject.textChanged.connect( function() &#123; console.log(&quot;signal emitted!&quot;) &#125;)&#125; 调试QML的远程调试需要绑定端口号来使用，实际开发往往都是用console打log，就像web html那样；因此我觉得，它做界面就够了，不要把复杂的业务逻辑打包在脚本文件里边 总结 QML库的水太深，容易奔溃（有时候是编译不报错，运行时报错，有些版本库命名也没有统一），做QML开发需要关注不同Qt5版本的兼容性问题，目前用2.12在Qt5.12.9和Qt5.15.8运行都没有问题 封装继承不好实现，因为如果是简单的UI可以用QML尝试，复杂要继承的话还是走C++吧 业务逻辑也不推荐放QML端，一个脚本解析引擎的效率要打上问号","tags":["Qt5","QML","触摸屏","车载"],"categories":["嵌入式"]},{"title":"RK3588移植GPSD","path":"//rk3588-port-gpsd.html","content":"介绍在Ubuntu20.04上交叉编译gpsd-3.25，目标系统为rk3588 Linux，目标编译工具链为aarch64-buildroot-linux-gnu 移植rk3588编译工具链配置 1234source /opt/rk3588/rk3588-aarch64-buildroot-linux-gnu/environment-setupexport TOOLCHAIN_PATH=/opt/rk3588/rk3588-aarch64-buildroot-linux-gnuexport SYSROOT=$TOOLCHAIN_PATH/aarch64-buildroot-linux-gnu/sysrootexport PATH=$TOOLCHAIN_PATH/bin:$PATH GPSD使用scons工具构建，Ubuntu20.04上安装scons 1sudo apt install scons scons工具大致用法 123456# 清理scons -c# 编译（可带参数）scons # 安装scons install GPSD交叉编译配置 1scons target=aarch64-buildroot-linux-gnu sysroot=$SYSROOT prefix=$PWD/build gpsd_user=nobody gpsd_group=nogroup install_root=$PWD/build qt=no python=no dbus=no chrpath=no strip=yes ncurses=no 使用scons install命令安装到指定目录，然后部署到rk3588开发板上去（adb或者scp） 运行部署至开发板的&#x2F;userdata&#x2F;admin目录，实际上只要bin、sbin、lib三个目录就够了，然后配置环境变量 12export PATH=/userdata/admin/build/bin:/userdata/admin/build/sbin:$PATHexport LD_LIBRARY_PATH=/userdata/admin/build/lib:$LD_LIBRARY_PATH 找到GNSS的串口节点，可以用cat命令，我这里的节点是ttyS1 1cat /dev/ttyS1 生成配置文件：&#x2F;etc&#x2F;gpsd.conf 123456[gpsd]listen = &quot;0.0.0.0&quot;port = &quot;2947&quot;device = &quot;/dev/ttyS1&quot;speed = &quot;9600&quot;nowake = &quot;true&quot; 运行gpsd应用 1/userdata/admin/build/sbin/gpsd -n -G -F /etc/gpsd.conf 测试可以用gpsd命令打印当前的定位数据：gpsd -N -n -D5 &#x2F;dev&#x2F;ttyS1 进阶把gpsd做成一个自启动的service 123456789[Unit]Description=gpsd.service[Service]ExecStart=/usr/bin/bash /userdata/admin/autorun.sh#Restart=always[Install]WantedBy=sysinit.target","tags":["linux","rk3588","gpsd"],"categories":["嵌入式"]},{"title":"stm32f103rct6开发板无法调试问题","path":"//stm32f103rct6-board-cannot-debug.html","content":"介绍STM32CubeMX配置及生成工程，发现用Keil5编译、下载后居然无法在线调试！ 可以明确的是：编译和下载没有问题，但启动仿真之后就会报错 回头看ST-Link V2调试器已经掉了，直觉是这个板子已经变砖了…… 救砖Debug选项栏配置Connect方式为：under Reset 按住开发板RESET按键，点击Download按钮，程序又能正常烧录了，但还是依旧无法仿真的 但按住RESET键，发现ST-Link V2调试器是能重新识别的 分析ST-Link V2调试器应该没有问题，大概率是通信出了问题，比如：SWD的GPIO配置不对，仔细看SWDIO和SWCLK两个口的状态都是黄的，应该没有正常工作 解决点击System Core -&gt; SYS，配置Debug项为：Serial Wire，重新生成工程代码编译烧录即可解决问题 stm32f103rct6的SYS配置跟stm32g030c8t6的有点不大一样","tags":["debug","stm32","stm32f103rct6","swd"],"categories":["嵌入式"]},{"title":"汽车电子专业英语合集","path":"//automotive-electronics-english.html","content":"前言汽车电子领域专业英语词汇汇总，不定期更新 词汇芯片类 VCU：Vehicle Control Unit，整车控制器 ECU：Electronic Control Unit，电子控制单元 AUTOSAR：Automotive Open System ARchitecture，开放的汽车电子系统软件架构标准 Domain Controller：域控制器 Power Train Domain：动力域 Chassis Domain：底盘域 Body Domain：车身域 ADAS Domain：智能驾驶域 HMI Domain：智能座舱域 Automotive Domain：自动驾驶域 ADAS：Advanced Driver Assistance Systems，高阶辅助驾驶系统 车灯类 前照明灯：Front position lamp 后照明灯：Rear position lamp 左照明灯：Left-side marker lamp 右照明灯：Right-side marker lamp 驾驶室顶灯：Cab interior lamp 左转向灯：Left turn signal lamp 右转向灯：Right turn signal lamp 示廊灯：Clearance lamp 前近光灯：Low beam headlamp 前远光灯：High beam headlamp 前雾灯：Front fog lamp 信号报警灯：Warning signal lamp 旋转报警灯：Rotating beacon light 刹车灯：Stop lamp 后牌照灯：License plate lamp 喇叭：Horn 发动机类 发动机转速：engine speed 机油压力：engine oil pressure 水温：water temperature 负载率：load rate 机油温度：engine oil temperature 瞬时油耗：instantaneous fuel consumption 增压温度：boost temperature 发动机总油耗：total fuel consumption 发动机总时间：engine total hours 离合器滑差：clutch slip 传感器类 刹车踏板：brake pedal 油门踏板：accelerator pedal 履带涨紧压力：track tension pressure 吸回油压力发讯器：suction oil pressure sensor 发动机电子阻塞：Engine Electronic Limp Mode 转向角度传感器：Steering Angle Sensor 驾驶室暖风：Cab Heater 发动机循环水加热：Engine Coolant Heating 故障 可疑参数编号：suspect parameter number，SPN 故障模式标识：failure mode identifier，FMI 故障发生次数：occurence count，OC","tags":["专业英语","汽车电子"],"categories":["学科"]},{"title":"关于模态对话框","path":"//about-dialog.html","content":"介绍模态对话框的特点 对话框对象是置顶的、独立的、垄断的，会把用户的输入焦点抢走 用户只能操作、响应这个对话框，完成必要的交互之后才能退出 只能使用特定的接口才能退出模态页面 使用什么情况下时候用Dialog / QDialog这样的模态对话框？ 升级管理：成功、失败、进行中 WiFi、蓝牙、4G、串口等配置管理界面 提示框（错误、警告、结果） 文件管理器也可以 自定义参数配置表 关于页面 密码设置 输入法键盘可以是一个模态对话框 什么时候不能用模态对话框？ 主界面 生存周期为全局的页面不推荐使用模态 状态刷新控件 嵌套在父控件里边的控件 模态对话框使用要点？ 嵌入式触摸平台大都需要重新实现顶部标题栏样式：标题+长方形背景+退出按钮，因为自带样式实在太丑了 show和exec两个函数的样式不一致，特别是show的样式容易被父控件污染，模态属性下样式独立于父控件 尽量避免使用static成员变量，但可以传递参数，如果你想使用把对话框对象当作局部变量来使用 和Qt定制输入法有冲突，需要改变窗体属性来唤起输入法界面 巧用reject（叉掉）和accept（确定），什么都不知道就close（对话框之外的点击） 尽量用QML（Dialog）吧，对触摸友好一些","tags":["Qt","QDialog","模态"],"categories":["嵌入式","程序设计"]},{"title":"Qt EGLFS按钮边框残影问题","path":"//qt-eglfs-button-frame-shadow.html","content":"介绍嵌入式Qt EGLFS由于没有窗口系统，很多控件的样式或者行为都跟PC、甚至是嵌入式的wayland-egl、linuxfb不大一样，比如QPushButton聚焦的时候它会带一个虚线框，而其它平台是不会的，qtvirtualkeyboard输入法插件也用起来怪怪的…… 解决统一控件的默认样式即可，比如Fusion，Fusion 是 Qt 提供的一个跨平台 widget 样式，它不依赖于任何特定操作系统的原生外观，而是提供了一套 Qt 自绘的统一界面风格 1qputenv(&quot;QT_STYLE_OVERRIDE&quot;, &quot;Fusion&quot;); 另外触摸屏上的QPushButton尽量用pressed属性，不论是样式表还是信号绑定，clicked有时候会没有反应！（点击了按钮明明样式变了，就是不会触发槽函数，不知道是不是EGLFS的问题）","tags":["Qt","宏定义"],"categories":["嵌入式"]},{"title":"跨平台宏定义","path":"//crossplatform-macros.html","content":"介绍由于业务的需要，经常在不同的操作系统平台编写代码，各个系统平台（编译器）下的接口总有差异，越往底层走差异越大，比如摄像头，在Windows下它可以是一个通用的camera，但是在Linux下你得写V4L2视频采集的驱动。怎么办，你只能用一些条件编译的方法把不同操作系统的个性化处理隔离开，这就需要使用跨平台的宏定义了 编译器相关__aarch64__ ：特指aarch64编译器，如RK3588、XILINX ZU3EG平台 __linux__ ：Linux操作系统，arm或者x64均适用 _WIN64：编写x64应用时的宏定义，表示是64位的MSVC编译器 _WIN32：编写x32应用时的宏定义，表示是32位的MSVC编译器 WIN32：这个是Windows平台的gcc内置的宏定义 QT相关Q_OS_WIN：表示当前系统为Windows Q_OS_WIN32：表示当前开发程序为win32应用 Q_OS_WIN64：表示当前开发程序为win64应用 Q_OS_WINDOWS：表示当前系统为Windows Q_OS_LINUX：表示当前系统为Linux，这个宏好像没有什么用，识别不了Ubuntu20.04系统 Q_OS_MAC：表示当前系统为mac Q_OS_FREEBSD：表示当前系统为FreeBSD Q_OS_ANDROID：表示当前系统为Android 参考 gcc查看编译器内置宏定义：gcc -dM -E - &lt;&#x2F;dev&#x2F;null qt内置宏定义","tags":["跨平台","宏定义"],"categories":["程序设计"]},{"title":"Linux环境下使用ADB命令做嵌入式开发","path":"//adb-command-usage.html","content":"介绍adb一般是给Android开发用的，但是换个思路也能做嵌入式Linux开发 安装以Ubuntu20.04为例 1sudo apt install android-tools-adb android-tools-fastboot 安装成功可以查看adb版本号 命令查看adb设备 登录shell 上传文件到设备指定目录 拉取设备上的文件到本地指定目录 端口转发：转发22端口用于QtCreator远程调试 然后配置Devices参数，记得多转发几个端口：10000-10005，Host name处填写localhost 移除所有ADB端口转发 进阶利用udev机制在ADB驱动装载之后执行自定义脚本：sudo vim /etc/udev/rules.d/99-adb-forward.rules 123ACTION==&quot;add&quot;, SUBSYSTEM==&quot;usb&quot;, ENV&#123;PRODUCT&#125;==&quot;2717/ff08/*&quot;, \\ RUN+=&quot;/bin/bash -c &#x27;echo UDEV_CALLED &gt;&gt; /tmp/udev_test.log &amp;&amp; \\ /bin/su asensing -c \\&quot;/usr/local/bin/adb_forward.sh\\&quot;&#x27;&quot; 其中，ENV&#123;PRODUCT&#125;参数可以通过sudo udevadm monitor --property命令查看到 adb_forward.sh脚本写法参考 1234567891011121314151617181920212223242526272829303132333435363738#!/bin/bashexport PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binLOG_FILE=&quot;/tmp/adb_forward.log&quot;exec &gt;&gt; &quot;$LOG_FILE&quot; 2&gt;&amp;1echo &quot;=== $(date) ===&quot;echo &quot;UDEV ENV:&quot;printenv | grep -E &#x27;ACTION|DEVPATH|PRODUCT|INTERFACE&#x27; &gt;&gt; &quot;$LOG_FILE&quot;# 等待设备初始化sleep 3# 检测adb命令ADB_CMD=$(which adb)if [ -z &quot;$ADB_CMD&quot; ]; then echo &quot;ERROR: adb not found!&quot; &gt;&gt; &quot;$LOG_FILE&quot; exit 1fi# 启动adb服务echo &quot;Starting ADB server...&quot;$ADB_CMD start-server# 等待设备就绪# 执行端口转发echo &quot;Executing: adb forward tcp:8022 tcp:22&quot; &gt;&gt; &quot;$LOG_FILE&quot;$ADB_CMD forward tcp:8022 tcp:22if [ $? -eq 0 ]; then echo &quot;SUCCESS: Port forwarding established&quot; &gt;&gt; &quot;$LOG_FILE&quot;else echo &quot;ERROR: Port forwarding failed&quot; &gt;&gt; &quot;$LOG_FILE&quot; $ADB_CMD devices -l &gt;&gt; &quot;$LOG_FILE&quot; exit 3fi 这样你的Linux设备一旦连接到虚拟机，Ubuntu就可以默认开启adb端口转发了 日志监控 12touch /tmp/adb_forward.logtail -f /tmp/adb_forward.log 总结生命在于折腾！没有网口的情形下可以用ADB转发模拟网络通信，这样gdbserver、ssh、smb、nfs、tftp等网络服务就可以使用了","tags":["linux","adb"],"categories":["嵌入式"]},{"title":"ch32v307vct6样片申请","path":"//ch32v307vct6-sample-request.html","content":"沁恒微电子官网的介绍 南京沁恒微电子股份有限公司专注于连接技术和微处理器内核研究，是一家基于自研专业接口IP、微处理器内核IP构建芯片的集成电路设计企业。公司致力于为客户提供万物互联、上下互通的芯片及解决方案，主要产品包括USB&#x2F;蓝牙&#x2F;以太网接口芯片和连接型&#x2F;互联型&#x2F;无线型MCU，产品侧重于连接、联网和控制 CH32V307 CH32V305&#x2F;7系列是基于32位RISC-V设计的互联型微控制器，配备了硬件堆栈区、快速中断入口，在标准RISC-V基础上大大提高了中断响应速度。加入单精度浮点指令集，扩充堆栈区，具有更高的运算性能。扩展串口UART数量到8组，电机定时器到4组。提供USB2.0高速接口（480Mbps）并内置了PHY收发器，以太网MAC升级到千兆并集成了10M-PHY模块 申请流程打开沁恒微电子官网 点击服务支持，选择样品索取 填写相关信息 不久就会有技术支持人员过来电话联系你，加微信，告知快递信息，隔个两三天快递就会送到 官方给的资料包里边有各种各样的外设demo（支持各式各样的国产RTOS）、原理图、芯片datasheet，还超级nice的提供了PCB工程！ 快递开箱美照 沁恒还非常贴心的多给了两块芯片 万物基于点灯，第一时间点灯，必须的！ 感慨自中美贸易战打响以来，国内的mcu芯片产业如同以后春笋一般蓬勃发展，对于嵌入式工程师来说是一件非常值得高兴的事情！毕竟选择多了很多，不再让别人卡脖子，RISC-V这种开源指令集最有可能让我们实现弯道超车，希望国人不要放弃机会！","tags":["沁恒","样片","ch32v307vct6"],"categories":["嵌入式"]},{"title":"自定义数据类型支持qDebug输出","path":"//qdebug-custom-data.html","content":"前言写Qt程序的时候，发现自定义数据数据对象就不能用qDebug直接输出了，每次都要写一大串的字符参数列表来打印log，有没有什么办法可以直接打印对象呢？很简单，写个友元函数就OK了 实现以结构体类型为例，需要实现&lt;&lt;运算符重载 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct Point&#123; float x; float y; float z; int id; int intensity; int imageX; int imageY; Point() &#123; this-&gt;x = qQNaN(); this-&gt;y = qQNaN(); this-&gt;z = qQNaN(); this-&gt;id = qQNaN(); this-&gt;intensity = qQNaN(); this-&gt;imageX = qQNaN(); this-&gt;imageY = qQNaN(); &#125; Point(const Point &amp;point) &#123; this-&gt;x = point.x; this-&gt;y = point.y; this-&gt;z = point.z; this-&gt;id = point.id; this-&gt;intensity = point.intensity; this-&gt;imageX = point.imageX; this-&gt;imageY = point.imageY; &#125; Point &amp;operator =(const Point &amp;point) &#123; this-&gt;x = point.x; this-&gt;y = point.y; this-&gt;z = point.z; this-&gt;id = point.id; this-&gt;intensity = point.intensity; this-&gt;imageX = point.imageX; this-&gt;imageY = point.imageY; return *this; &#125; friend QDebug operator&lt;&lt;(QDebug dbg, const Point &amp;point) &#123; dbg &lt;&lt; point.id &lt;&lt; &quot; : (&quot; &lt;&lt; point.x &lt;&lt; &quot;,&quot; &lt;&lt; point.y &lt;&lt; &quot;,&quot; &lt;&lt; point.z &lt;&lt; &quot;)&quot; &lt;&lt; &quot; intensity : &quot; &lt;&lt; point.intensity; return dbg; &#125;&#125;; 然后自定义的数据可以直接用qDebug打印了 1qDebug() &lt;&lt; Point();","tags":["Qt","qDebug"],"categories":["程序设计"]},{"title":"github无法提交代码问题","path":"//github-cannot-push.html","content":"问题描述提交代码到个人仓库的时候发现报错，认证失败 12345Username for &#x27;https://github.com&#x27;: hywingPassword for &#x27;https://hywing@github.com&#x27;: remote: Support for password authentication was removed on August 13, 2021.remote: Please see https://docs.github.com/en/get-started/getting-started-with-git/about-remote-repositories#cloning-with-https-urls for information on currently recommended modes of authentication.fatal: Authentication failed for &#x27;https://github.com/hywing/rt-thread.git/&#x27; 解决办法在GitHub页面点击右上角个人logo，选择Settings进入Settings页面 在Settings页面拉到最下方点击Developer Settings 在Developer Settings页面依次点击Personal access tokens，Token (classic)，Generate new token，Generate new token (classic) 填写口令信息，点击Generate token，点击你所需要的访问权限，然后拷贝口令 然后你需要通用的url格式来验证你对远程仓库的控制权限 1https://刚刚拷贝的口令@github.com/你的用户名/你的仓库名称.git 将生成的口令拷贝，作为 git clone仓库的前缀，我的口令是随意填写的，这里要填你自己的token口令 1git clone https://aaa_bbbKoJyB0oJbuQYjJOILugksoT9VB93TTTTT@github.com/hywing/rt-thread.git 如果已有仓库可以通过set url的方式更新token 1git remote set-url origin https://aaa_bbbKoJyB0oJbuQYjJOILugksoT9VB93TTTTT@github.com/hywing/rt-thread.git 这样，你就可以顺利对远程仓库进行操作了","tags":["GitHub"],"categories":["开发工具"]},{"title":"Qt在子控件上绘图","path":"//qt-subcontrol-painting.html","content":"前言有时候，我们并不想派生一个类（可能是因为懒，毕竟要写cpp和h文件，还要重写它的paintEvent虚函数），可是父控件的paintEvent并不是你想用就能用的，因为它只属于父控件；那有没有一种办法，可以在父控件的类里边实现子控件的绘图呢？ 介绍我们需要对Qt的事件机制比较熟悉，比如paintEvent，它本质是一个QEvent::paint的事件；如果在事件队列里边拦截了QEvent::paint，再进行QPainter绘图，这个和paintEvent是一样的效果！ 举例这里的ui-&gt;dashboard1是一个QLabel，我们打算侦听它的事件 1ui-&gt;dashboard1-&gt;installEventFilter(this); 重写父控件的eventFilter事件，侦听QEvent::Paint事件 1234567bool MainWidget::eventFilter(QObject *obj, QEvent *evt)&#123; if(obj == ui-&gt;dashboard1 &amp;&amp; evt-&gt;type() == QEvent::Paint) &#123; this-&gt;drawArc(ui-&gt;dashboard1); &#125; return QFrame::eventFilter(obj, evt);&#125; 子控件绘图：这里可以加入自定义的效果 123456789void MainWidget::drawArc(QWidget *widget)&#123; QPainter painter(widget); painter.setRenderHint(QPainter::Antialiasing, true); QPointF center(204, 204); painter.setPen(Qt::NoPen); painter.setBrush(Qt::red); painter.drawEllipse(center, 3, 3);&#125;","tags":["Qt","绘图"],"categories":["程序设计"]},{"title":"FRDM-MCXW71开发指南","path":"//frdm-mcxw71-tutorial.html","content":"前言我从NXP官网申请了FRDM-MCXW71开发板，这个是专门为无线连接设计的MCU方案 介绍MCXW71是NXP推出的一款低功耗、高安全系数、面向无线连接的MCU，它的最大主频有96MHz，内核为Cortex-M33，片上集成1MB flash和128KB SRAM；FRDM-MCXW71是一款紧凑且可扩展的开发板，可让您快速基于MCX W71无线MCU开展原型设计。它可以轻松地评估MCX W71对BLE、Zigbee、Thread和Matter的多协议无线支持。该板包括一个板载MCU-Link调试器、便于访问MCU I&#x2F;O的行业标准头、一个加速度传感器、一个光传感器和一个外接SPI闪存。 开发环境 安装VSCode，我这里安装的版本是1.96.4 打开VSCode Extensions，安装MCUPRESSO插件 安装Cortex-Debug插件 安装CMake插件 另外PC也要安装CMake 下载一个Ninja arm-gcc-toolchain，我这里安装的是10.2021.10版本 NXP SDK Repository导入，这个要从GitHub上面拉取，拉取时间比较长 安装LinkServer工具 我安装的是1.6.133版本，VSCode自动能够识别 下载sdk包：SDK_2_16_100_FRDM-MCXW71.zip，在MCUXPRESSO VSCode面板导入 搭建demo工程 编译hello_world工程失败 1d:/software/arm-gc~1/102021~1.10/bin/../lib/gcc/arm-none-eabi/10.3.1/../../../../arm-none-eabi/bin/ld.exe: cannot find -lcr_newlib_nohost 需要把armgcc\\debug\\build.ninja文件的部分代码注释掉 1-lcr_newlib_nohost 然后按F5进入调试模式，这样就可以进行开发板的开发工作了 RT-Thread工程Dist包请用RT-Thread Env工具导出支持cmake的dist包 1scons --dist dist工程示例：所有RT-Thread源码被打包至rt-thread目录，并且被CMakeList.txt索引 VSCode配置以下配置文件用于激活VSCode MCUPRESSO工程 .vscode\\c_cpp_properties.json 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#123; &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;rt-thread&quot;, &quot;defines&quot;: [ &quot;CPU_MCXW716CMFPA&quot;, &quot;DEBUG&quot;, &quot;RT_USING_LIBC&quot;, &quot;RT_USING_NEWLIBC&quot;, &quot;_POSIX_C_SOURCE=1&quot;, &quot;_REENT_SMALL&quot;, &quot;__RTTHREAD__&quot; ], &quot;intelliSenseMode&quot;: &quot;gcc-arm&quot;, &quot;compilerPath&quot;: &quot;C:/env-windows/tools/gnu_gcc/arm_gcc/mingw/bin/arm-none-eabi-gcc&quot;, &quot;cStandard&quot;: &quot;c99&quot;, &quot;cppStandard&quot;: &quot;c++11&quot;, &quot;compileCommands&quot;: [ &quot;build/compile_commands.json&quot; ], &quot;includePath&quot;: [ &quot;applications&quot;, &quot;rt-thread\\\\components\\\\libc\\\\compilers\\\\common\\\\include&quot;, &quot;rt-thread\\\\components\\\\libc\\\\compilers\\ ewlib&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\include&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\phy&quot;, &quot;board&quot;, &quot;board\\\\MCUX_Config\\\\board&quot;, &quot;Libraries\\\\drivers&quot;, &quot;Libraries\\\\drivers\\\\config&quot;, &quot;rt-thread\\\\components\\\\finsh&quot;, &quot;.&quot;, &quot;rt-thread\\\\include&quot;, &quot;rt-thread\\\\libcpu\\\\arm\\\\common&quot;, &quot;rt-thread\\\\libcpu\\\\arm\\\\cortex-m33&quot;, &quot;Libraries\\\\CMSIS\\\\Core\\\\Include&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\drivers&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\drivers\\\\romapi\\\\flash&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\drivers\\\\romapi\\\\mem_interface&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\drivers\\\\romapi\\ boot&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\drivers\\\\romapi\\\\runbootloader&quot;, &quot;rt-thread\\\\components\\\\libc\\\\posix\\\\io\\\\epoll&quot;, &quot;rt-thread\\\\components\\\\libc\\\\posix\\\\io\\\\eventfd&quot;, &quot;rt-thread\\\\components\\\\libc\\\\posix\\\\io\\\\poll&quot;, &quot;rt-thread\\\\components\\\\libc\\\\posix\\\\ipc&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\smp_call&quot;, &quot;rt-thread\\\\components\\\\utilities\\\\ulog&quot; ] &#125; ], &quot;version&quot;: 4&#125; .vscode\\launch.json 1234567891011121314151617181920212223242526&#123; &quot;configurations&quot;: [ &#123; &quot;type&quot;: &quot;mcuxpresso-debug&quot;, &quot;name&quot;: &quot;Debug project configuration&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;, &quot;executable&quot;: &quot;&quot;, &quot;stopAtSymbol&quot;: &quot;main&quot;, &quot;probeSerialNumber&quot;: &quot;2NL4XDTOIMBQA&quot;, &quot;isAttach&quot;: false, &quot;probeType&quot;: &quot;&quot;, &quot;skipBuildBeforeDebug&quot;: false, &quot;skipPreFlashActions&quot;: false, &quot;gdbInitCommands&quot;: [ &quot;set remotetimeout 600&quot;, &quot;set debug-file-directory&quot;, &quot;set non-stop off&quot; ], &quot;showDevDebugOutput&quot;: &quot;none&quot; &#125; ]&#125; .vscode\\mcuxpresso-tools.json 12345678910111213141516&#123; &quot;version&quot;: &quot;24.9&quot;, &quot;toolchainPath&quot;: &quot;d:/software/arm-gcc-toolchain/10 2021.10&quot;, &quot;linkedProjects&quot;: [], &quot;trustZoneType&quot;: &quot;none&quot;, &quot;multicoreType&quot;: &quot;none&quot;, &quot;debug&quot;: &#123; &quot;linkserver&quot;: &#123; &quot;device&quot;: &quot;MCXW716CxxxA:FRDM-MCXW71&quot;, &quot;core&quot;: &quot;primary&quot; &#125;, &quot;pemicro&quot;: &#123;&#125;, &quot;segger&quot;: &#123;&#125; &#125;, &quot;projectType&quot;: &quot;cmake-freestanding&quot;&#125; .vscode\\project.json 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146&#123; &quot;RT-Thread&quot;: &quot;D:\\\\project\\\\rt-thread&quot;, &quot;Groups&quot;: [ &#123; &quot;name&quot;: &quot;Applications&quot;, &quot;path&quot;: &quot;applications&quot;, &quot;files&quot;: [ &quot;applications\\\\main.c&quot;, &quot;applications\\\\SConscript&quot; ] &#125;, &#123; &quot;name&quot;: &quot;Compiler&quot;, &quot;path&quot;: &quot;rt-thread\\\\components\\\\libc\\\\compilers\\\\common&quot;, &quot;files&quot;: [ &quot;rt-thread\\\\components\\\\libc\\\\compilers\\\\common\\\\cctype.c&quot;, &quot;rt-thread\\\\components\\\\libc\\\\compilers\\\\common\\\\cstdlib.c&quot;, &quot;rt-thread\\\\components\\\\libc\\\\compilers\\\\common\\\\cstring.c&quot;, &quot;rt-thread\\\\components\\\\libc\\\\compilers\\\\common\\\\ctime.c&quot;, &quot;rt-thread\\\\components\\\\libc\\\\compilers\\\\common\\\\cunistd.c&quot;, &quot;rt-thread\\\\components\\\\libc\\\\compilers\\\\common\\\\cwchar.c&quot;, &quot;rt-thread\\\\components\\\\libc\\\\compilers\\ ewlib\\\\syscalls.c&quot;, &quot;rt-thread\\\\components\\\\libc\\\\compilers\\\\common\\\\SConscript&quot; ] &#125;, &#123; &quot;name&quot;: &quot;DeviceDrivers&quot;, &quot;path&quot;: &quot;rt-thread\\\\components\\\\drivers\\\\core&quot;, &quot;files&quot;: [ &quot;rt-thread\\\\components\\\\drivers\\\\core\\\\device.c&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\hwtimer\\\\hwtimer.c&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\ipc\\\\completion_comm.c&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\ipc\\\\completion_up.c&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\ipc\\\\condvar.c&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\ipc\\\\dataqueue.c&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\ipc\\\\pipe.c&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\ipc\\\\ringblk_buf.c&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\ipc\\\\ringbuffer.c&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\ipc\\\\waitqueue.c&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\ipc\\\\workqueue.c&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\pin\\\\dev_pin.c&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\serial\\\\dev_serial.c&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\core\\\\SConscript&quot; ] &#125;, &#123; &quot;name&quot;: &quot;Drivers&quot;, &quot;path&quot;: &quot;board&quot;, &quot;files&quot;: [ &quot;board\\\\MCUX_Config\\\\board\\\\clock_config.c&quot;, &quot;board\\\\MCUX_Config\\\\board\\\\pin_mux.c&quot;, &quot;board\\\\board.c&quot;, &quot;Libraries\\\\drivers\\\\drv_pin.c&quot;, &quot;Libraries\\\\drivers\\\\drv_uart.c&quot;, &quot;board\\\\SConscript&quot; ] &#125;, &#123; &quot;name&quot;: &quot;Finsh&quot;, &quot;path&quot;: &quot;rt-thread\\\\components\\\\finsh&quot;, &quot;files&quot;: [ &quot;rt-thread\\\\components\\\\finsh\\\\msh_parse.c&quot;, &quot;rt-thread\\\\components\\\\finsh\\\\shell.c&quot;, &quot;rt-thread\\\\components\\\\finsh\\\\msh.c&quot;, &quot;rt-thread\\\\components\\\\finsh\\\\cmd.c&quot;, &quot;rt-thread\\\\components\\\\finsh\\\\SConscript&quot; ] &#125;, &#123; &quot;name&quot;: &quot;Kernel&quot;, &quot;path&quot;: &quot;.&quot;, &quot;files&quot;: [ &quot;rt-thread\\\\src\\\\clock.c&quot;, &quot;rt-thread\\\\src\\\\components.c&quot;, &quot;rt-thread\\\\src\\\\cpu_up.c&quot;, &quot;rt-thread\\\\src\\\\defunct.c&quot;, &quot;rt-thread\\\\src\\\\idle.c&quot;, &quot;rt-thread\\\\src\\\\ipc.c&quot;, &quot;rt-thread\\\\src\\\\irq.c&quot;, &quot;rt-thread\\\\src\\\\kservice.c&quot;, &quot;rt-thread\\\\src\\\\mem.c&quot;, &quot;rt-thread\\\\src\\\\mempool.c&quot;, &quot;rt-thread\\\\src\\\\object.c&quot;, &quot;rt-thread\\\\src\\\\scheduler_comm.c&quot;, &quot;rt-thread\\\\src\\\\scheduler_up.c&quot;, &quot;rt-thread\\\\src\\\\thread.c&quot;, &quot;rt-thread\\\\src\\\\timer.c&quot;, &quot;.\\\\SConscript&quot; ] &#125;, &#123; &quot;name&quot;: &quot;klibc&quot;, &quot;path&quot;: &quot;rt-thread\\\\src\\\\klibc&quot;, &quot;files&quot;: [ &quot;rt-thread\\\\src\\\\klibc\\\\rt_vsnprintf_tiny.c&quot;, &quot;rt-thread\\\\src\\\\klibc\\\\kerrno.c&quot;, &quot;rt-thread\\\\src\\\\klibc\\\\rt_vsscanf.c&quot;, &quot;rt-thread\\\\src\\\\klibc\\\\kstring.c&quot;, &quot;rt-thread\\\\src\\\\klibc\\\\kstdio.c&quot;, &quot;rt-thread\\\\src\\\\klibc\\\\SConscript&quot; ] &#125;, &#123; &quot;name&quot;: &quot;libcpu&quot;, &quot;path&quot;: &quot;rt-thread\\\\libcpu\\\\arm\\\\common&quot;, &quot;files&quot;: [ &quot;rt-thread\\\\libcpu\\\\arm\\\\common\\\\atomic_arm.c&quot;, &quot;rt-thread\\\\libcpu\\\\arm\\\\common\\\\div0.c&quot;, &quot;rt-thread\\\\libcpu\\\\arm\\\\common\\\\showmem.c&quot;, &quot;rt-thread\\\\libcpu\\\\arm\\\\cortex-m33\\\\context_gcc.S&quot;, &quot;rt-thread\\\\libcpu\\\\arm\\\\cortex-m33\\\\cpuport.c&quot;, &quot;rt-thread\\\\libcpu\\\\arm\\\\cortex-m33\\\\syscall_gcc.S&quot;, &quot;rt-thread\\\\libcpu\\\\arm\\\\cortex-m33\\\\trustzone.c&quot;, &quot;rt-thread\\\\libcpu\\\\arm\\\\common\\\\SConscript&quot; ] &#125;, &#123; &quot;name&quot;: &quot;Libraries&quot;, &quot;path&quot;: &quot;Libraries\\\\MCXW71&quot;, &quot;files&quot;: [ &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\drivers\\\\fsl_edma.c&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\drivers\\\\fsl_cmc.c&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\system_MCXW716C.c&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\drivers\\\\fsl_common_arm.c&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\drivers\\\\fsl_crc.c&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\drivers\\\\fsl_spc.c&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\drivers\\\\fsl_clock.c&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\drivers\\\\fsl_ccm32k.c&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\gcc\\\\startup_MCXW716C.S&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\drivers\\\\fsl_lpuart.c&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\drivers\\\\fsl_gpio.c&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\drivers\\\\fsl_common.c&quot;, &quot;Libraries\\\\MCXW71\\\\SConscript&quot; ] &#125;, &#123; &quot;name&quot;: &quot;Utilities&quot;, &quot;path&quot;: &quot;rt-thread\\\\components\\\\utilities\\\\ulog&quot;, &quot;files&quot;: [ &quot;rt-thread\\\\components\\\\utilities\\\\ulog\\\\backend\\\\console_be.c&quot;, &quot;rt-thread\\\\components\\\\utilities\\\\ulog\\\\ulog.c&quot;, &quot;rt-thread\\\\components\\\\utilities\\\\ulog\\\\SConscript&quot; ] &#125; ]&#125; .vscode\\settings.json 12345678&#123; &quot;cmake.configureOnOpen&quot;: false, &quot;C_Cpp.errorSquiggles&quot;: &quot;disabled&quot;, &quot;C_Cpp.default.configurationProvider&quot;: &quot;ms-vscode.cmake-tools&quot;, &quot;cmake.useCMakePresets&quot;: &quot;always&quot;, &quot;cmake.buildTask&quot;: true, &quot;cmake.sourceDirectory&quot;: &quot;$&#123;workspaceFolder&#125;&quot;&#125; .vscode\\tasks.json 123456789101112131415161718192021222324252627282930313233343536373839404142&#123; &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ &#123; &quot;type&quot;: &quot;cmake&quot;, &quot;label&quot;: &quot;CMake: build&quot;, &quot;command&quot;: &quot;build&quot;, &quot;preset&quot;: &quot;debug&quot;, &quot;targets&quot;: [ &quot;all&quot; ], &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true &#125;, &quot;problemMatcher&quot;: [ &quot;$gcc&quot; ], &quot;detail&quot;: &quot;CMake template build task&quot; &#125;, &#123; &quot;type&quot;: &quot;cmake&quot;, &quot;label&quot;: &quot;CMake: clean&quot;, &quot;command&quot;: &quot;clean&quot;, &quot;preset&quot;: &quot;debug&quot;, &quot;problemMatcher&quot;: [ &quot;$gcc&quot; ], &quot;detail&quot;: &quot;CMake template clean task&quot; &#125;, &#123; &quot;type&quot;: &quot;cmake&quot;, &quot;label&quot;: &quot;CMake: configure&quot;, &quot;command&quot;: &quot;configure&quot;, &quot;preset&quot;: &quot;debug&quot;, &quot;problemMatcher&quot;: [ &quot;$gcc&quot; ], &quot;detail&quot;: &quot;CMake template configure task&quot; &#125; ]&#125; CMakePresets.json 123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123; &quot;version&quot;: 7, &quot;cmakeMinimumRequired&quot;: &#123; &quot;major&quot;: 3 &#125;, &quot;configurePresets&quot;: [ &#123; &quot;name&quot;: &quot;debug&quot;, &quot;displayName&quot;: &quot;debug&quot;, &quot;generator&quot;: &quot;Ninja&quot;, &quot;toolchainFile&quot;: &quot;D:/repository/core/tools/cmake_toolchain_files/armgcc.cmake&quot;, &quot;cacheVariables&quot;: &#123; &quot;CMAKE_BUILD_TYPE&quot;: &quot;debug&quot;, &quot;GNinja&quot;: &quot;D:/software/ninja.exe&quot; &#125;, &quot;inherits&quot;: &quot;debug-env&quot; &#125;, &#123; &quot;name&quot;: &quot;release&quot;, &quot;displayName&quot;: &quot;release&quot;, &quot;generator&quot;: &quot;Ninja&quot;, &quot;toolchainFile&quot;: &quot;D:/repository/core/tools/cmake_toolchain_files/armgcc.cmake&quot;, &quot;cacheVariables&quot;: &#123; &quot;CMAKE_BUILD_TYPE&quot;: &quot;release&quot;, &quot;GNinja&quot;: &quot;D:/software/ninja.exe&quot; &#125;, &quot;inherits&quot;: &quot;release-env&quot; &#125; ], &quot;buildPresets&quot;: [ &#123; &quot;name&quot;: &quot;debug&quot;, &quot;displayName&quot;: &quot;debug&quot;, &quot;configurePreset&quot;: &quot;debug&quot; &#125;, &#123; &quot;name&quot;: &quot;release&quot;, &quot;displayName&quot;: &quot;release&quot;, &quot;configurePreset&quot;: &quot;release&quot; &#125; ], &quot;include&quot;: [ &quot;mcux_include.json&quot; ]&#125; mcux_include.json 123456789101112131415161718192021222324252627282930313233&#123; &quot;version&quot;: 7, &quot;cmakeMinimumRequired&quot;: &#123; &quot;major&quot;: 3 &#125;, &quot;configurePresets&quot;: [ &#123; &quot;name&quot;: &quot;debug-env&quot;, &quot;displayName&quot;: &quot;debug-env&quot;, &quot;hidden&quot;: true, &quot;environment&quot;: &#123; &quot;ARMGCC_DIR&quot;: &quot;d:/software/arm-gcc-toolchain/10 2021.10&quot;, &quot;SdkRootDirPath&quot;: &quot;&quot;, &quot;POSTPROCESS_UTILITY&quot;: &quot;&quot;, &quot;MCUX_VENV_PATH&quot;: &quot;&quot;, &quot;PATH&quot;: &quot;$env&#123;MCUX_VENV_PATH&#125;;$penv&#123;PATH&#125;&quot; &#125; &#125;, &#123; &quot;name&quot;: &quot;release-env&quot;, &quot;displayName&quot;: &quot;release-env&quot;, &quot;hidden&quot;: true, &quot;environment&quot;: &#123; &quot;ARMGCC_DIR&quot;: &quot;d:/software/arm-gcc-toolchain/10 2021.10&quot;, &quot;SdkRootDirPath&quot;: &quot;&quot;, &quot;POSTPROCESS_UTILITY&quot;: &quot;&quot;, &quot;MCUX_VENV_PATH&quot;: &quot;&quot;, &quot;PATH&quot;: &quot;$env&#123;MCUX_VENV_PATH&#125;;$penv&#123;PATH&#125;&quot; &#125; &#125; ], &quot;buildPresets&quot;: []&#125; 后续文章会介绍怎么移植RT-Thread","tags":["NXP","MCXW71","MCU"],"categories":["嵌入式"]},{"title":"STM32G030移植RT-Thread","path":"//stm32g030-port-rtt.html","content":"移植流程移植前需要安装Keil.STM32G0xx_DFP.1.2.0.pack组件，大致的移植过程： CubeMX配置 RT-Thread组件配置 工程模板配置 参考例程配置：拷贝仓库原有的stm32g070-st-nucleo工程，然后另起一个名字，目录结构如下 完整的RT-Thread BSP需要考虑的改动点： 文档：把两个README文档改一下，改成stm32g030相关的说明 芯片：board目录下是跟stm32g030相关的CubeMX配置、链接脚本、板级初始化文件 MDK5：template工程是命令scons --target=mdk5生成工程的模板 系统：.config文件保存RT-Thread系统的基本组件配置，rtconfig.h与之关联 CubeMX配置时钟配置在Caegories栏点击System Core一栏，然后选择RCC，实际上HSE和LSE也可以不用配置，因为stm32已经集成了晶振，在GPIO资源紧张时可以不配置 这里选择不配置时钟，Clock Configuration配置如下： 系统滴答点击SYS项，配置如下图所示 串口配置在Connectivity栏点击USART1项，配置PB6、PB7两个GPIO，设置波特率等串口参数 工程配置Project Manager配置项参考 Code Generator配置，最后点击右上角GENERATE CODE 组件配置先说结论，一个成功移植了GPIO和USART的系统工程大致是这样的： Kconfig 123456789101112131415161718192021222324252627mainmenu &quot;RT-Thread Configuration&quot;BSP_DIR := .RTT_DIR := ../../..PKGS_DIR := packagesconfig SOC_STM32G030RB bool select SOC_SERIES_STM32G0 select RT_USING_COMPONENTS_INIT select RT_USING_USER_MAIN default yconfig BOARD_STM32G030_TINY_BOARD bool select BOARD_SERIES_STM32_NUCLEO_64 default ysource &quot;$(RTT_DIR)/Kconfig&quot;osource &quot;$PKGS_DIR/Kconfig&quot;rsource &quot;../libraries/Kconfig&quot;if !RT_USING_NANOrsource &quot;board/Kconfig&quot;endif board&#x2F;Kconfig 1234567891011121314151617181920212223242526272829303132333435363738menu &quot;Hardware Drivers Config&quot;menu &quot;Onboard Peripheral Drivers&quot;endmenumenu &quot;On-chip Peripheral Drivers&quot; config BSP_USING_GPIO bool &quot;Enable GPIO&quot; select RT_USING_PIN default y menuconfig BSP_USING_UART bool &quot;Enable UART1&quot; default y select RT_USING_SERIAL if BSP_USING_UART config BSP_STM32_UART_V1_TX_TIMEOUT int &quot;UART TX timeout&quot; default 2000 depends on RT_USING_SERIAL_V1 config BSP_USING_UART1 bool &quot;Enable UART1&quot; default y endif source &quot;$(BSP_DIR)/../libraries/HAL_Drivers/drivers/Kconfig&quot;endmenumenu &quot;Board extended module Drivers&quot;endmenuendmenu board&#x2F;SConscript 1234567891011121314151617181920212223242526272829import osimport rtconfigfrom building import *Import(&#x27;SDK_LIB&#x27;)cwd = GetCurrentDir()# add general driverssrc = Split(&#x27;&#x27;&#x27;board.cCubeMX_Config/Src/stm32g0xx_hal_msp.c&#x27;&#x27;&#x27;)path = [cwd]path += [cwd + &#x27;/CubeMX_Config/Inc&#x27;]startup_path_prefix = SDK_LIBif rtconfig.PLATFORM in [&#x27;gcc&#x27;]: src += [startup_path_prefix + &#x27;/STM32G0xx_HAL/CMSIS/Device/ST/STM32G0xx/Source/Templates/gcc/startup_stm32g030xx.s&#x27;]elif rtconfig.PLATFORM in [&#x27;armcc&#x27;, &#x27;armclang&#x27;]: src += [startup_path_prefix + &#x27;/STM32G0xx_HAL/CMSIS/Device/ST/STM32G0xx/Source/Templates/arm/startup_stm32g030xx.s&#x27;]elif rtconfig.PLATFORM in [&#x27;iccarm&#x27;]: src += [startup_path_prefix + &#x27;/STM32G0xx_HAL/CMSIS/Device/ST/STM32G0xx/Source/Templates/iar/startup_stm32g030xx.s&#x27;]CPPDEFINES = [&#x27;STM32G030xx&#x27;]group = DefineGroup(&#x27;Drivers&#x27;, src, depend = [&#x27;&#x27;], CPPPATH = path, CPPDEFINES = CPPDEFINES)Return(&#x27;group&#x27;) board&#x2F;board.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* * Copyright (c) 2006-2025 RT-Thread Development Team * * SPDX-License-Identifier: Apache-2.0 * * Change Logs: * Date Author Notes * 2018-11-5 SummerGift first version */#ifndef __BOARD_H__#define __BOARD_H__#include &lt;rtthread.h&gt;#include &lt;stm32g0xx.h&gt;#include &quot;drv_common.h&quot;#include &quot;drv_gpio.h&quot;#ifdef __cplusplusextern &quot;C&quot; &#123;#endif#define STM32_FLASH_START_ADRESS ((uint32_t)0x08000000)#define STM32_FLASH_SIZE (64 * 1024)#define STM32_FLASH_END_ADDRESS ((uint32_t)(STM32_FLASH_START_ADRESS + STM32_FLASH_SIZE))/* Internal SRAM memory size[Kbytes] &lt;8-64&gt;, Default: 64*/#define STM32_SRAM_SIZE 8#define STM32_SRAM_END (0x20000000 + STM32_SRAM_SIZE * 1024)#if defined(__ARMCC_VERSION)extern int Image$$RW_IRAM1$$ZI$$Limit;#define HEAP_BEGIN ((void *)&amp;Image$$RW_IRAM1$$ZI$$Limit)#elif __ICCARM__#pragma section=&quot;CSTACK&quot;#define HEAP_BEGIN (__segment_end(&quot;CSTACK&quot;))#elseextern int __bss_end;#define HEAP_BEGIN ((void *)&amp;__bss_end)#endif#define HEAP_END STM32_SRAM_ENDvoid SystemClock_Config(void);#ifdef __cplusplus&#125;#endif#endif /* __BOARD_H__ */ board&#x2F;board.c 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* * Copyright (c) 2006-2025 RT-Thread Development Team * * SPDX-License-Identifier: Apache-2.0 * * Change Logs: * Date Author Notes * 2018-12-21 zylx first version */#include &quot;board.h&quot;void SystemClock_Config(void)&#123; RCC_OscInitTypeDef RCC_OscInitStruct = &#123;0&#125;; RCC_ClkInitTypeDef RCC_ClkInitStruct = &#123;0&#125;; /** Configure the main internal regulator output voltage */ HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1); /** Initializes the RCC Oscillators according to the specified parameters * in the RCC_OscInitTypeDef structure. */ RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSIDiv = RCC_HSI_DIV1; RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE; if (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK) &#123; Error_Handler(); &#125; /** Initializes the CPU, AHB and APB buses clocks */ RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK |RCC_CLOCKTYPE_PCLK1; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; if (HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK) &#123; Error_Handler(); &#125;&#125; board&#x2F;linker_scipts&#x2F;link.icf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/* * linker script for STM32F10x with GNU ld *//* Program Entry, set to mark it as &quot;used&quot; and avoid gc */MEMORY&#123; ROM (rx) : ORIGIN = 0x08000000, LENGTH = 64k /* 64KB flash */ RAM (rw) : ORIGIN = 0x20000000, LENGTH = 8k /* 8K sram */&#125;ENTRY(Reset_Handler)_system_stack_size = 0x400;SECTIONS&#123; .text : &#123; . = ALIGN(4); _stext = .; KEEP(*(.isr_vector)) /* Startup code */ . = ALIGN(4); *(.text) /* remaining code */ *(.text.*) /* remaining code */ *(.rodata) /* read-only data (constants) */ *(.rodata*) *(.glue_7) *(.glue_7t) *(.gnu.linkonce.t*) /* section information for finsh shell */ . = ALIGN(4); __fsymtab_start = .; KEEP(*(FSymTab)) __fsymtab_end = .; . = ALIGN(4); __vsymtab_start = .; KEEP(*(VSymTab)) __vsymtab_end = .; /* section information for initial. */ . = ALIGN(4); __rt_init_start = .; KEEP(*(SORT(.rti_fn*))) __rt_init_end = .; . = ALIGN(4); PROVIDE(__ctors_start__ = .); KEEP (*(SORT(.init_array.*))) KEEP (*(.init_array)) PROVIDE(__ctors_end__ = .); . = ALIGN(4); _etext = .; &#125; &gt; ROM = 0 /* .ARM.exidx is sorted, so has to go in its own output section. */ __exidx_start = .; .ARM.exidx : &#123; *(.ARM.exidx* .gnu.linkonce.armexidx.*) /* This is used by the startup in order to initialize the .data secion */ _sidata = .; &#125; &gt; ROM __exidx_end = .; /* .data section which is used for initialized data */ .data : AT (_sidata) &#123; . = ALIGN(4); /* This is used by the startup in order to initialize the .data secion */ _sdata = . ; *(.data) *(.data.*) *(.gnu.linkonce.d*) PROVIDE(__dtors_start__ = .); KEEP(*(SORT(.dtors.*))) KEEP(*(.dtors)) PROVIDE(__dtors_end__ = .); . = ALIGN(4); /* This is used by the startup in order to initialize the .data secion */ _edata = . ; &#125; &gt;RAM .stack : &#123; . = ALIGN(4); _sstack = .; . = . + _system_stack_size; . = ALIGN(4); _estack = .; &#125; &gt;RAM __bss_start = .; .bss : &#123; . = ALIGN(4); /* This is used by the startup in order to initialize the .bss secion */ _sbss = .; *(.bss) *(.bss.*) *(COMMON) . = ALIGN(4); /* This is used by the startup in order to initialize the .bss secion */ _ebss = . ; *(.bss.init) &#125; &gt; RAM __bss_end = .; _end = .; /* Stabs debugging sections. */ .stab 0 : &#123; *(.stab) &#125; .stabstr 0 : &#123; *(.stabstr) &#125; .stab.excl 0 : &#123; *(.stab.excl) &#125; .stab.exclstr 0 : &#123; *(.stab.exclstr) &#125; .stab.index 0 : &#123; *(.stab.index) &#125; .stab.indexstr 0 : &#123; *(.stab.indexstr) &#125; .comment 0 : &#123; *(.comment) &#125; /* DWARF debug sections. * Symbols in the DWARF debugging sections are relative to the beginning * of the section so we begin them at 0. */ /* DWARF 1 */ .debug 0 : &#123; *(.debug) &#125; .line 0 : &#123; *(.line) &#125; /* GNU DWARF 1 extensions */ .debug_srcinfo 0 : &#123; *(.debug_srcinfo) &#125; .debug_sfnames 0 : &#123; *(.debug_sfnames) &#125; /* DWARF 1.1 and DWARF 2 */ .debug_aranges 0 : &#123; *(.debug_aranges) &#125; .debug_pubnames 0 : &#123; *(.debug_pubnames) &#125; /* DWARF 2 */ .debug_info 0 : &#123; *(.debug_info .gnu.linkonce.wi.*) &#125; .debug_abbrev 0 : &#123; *(.debug_abbrev) &#125; .debug_line 0 : &#123; *(.debug_line) &#125; .debug_frame 0 : &#123; *(.debug_frame) &#125; .debug_str 0 : &#123; *(.debug_str) &#125; .debug_loc 0 : &#123; *(.debug_loc) &#125; .debug_macinfo 0 : &#123; *(.debug_macinfo) &#125; /* SGI/MIPS DWARF 2 extensions */ .debug_weaknames 0 : &#123; *(.debug_weaknames) &#125; .debug_funcnames 0 : &#123; *(.debug_funcnames) &#125; .debug_typenames 0 : &#123; *(.debug_typenames) &#125; .debug_varnames 0 : &#123; *(.debug_varnames) &#125;&#125; board&#x2F;linker_scipts&#x2F;link.sct，这个是MDK的链接脚本文件，需要加上rti_fn保证RT-Thread组件的初始化 1234567891011121314; *************************************************************; *** Scatter-Loading Description File generated by uVision ***; *************************************************************LR_IROM1 0x08000000 0x00010000 &#123; ; load region size_region ER_IROM1 0x08000000 0x00010000 &#123; ; load address = execution address *.o (RESET, +First) *(InRoot$$Sections) .ANY (+RO) &#125; RW_IRAM1 0x20000000 0x00002000 &#123; ; RW data .ANY (+RW +ZI) &#125;&#125; board&#x2F;linker_scripts&#x2F;link.lds，这个是arm gcc的链接脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/* * linker script for STM32F10x with GNU ld *//* Program Entry, set to mark it as &quot;used&quot; and avoid gc */MEMORY&#123; ROM (rx) : ORIGIN = 0x08000000, LENGTH = 64k /* 128KB flash */ RAM (rw) : ORIGIN = 0x20000000, LENGTH = 8k /* 8K sram */&#125;ENTRY(Reset_Handler)_system_stack_size = 0x400;SECTIONS&#123; .text : &#123; . = ALIGN(4); _stext = .; KEEP(*(.isr_vector)) /* Startup code */ . = ALIGN(4); *(.text) /* remaining code */ *(.text.*) /* remaining code */ *(.rodata) /* read-only data (constants) */ *(.rodata*) *(.glue_7) *(.glue_7t) *(.gnu.linkonce.t*) /* section information for finsh shell */ . = ALIGN(4); __fsymtab_start = .; KEEP(*(FSymTab)) __fsymtab_end = .; . = ALIGN(4); __vsymtab_start = .; KEEP(*(VSymTab)) __vsymtab_end = .; /* section information for initial. */ . = ALIGN(4); __rt_init_start = .; KEEP(*(SORT(.rti_fn*))) __rt_init_end = .; . = ALIGN(4); PROVIDE(__ctors_start__ = .); KEEP (*(SORT(.init_array.*))) KEEP (*(.init_array)) PROVIDE(__ctors_end__ = .); . = ALIGN(4); _etext = .; &#125; &gt; ROM = 0 /* .ARM.exidx is sorted, so has to go in its own output section. */ __exidx_start = .; .ARM.exidx : &#123; *(.ARM.exidx* .gnu.linkonce.armexidx.*) /* This is used by the startup in order to initialize the .data secion */ _sidata = .; &#125; &gt; ROM __exidx_end = .; /* .data section which is used for initialized data */ .data : AT (_sidata) &#123; . = ALIGN(4); /* This is used by the startup in order to initialize the .data secion */ _sdata = . ; *(.data) *(.data.*) *(.gnu.linkonce.d*) PROVIDE(__dtors_start__ = .); KEEP(*(SORT(.dtors.*))) KEEP(*(.dtors)) PROVIDE(__dtors_end__ = .); . = ALIGN(4); /* This is used by the startup in order to initialize the .data secion */ _edata = . ; &#125; &gt;RAM .stack : &#123; . = ALIGN(4); _sstack = .; . = . + _system_stack_size; . = ALIGN(4); _estack = .; &#125; &gt;RAM __bss_start = .; .bss : &#123; . = ALIGN(4); /* This is used by the startup in order to initialize the .bss secion */ _sbss = .; *(.bss) *(.bss.*) *(COMMON) . = ALIGN(4); /* This is used by the startup in order to initialize the .bss secion */ _ebss = . ; *(.bss.init) &#125; &gt; RAM __bss_end = .; _end = .; /* Stabs debugging sections. */ .stab 0 : &#123; *(.stab) &#125; .stabstr 0 : &#123; *(.stabstr) &#125; .stab.excl 0 : &#123; *(.stab.excl) &#125; .stab.exclstr 0 : &#123; *(.stab.exclstr) &#125; .stab.index 0 : &#123; *(.stab.index) &#125; .stab.indexstr 0 : &#123; *(.stab.indexstr) &#125; .comment 0 : &#123; *(.comment) &#125; /* DWARF debug sections. * Symbols in the DWARF debugging sections are relative to the beginning * of the section so we begin them at 0. */ /* DWARF 1 */ .debug 0 : &#123; *(.debug) &#125; .line 0 : &#123; *(.line) &#125; /* GNU DWARF 1 extensions */ .debug_srcinfo 0 : &#123; *(.debug_srcinfo) &#125; .debug_sfnames 0 : &#123; *(.debug_sfnames) &#125; /* DWARF 1.1 and DWARF 2 */ .debug_aranges 0 : &#123; *(.debug_aranges) &#125; .debug_pubnames 0 : &#123; *(.debug_pubnames) &#125; /* DWARF 2 */ .debug_info 0 : &#123; *(.debug_info .gnu.linkonce.wi.*) &#125; .debug_abbrev 0 : &#123; *(.debug_abbrev) &#125; .debug_line 0 : &#123; *(.debug_line) &#125; .debug_frame 0 : &#123; *(.debug_frame) &#125; .debug_str 0 : &#123; *(.debug_str) &#125; .debug_loc 0 : &#123; *(.debug_loc) &#125; .debug_macinfo 0 : &#123; *(.debug_macinfo) &#125; /* SGI/MIPS DWARF 2 extensions */ .debug_weaknames 0 : &#123; *(.debug_weaknames) &#125; .debug_funcnames 0 : &#123; *(.debug_funcnames) &#125; .debug_typenames 0 : &#123; *(.debug_typenames) &#125; .debug_varnames 0 : &#123; *(.debug_varnames) &#125;&#125; main.c，最小例程里边带了LED闪烁功能 123456789101112131415161718192021222324252627282930313233343536/* * Copyright (c) 2006-2025 RT-Thread Development Team * * SPDX-License-Identifier: Apache-2.0 * * Change Logs: * Date Author Notes * 2025-3-17 hywing first version */#include &lt;board.h&gt;#include &lt;rtthread.h&gt;#ifndef RT_USING_NANO#include &lt;rtdevice.h&gt;#endif /* RT_USING_NANO *//* defined the LED0 pin: PB4 */#define LED0_PIN GET_PIN(B, 4)int main(void)&#123; /* set LED0 pin mode to output */ rt_pin_mode(LED0_PIN, PIN_MODE_OUTPUT); rt_kprintf(&quot;Welcome to the world of IoT Stuff!\\r &quot;); while (1) &#123; rt_pin_write(LED0_PIN, PIN_HIGH); rt_thread_mdelay(500); rt_pin_write(LED0_PIN, PIN_LOW); rt_thread_mdelay(500); &#125; return RT_EOK;&#125; 工程模板我们先把Template工程配置好，然后后面就可以通过scons自动生成想要的工程配置，打开Template工程模板选择STM32G030C8TX 时钟配置为16MHz，检查IROM1和IRAM1的起始地址以及大小是否正确 下载器配置为ST-Link Debugger ST-Link Debug配置，Clock Req设为10MHz Flash Download配置 Include Paths调整：拷贝过来的例程有些是不对的，需要修正过来 导出MDK Keil5工程 1scons --target=mdk5 导出的rtconfig.h文件配置如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391#ifndef RT_CONFIG_H__#define RT_CONFIG_H__#define SOC_STM32G030RB#define BOARD_STM32G030_TINY_BOARD/* RT-Thread Kernel *//* klibc options *//* rt_vsnprintf options */#define RT_KLIBC_USING_LIBC_VSNPRINTF/* end of rt_vsnprintf options *//* rt_vsscanf options */#define RT_KLIBC_USING_LIBC_VSSCANF/* end of rt_vsscanf options *//* rt_memset options *//* end of rt_memset options *//* rt_memcpy options *//* end of rt_memcpy options *//* rt_memmove options *//* end of rt_memmove options *//* rt_memcmp options *//* end of rt_memcmp options *//* rt_strstr options *//* end of rt_strstr options *//* rt_strcasecmp options *//* end of rt_strcasecmp options *//* rt_strncpy options *//* end of rt_strncpy options *//* rt_strcpy options *//* end of rt_strcpy options *//* rt_strncmp options *//* end of rt_strncmp options *//* rt_strcmp options *//* end of rt_strcmp options *//* rt_strlen options *//* end of rt_strlen options *//* rt_strnlen options *//* end of rt_strnlen options *//* end of klibc options */#define RT_NAME_MAX 8#define RT_CPUS_NR 1#define RT_ALIGN_SIZE 8#define RT_THREAD_PRIORITY_32#define RT_THREAD_PRIORITY_MAX 32#define RT_TICK_PER_SECOND 1000#define RT_USING_OVERFLOW_CHECK#define RT_USING_HOOK#define RT_HOOK_USING_FUNC_PTR#define RT_USING_IDLE_HOOK#define RT_IDLE_HOOK_LIST_SIZE 4#define IDLE_THREAD_STACK_SIZE 256/* kservice options *//* end of kservice options */#define RT_USING_DEBUG#define RT_DEBUGING_ASSERT#define RT_DEBUGING_COLOR#define RT_DEBUGING_CONTEXT/* Inter-Thread communication */#define RT_USING_SEMAPHORE#define RT_USING_MUTEX#define RT_USING_EVENT#define RT_USING_MAILBOX#define RT_USING_MESSAGEQUEUE/* end of Inter-Thread communication *//* Memory Management */#define RT_USING_MEMPOOL#define RT_USING_SMALL_MEM#define RT_USING_SMALL_MEM_AS_HEAP#define RT_USING_HEAP/* end of Memory Management */#define RT_USING_DEVICE#define RT_USING_CONSOLE#define RT_CONSOLEBUF_SIZE 128#define RT_CONSOLE_DEVICE_NAME &quot;uart1&quot;#define RT_VER_NUM 0x50200#define RT_BACKTRACE_LEVEL_MAX_NR 32/* end of RT-Thread Kernel */#define ARCH_ARM#define ARCH_ARM_CORTEX_M#define ARCH_ARM_CORTEX_M0/* RT-Thread Components */#define RT_USING_COMPONENTS_INIT#define RT_USING_USER_MAIN#define RT_MAIN_THREAD_STACK_SIZE 1024#define RT_MAIN_THREAD_PRIORITY 10#define RT_USING_MSH#define RT_USING_FINSH#define FINSH_USING_MSH#define FINSH_THREAD_NAME &quot;tshell&quot;#define FINSH_THREAD_PRIORITY 20#define FINSH_THREAD_STACK_SIZE 768#define FINSH_USING_HISTORY#define FINSH_HISTORY_LINES 5#define FINSH_USING_SYMTAB#define FINSH_CMD_SIZE 80#define MSH_USING_BUILT_IN_COMMANDS#define FINSH_USING_DESCRIPTION#define FINSH_ARG_MAX 10#define FINSH_USING_OPTION_COMPLETION/* DFS: device virtual file system *//* end of DFS: device virtual file system *//* Device Drivers */#define RT_USING_DEVICE_IPC#define RT_UNAMED_PIPE_NUMBER 64#define RT_USING_SERIAL#define RT_USING_SERIAL_V1#define RT_SERIAL_USING_DMA#define RT_SERIAL_RB_BUFSZ 64#define RT_USING_PIN/* end of Device Drivers *//* C/C++ and POSIX layer *//* ISO-ANSI C layer *//* Timezone and Daylight Saving Time */#define RT_LIBC_USING_LIGHT_TZ_DST#define RT_LIBC_TZ_DEFAULT_HOUR 8#define RT_LIBC_TZ_DEFAULT_MIN 0#define RT_LIBC_TZ_DEFAULT_SEC 0/* end of Timezone and Daylight Saving Time *//* end of ISO-ANSI C layer *//* POSIX (Portable Operating System Interface) layer *//* Interprocess Communication (IPC) *//* Socket is in the &#x27;Network&#x27; category *//* end of Interprocess Communication (IPC) *//* end of POSIX (Portable Operating System Interface) layer *//* end of C/C++ and POSIX layer *//* Network *//* end of Network *//* Memory protection *//* end of Memory protection *//* Utilities *//* end of Utilities *//* Using USB legacy version *//* end of Using USB legacy version *//* end of RT-Thread Components *//* RT-Thread Utestcases *//* end of RT-Thread Utestcases *//* RT-Thread online packages *//* IoT - internet of things *//* Wi-Fi *//* Marvell WiFi *//* end of Marvell WiFi *//* Wiced WiFi *//* end of Wiced WiFi *//* CYW43012 WiFi *//* end of CYW43012 WiFi *//* BL808 WiFi *//* end of BL808 WiFi *//* CYW43439 WiFi *//* end of CYW43439 WiFi *//* end of Wi-Fi *//* IoT Cloud *//* end of IoT Cloud *//* end of IoT - internet of things *//* security packages *//* end of security packages *//* language packages *//* JSON: JavaScript Object Notation, a lightweight data-interchange format *//* end of JSON: JavaScript Object Notation, a lightweight data-interchange format *//* XML: Extensible Markup Language *//* end of XML: Extensible Markup Language *//* end of language packages *//* multimedia packages *//* LVGL: powerful and easy-to-use embedded GUI library *//* end of LVGL: powerful and easy-to-use embedded GUI library *//* u8g2: a monochrome graphic library *//* end of u8g2: a monochrome graphic library *//* end of multimedia packages *//* tools packages *//* end of tools packages *//* system packages *//* enhanced kernel services *//* end of enhanced kernel services *//* acceleration: Assembly language or algorithmic acceleration packages *//* end of acceleration: Assembly language or algorithmic acceleration packages *//* CMSIS: ARM Cortex-M Microcontroller Software Interface Standard *//* end of CMSIS: ARM Cortex-M Microcontroller Software Interface Standard *//* Micrium: Micrium software products porting for RT-Thread *//* end of Micrium: Micrium software products porting for RT-Thread *//* end of system packages *//* peripheral libraries and drivers *//* HAL &amp; SDK Drivers *//* STM32 HAL &amp; SDK Drivers *//* end of STM32 HAL &amp; SDK Drivers *//* Infineon HAL Packages *//* end of Infineon HAL Packages *//* Kendryte SDK *//* end of Kendryte SDK *//* end of HAL &amp; SDK Drivers *//* sensors drivers *//* end of sensors drivers *//* touch drivers *//* end of touch drivers *//* end of peripheral libraries and drivers *//* AI packages *//* end of AI packages *//* Signal Processing and Control Algorithm Packages *//* end of Signal Processing and Control Algorithm Packages *//* miscellaneous packages *//* project laboratory *//* end of project laboratory *//* samples: kernel and components samples *//* end of samples: kernel and components samples *//* entertainment: terminal games and other interesting software packages *//* end of entertainment: terminal games and other interesting software packages *//* end of miscellaneous packages *//* Arduino libraries *//* Projects and Demos *//* end of Projects and Demos *//* Sensors *//* end of Sensors *//* Display *//* end of Display *//* Timing *//* end of Timing *//* Data Processing *//* end of Data Processing *//* Data Storage *//* Communication *//* end of Communication *//* Device Control *//* end of Device Control *//* Other *//* end of Other *//* Signal IO *//* end of Signal IO *//* Uncategorized *//* end of Arduino libraries *//* end of RT-Thread online packages */#define SOC_FAMILY_STM32#define SOC_SERIES_STM32G0#define BOARD_SERIES_STM32_NUCLEO_64/* Hardware Drivers Config *//* Onboard Peripheral Drivers *//* On-chip Peripheral Drivers */#define BSP_USING_GPIO#define BSP_USING_UART#define BSP_STM32_UART_V1_TX_TIMEOUT 2000#define BSP_USING_UART1/* end of On-chip Peripheral Drivers *//* Board extended module Drivers *//* end of Hardware Drivers Config */#endif 遇到的问题 断点失效：尽量不用Browse Information就OK 没有msh提示符输出：把msh线程的栈空间大小FINSH_THREAD_STACK_SIZE调小一点就OK，512也是可以的但ps命令会卡死 1#define FINSH_THREAD_STACK_SIZE 768 资源紧张，SRAM比较有限，任务的堆栈尽量小一些 开源移植的工程已经push到RT-Thread GitHub仓库：rt-thread&#x2F;bsp&#x2F;stm32&#x2F;stm32g030-tiny-board at master · RT-Thread&#x2F;rt-thread","tags":["stm32","RT-Thread"],"categories":["嵌入式"]},{"title":"如何撤销缓冲区的提交","path":"//git-reset-command.html","content":"介绍一次误操作发现commit的时候漏提交一些文件，但是还没有push到远端仓库，缓冲区可以看到提交记录 解决git-bash用reset命令将commit撤销掉（最近一次提交记录会没有），然后修改的文件保存到当前工作区，用户可以再次提交 1git reset --soft HEAD^ tortoiseGit在仓库所在文件夹右键菜单打开Show log列表，然后选中某条提交记录右键再弹出菜单，点击Reset xxx to this ...就可以回退了","tags":["git"],"categories":["开发工具"]},{"title":"倍福官方ADS组件使用","path":"//beckhoff-ads-usage.html","content":"介绍倍福官方把ADS通信组件做成了跨平台（Windows、Linux、BSD），而且还开源，这下在Unix开发工控机上位机软件就问题不大了，这是官方的编译器配置要求： Currently (2024-12-13) tested with: host os host target compiler Alpine 3.21 amd64 amd64 gcc 14.2.0 Arch Linux amd64 amd64 clang 18.1.8 Arch Linux amd64 amd64 gcc 14.2.1 Debian 12 amd64 amd64 clang 14.0.6 Debian 12 amd64 amd64 gcc 12.2.0-14 Debian 12 amd64 i686 gcc 12.2.0-14 Debian 12 amd64 mips gcc 12.2.0-14 Debian 12 amd64 win32 gcc 10.2.1-6 Debian 12 amd64 riscv64 gcc 12.2.0-13 Debian 12 arm64 arm64 gcc 12.2.0-14 TC&#x2F;BSD 14 amd64 amd64 clang 18.1.5 Windows 10 amd64 win64 msvc 19.36.33134 编译开源工程是用cmake构建的，在Windows下可以直接用QtCreator打开 配置编译的类型、构建路径、安装目录 用MSVC2017编译需要在顶层cmake加入一行代码 构建工程的过程中会遇到Link错误，明显这个是个静态库lib 在AdsLib里边改一下库的配置类型，你也可以把前面那个BUILD_SHARED_LIBS的选项去掉 然后点击重新构建就好 测试ADS组件里边自带的example例程也很简单，跟以太网通信那一套类似，都是对指定IP地址和端口发起连接，TC3的端口为851 1234567891011121314151617static void runExample(std::ostream&amp; out)&#123; static const AmsNetId remoteNetId &#123; 192, 168, 0, 231, 1, 1 &#125;; static const char remoteIpV4[] = &quot;ads-server&quot;; // uncomment and adjust if automatic AmsNetId deduction is not working as expected //bhf::ads::SetLocalAddress(&#123;192, 168, 0, 1, 1, 1&#125;); AdsDevice route &#123;remoteIpV4, remoteNetId, AMSPORT_R0_PLC_TC3&#125;; notificationExample(out, route); notificationByNameExample(out, route); readExample(out, route); readByNameExample(out, route); readWriteExample(out, route); readWriteArrayExample(out, route); readStateExample(out, route);&#125; AdsDevice类型，需要配置AdsDevice的地址、端口等信息后读取指定地址或名称的寄存器值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct AdsDevice &#123; AdsDevice(const std::string&amp; ipV4, AmsNetId netId, uint16_t port); DeviceInfo GetDeviceInfo() const; /** Get handle to access AdsVariable by indexGroup/Offset */ AdsHandle GetHandle(uint32_t offset) const; /** Get handle for access by symbol name */ AdsHandle GetHandle(const std::string&amp; symbolName) const; /** Get notification handle */ AdsHandle GetHandle(uint32_t indexGroup, uint32_t indexOffset, const AdsNotificationAttrib&amp; notificationAttributes, PAdsNotificationFuncEx callback, uint32_t hUser) const; /** Get handle to access files */ AdsHandle OpenFile(const std::string&amp; filename, uint32_t flags) const; long GetLocalPort() const; AdsDeviceState GetState() const; void SetState(const ADSSTATE AdsState, const ADSSTATE DeviceState) const; uint32_t GetTimeout() const; void SetTimeout(const uint32_t timeout) const; long ReadReqEx2(uint32_t group, uint32_t offset, size_t length, void* buffer, uint32_t* bytesRead) const; long ReadWriteReqEx2(uint32_t indexGroup, uint32_t indexOffset, size_t readLength, void* readData, size_t writeLength, const void* writeData, uint32_t* bytesRead) const; long WriteReqEx(uint32_t group, uint32_t offset, size_t length, const void* buffer) const; AdsResource&lt;const AmsNetId&gt; m_NetId; const AmsAddr m_Addr;private: AdsResource&lt;const long&gt; m_LocalPort; long CloseFile(uint32_t handle) const; long DeleteNotificationHandle(uint32_t handle) const; long DeleteSymbolHandle(uint32_t handle) const;&#125;; AdsVariable是一个模板类型，封装了各种各样的寄存器类型的数据访问（IndexGroup、group、offset或者symbolName） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566template&lt;typename T&gt;struct AdsVariable &#123; AdsVariable(const AdsDevice&amp; route, const std::string&amp; symbolName) : m_Route(route), m_IndexGroup(ADSIGRP_SYM_VALBYHND), m_Handle(route.GetHandle(symbolName)) &#123;&#125; AdsVariable(const AdsDevice&amp; route, const uint32_t group, const uint32_t offset) : m_Route(route), m_IndexGroup(group), m_Handle(route.GetHandle(offset)) &#123;&#125; operator T() const &#123; T buffer; Read(sizeof(buffer), &amp;buffer); return buffer; &#125; void operator=(const T&amp; value) const &#123; Write(sizeof(T), &amp;value); &#125; template&lt;typename U, size_t N&gt; operator std::array&lt;U, N&gt;() const &#123; std::array&lt;U, N&gt; buffer; Read(sizeof(U) * N, buffer.data()); return buffer; &#125; template&lt;typename U, size_t N&gt; void operator=(const std::array&lt;U, N&gt;&amp; value) const &#123; Write(sizeof(U) * N, value.data()); &#125; void Read(const size_t size, void* data) const &#123; uint32_t bytesRead = 0; auto error = m_Route.ReadReqEx2(m_IndexGroup, *m_Handle, size, data, &amp;bytesRead); if (error || (size != bytesRead)) &#123; throw AdsException(error); &#125; &#125; void Write(const size_t size, const void* data) const &#123; auto error = m_Route.WriteReqEx(m_IndexGroup, *m_Handle, size, data); if (error) &#123; throw AdsException(error); &#125; &#125;private: const AdsDevice&amp; m_Route; const uint32_t m_IndexGroup; const AdsHandle m_Handle;&#125;; 根据group和offset读取寄存器值 123456789static void readExample(std::ostream&amp; out, const AdsDevice&amp; route)&#123; AdsVariable&lt;uint8_t&gt; readVar &#123;route, 0x4020, 0&#125;; out &lt;&lt; __FUNCTION__ &lt;&lt; &quot;(): &quot;; for (size_t i = 0; i &lt; 8; ++i) &#123; out &lt;&lt; &quot;ADS read &quot; &lt;&lt; std::hex &lt;&lt; (uint32_t)readVar &lt;&lt; &#x27; &#x27;; &#125;&#125; 根据name读取寄存器值 123456789static void readByNameExample(std::ostream&amp; out, const AdsDevice&amp; route)&#123; AdsVariable&lt;uint8_t&gt; readVar &#123;route, &quot;MAIN.byByte[4]&quot;&#125;; out &lt;&lt; __FUNCTION__ &lt;&lt; &quot;(): &quot;; for (size_t i = 0; i &lt; 8; ++i) &#123; out &lt;&lt; &quot;ADS read &quot; &lt;&lt; std::hex &lt;&lt; (uint32_t)readVar &lt;&lt; &#x27; &#x27;; &#125;&#125; 读写示例 1234567891011static void readWriteExample(std::ostream&amp; out, const AdsDevice&amp; route)&#123; AdsVariable&lt;uint8_t&gt; simpleVar &#123;route, &quot;MAIN.byByte[0]&quot;&#125;; AdsVariable&lt;uint8_t&gt; validation &#123;route, &quot;MAIN.byByte[0]&quot;&#125;; out &lt;&lt; __FUNCTION__ &lt;&lt; &quot;(): &quot;; simpleVar = 0xA5; out &lt;&lt; &quot;Wrote &quot; &lt;&lt; 0xA5 &lt;&lt; &quot; to MAIN.byByte and read &quot; &lt;&lt; (uint32_t)validation &lt;&lt; &quot; back &quot;; simpleVar = 0x5A; out &lt;&lt; &quot;Wrote &quot; &lt;&lt; (uint32_t)simpleVar &lt;&lt; &quot; to MAIN.byByte and read &quot; &lt;&lt; (uint32_t)validation &lt;&lt; &quot; back &quot;;&#125; 应用构建好之后在install目录下会生成相关的库文件、头文件，方便我们拿到自己的项目使用 在cmake里边包含和链接ads组件 123include_directories($&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/ads)target_link_libraries(demoApp PUBLIC ads)","tags":["ADS","自动化"],"categories":["程序设计"]},{"title":"开发板硬件测试","path":"//board-test.html","content":"前言作为一名电子工程师，你可以不懂嵌入式，但你绝对不能不懂示波器！ 介绍嵌入式工程师拿到开发板第一时间需要检查开发板功能是否正常，示波器用来做硬件测试最好不过了，这里以数字电路为例列举一些常见的测试方法 电源电源失稳有可能导致芯片无法正常工作，电源测试主要是针对USB电源、三端稳压器（线性电源）、GPIO电平、LED电源指示灯等 时钟晶振不起振可能会导致芯片无法工作，不过像stm32这样的芯片都内置晶振，这个可以帮忙判断检查外置晶振或RTC是否起振，但不能作为芯片不能工作的唯一依据 按键主要是复位按键以及用户按键的工作状况（是否能稳定输出脉冲） 外设比如i2c主从设备通信是否正常（如硬件忘了给SDA、SCL上拉电阻），国产示波器通常自带协议解码的功能，推荐用国产示波器来测试 PWM波形也不例外","tags":["开发板","示波器"],"categories":["嵌入式"]},{"title":"上位机数据可视化：使用QtCharts绘制波形图","path":"//qt-charts-design.html","content":"工程配置CMake文件 123find_package(Qt5 COMPONENTS Charts REQUIRED)target_link_libraries(zhd-desktop PRIVATE Qt5::Charts) 包含头文件以及名称空间（这个很重要，没有包含名称空间编译器会提示找不到相关的类型） 123#include &lt;QtCharts&gt;using namespace QtCharts; 初始化初始化Chart 1234567891011121314// 创建图表QChart *chart = new QChart();chart-&gt;setTitle(&quot;Valve Data&quot;);// 隐藏图例chart-&gt;legend()-&gt;setVisible(false);// 创建图表视图QChartView *chartView = new QChartView(chart);chartView-&gt;setRenderHint(QPainter::Antialiasing);QHBoxLayout *hLayout = new QHBoxLayout(ui-&gt;view);hLayout-&gt;addWidget(chartView);hLayout-&gt;setContentsMargins(0, 0, 0, 0); 波形每一道波形就是一个QLineSeries，每个QLineSeries都要和X轴和Y轴进行绑定 123456789101112131415m_temperature = new QLineSeries();m_temperature-&gt;setColor(Qt::red);m_temperature-&gt;setPointsVisible(true);m_pressure = new QLineSeries();m_pressure-&gt;setColor(Qt::blue);m_pressure-&gt;setPointsVisible(true);m_position = new QLineSeries();m_position-&gt;setColor(Qt::black);m_position-&gt;setPointsVisible(true);m_pressureSetpt = new QLineSeries();m_pressureSetpt-&gt;setColor(Qt::darkYellow);m_pressureSetpt-&gt;setPointsVisible(true); 为了使波形更有区分度，需要配置不同的颜色，建议跟Y轴刻度的颜色保持一致，特别是轴比较多的情况下 1234567void setAxisColor(QAbstractAxis *axis, const QColor &amp;color)&#123; axis-&gt;setGridLineColor(color); axis-&gt;setLinePenColor(color); axis-&gt;setLabelsColor(color); axis-&gt;setTitleBrush(color);&#125; X轴X轴一般是时间轴，时分秒格式：hh:mm:ss 123456QDateTimeAxis *timeAxis = new QDateTimeAxis();timeAxis-&gt;setTitleText(&quot;Time&quot;);timeAxis-&gt;setFormat(&quot;hh:mm:ss&quot;);chart-&gt;addAxis(timeAxis, Qt::AlignBottom);series1-&gt;attachAxis(timeAxis);series2-&gt;attachAxis(timeAxis); Y轴Y轴：左侧和右侧都可以添加刻度尺 12345678910111213141516171819202122232425// 左侧刻度尺QValueAxis *pressureSetpt = new QValueAxis();pressureSetpt-&gt;setTitleText(&quot;Pressure Setpt (Torr)&quot;);pressureSetpt-&gt;setRange(0, 25);chart-&gt;addAxis(pressureSetpt, Qt::AlignLeft);series1-&gt;attachAxis(pressureSetpt);QValueAxis *pressure = new QValueAxis();pressure-&gt;setTitleText(&quot;Pressure (Torr)&quot;);pressure-&gt;setRange(0, 25);chart-&gt;addAxis(pressure, Qt::AlignLeft);series1-&gt;attachAxis(pressure);// 右侧刻度尺QValueAxis *driverTemperature = new QValueAxis();driverTemperature-&gt;setTitleText(&quot;Driver temperature&quot;);driverTemperature-&gt;setRange(0, 100);chart-&gt;addAxis(driverTemperature, Qt::AlignRight);series2-&gt;attachAxis(driverTemperature);QValueAxis *positionAxis = new QValueAxis();positionAxis-&gt;setTitleText(&quot;Position (%)&quot;);positionAxis-&gt;setRange(0, 100);chart-&gt;addAxis(positionAxis, Qt::AlignRight);series2-&gt;attachAxis(positionAxis); 绘图实时绘制波形点：往QLineSeries里边添加数据，用append接口 1234567891011121314151617181920212223242526272829303132QDateTime currentTime = QDateTime::currentDateTime();if(m_resumePause) &#123; m_timeAxis-&gt;setRange(currentTime.addSecs(-10), currentTime);&#125;if(m_channels[0]) &#123; m_pressure-&gt;append(currentTime.toMSecsSinceEpoch(), pressure); if (m_pressure-&gt;count() &gt; m_max) &#123; m_pressure-&gt;remove(0); &#125;&#125;if(m_channels[1]) &#123; m_position-&gt;append(currentTime.toMSecsSinceEpoch(), position); if (m_position-&gt;count() &gt; m_max) &#123; m_position-&gt;remove(0); &#125;&#125;if(m_channels[2]) &#123; m_pressureSetpt-&gt;append(currentTime.toMSecsSinceEpoch(), pressureSetpt); if (m_pressureSetpt-&gt;count() &gt; m_max) &#123; m_pressureSetpt-&gt;remove(0); &#125;&#125;if(m_channels[3]) &#123; m_temperature-&gt;append(currentTime.toMSecsSinceEpoch(), valveTemperature); if (m_temperature-&gt;count() &gt; m_max) &#123; m_temperature-&gt;remove(0); &#125;&#125; 注意事项： 1.时间轴要实时移动到正确的时间窗口范围 2.QLineSeries波形点之后到达一定的数据量需要删除一些点以确保buffer不会写爆（频繁申请内存导致卡顿） 进阶QtCharts自带的时间轴比较丑陋，如果想要定制的话，可以参考以下方法进行样式修改 自定义QValueAxis作为X轴 捕获QValueAxis::rangeChanged信号，获取QChartView里边的scene，同时也可以获取到刻度的左右边界min和max 删除scene（QGraphicsScene）里边的所有items，即原有的刻度不要了 在QGraphicsScene即基础上画刻度，每一个刻度就是一个QGraphicsLineItem 代码参考 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 动态修改 X 轴标签为时间格式，并绘制刻度线QObject::connect(axisX, &amp;QValueAxis::rangeChanged, [axisX, chartView](qreal min, qreal max) &#123; QGraphicsScene *scene = chartView-&gt;scene(); // 检查 min 和 max 是否有效 if (qIsNaN(min) || qIsNaN(max) || qIsInf(min) || qIsInf(max)) &#123; // qWarning() &lt;&lt; &quot;Invalid min or max value:&quot; &lt;&lt; min &lt;&lt; max; return; &#125; // 检查 plotArea 是否有效 if (chartView-&gt;chart()-&gt;plotArea().width() &lt;= 0 || chartView-&gt;chart()-&gt;plotArea().height() &lt;= 0) &#123; // qWarning() &lt;&lt; &quot;Invalid plot area size&quot;; return; &#125; // 清除旧的标签和刻度线 for (QGraphicsItem *item : scene-&gt;items()) &#123; if (item-&gt;data(0).toString() == &quot;custom_label&quot; || item-&gt;data(0).toString() == &quot;custom_line&quot;) &#123; scene-&gt;removeItem(item); delete item; &#125; &#125; // 生成 10 个刻度 int tickCount = 10; // 总共 10 个刻度 qreal tickInterval = (max - min) / (tickCount - 1); // 计算刻度间隔 for (int i = 0; i &lt; tickCount; ++i) &#123; qreal value = min + i * tickInterval; // 检查 value 是否有效 if (qIsNaN(value) || qIsInf(value)) &#123; // qWarning() &lt;&lt; &quot;Invalid value:&quot; &lt;&lt; value; continue; &#125; QDateTime dateTime = QDateTime::fromSecsSinceEpoch(value); // 计算刻度线的位置 qreal x = chartView-&gt;chart()-&gt;plotArea().left() + (value - min) / (max - min) * chartView-&gt;chart()-&gt;plotArea().width(); // 检查 x 是否有效 if (qIsNaN(x) || qIsInf(x)) &#123; // qWarning() &lt;&lt; &quot;Invalid x coordinate:&quot; &lt;&lt; x; continue; &#125; // 只在偶数刻度绘制时间标签和黑线 if (i % 2 == 0) &#123; // 绘制时间标签 QString label = dateTime.toString(&quot;hh:mm:ss&quot;); QGraphicsTextItem *textItem = scene-&gt;addText(label); qreal textWidth = textItem-&gt;boundingRect().width(); // 获取标签宽度 qreal textHeight = textItem-&gt;boundingRect().height(); // 获取标签高度 // 调整标签位置，使其居中对齐刻度线 textItem-&gt;setPos(x - textWidth / 2, chartView-&gt;chart()-&gt;plotArea().bottom() + 10); textItem-&gt;setData(0, &quot;custom_label&quot;); // 标记为自定义标签 // 绘制黑线 qreal lineLength = 10; // 刻度线长度 QGraphicsLineItem *lineItem = scene-&gt;addLine(x, chartView-&gt;chart()-&gt;plotArea().bottom(), x, chartView-&gt;chart()-&gt;plotArea().bottom() + lineLength, QPen(Qt::black)); lineItem-&gt;setData(0, &quot;custom_line&quot;); // 标记为自定义刻度线 &#125; &#125;&#125;); 打包软件打包，需要添加Qt5Charts这个dll 1Qt5Charts.dll 版权版权问题：据说是LGPL授权，商用的话可能会被Qt请喝茶","tags":["Qt","上位机","Charts"],"categories":["程序设计"]},{"title":"上位机数据可视化：Qt表格美化","path":"//qt-table-design.html","content":"介绍表格是一种常见的数据管理界面形式，在大批量的数据交互情形下使用的比较多 表格可以通过样式表设置线条以及边框的颜色 12345QTableWidget&#123; gridline-color : rgb(55, 60, 62); border: 1px solid rgb(62,112,181); &#125; 表头如果表头和第一行的分割线显示，请设置一下表头的样式表 1234QHeaderView::section &#123; border: 1px solid gray; &#125; 表头不是必须的，可以设置horizontalHeaderVisiable属性把它隐藏掉 列列的数目：columnCount 列序号，比较不美观，最好隐藏掉：verticalHeaderVisible -&gt; false 列宽控制 1234for (int i = 0; i &lt; ui-&gt;tableWidget-&gt;columnCount(); ++i) &#123; ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;setSectionResizeMode(i, QHeaderView::Fixed); ui-&gt;tableWidget-&gt;setColumnWidth(i, width);&#125; 行行的数目：rowCount 行高控制 123for (int i = 0; i &lt; tableWidget-&gt;rowCount(); ++i) &#123; ui-&gt;tableWidget-&gt;setRowHeight(i, 30); &#125; 单元格样式表修改，只要指定item项，便可以修改相关的文字颜色、背景色、字体大小、文字对齐等样式 1234567QTableWidget::item&#123; color: red; background-color: blue; font-size: 14px; text-align: center;&#125; 设置只读状态 123item = new QTableWidgetItem;item-&gt;setText(QString::number(p-&gt;suggestedFlow, &#x27;f&#x27;, 2));item-&gt;setFlags(item-&gt;flags() &amp; ~Qt::ItemIsEditable); 插入自定义控件 12345auto itemWidget = new QComboBox;itemWidget-&gt;addItem(&quot;OFF&quot;);itemWidget-&gt;addItem(&quot;ON&quot;);itemWidget-&gt;setCurrentIndex(p-&gt;speedup);ui-&gt;tableWidget-&gt;setCellWidget(5, 1, itemWidget); 获取单元格数据：1.自带item；2.自定义控件item 1234// 如果是一个text itemm_pid.gamma = ui-&gt;tableWidget-&gt;item(row, 1)-&gt;text().toFloat();// 如果是一个widget itemm_pid.type = qobject_cast&lt;QComboBox *&gt;(ui-&gt;tableWidget-&gt;cellWidget(row, 1))-&gt;currentIndex(); 单元格改变 123connect(ui-&gt;tableWidget, &amp;QTableWidget::cellChanged, this, [=](int row, int column) &#123; this-&gt;onCellChanged(row, column);&#125;); 禁止单元格多选 1ui-&gt;tableWidget-&gt;setSelectionMode(QAbstractItemView::SingleSelection); 滚动条水平滚动条：一般都是设置为关闭，开启的话比较丑陋 垂直滚动条：自带的比较丑，如果开启的话需要自定义一下样式表 滚动条样式参考 1234567// 水平滚动条ui-&gt;tableWidget-&gt;horizontalScrollBar()-&gt;setStyleSheet(&quot;QScrollBar&#123;background:rgb(43, 44, 49);height:20px;border: 1px solid rgb(43, 44, 49);&#125;\\QScrollBar::handle&#123;border: 1px solid rgb(62 ,73 ,84);&#125;&quot;);// 垂直滚动条ui-&gt;tableWidget-&gt;verticalScrollBar()-&gt;setStyleSheet(&quot;QScrollBar&#123;background:rgb(43, 44, 49);width:20px;border: 1px solid rgb(43, 44, 49);&#125;\\QScrollBar::handle&#123;border: 1px solid rgb(62 ,73 ,84);&#125;&quot;); 问题问题一点击单元格的时候，整个表格可能会有左右偏移的现象 这是整个滑动区域的宽度（所有的列宽和）大于表格的宽度导致的漂移，需要：1.指定列宽；2.固定表头列宽 12345678910int width = ui-&gt;tableWidget1-&gt;width() / 2 - 1;for (int i = 0; i &lt; ui-&gt;tableWidget1-&gt;columnCount(); ++i) &#123; ui-&gt;tableWidget1-&gt;horizontalHeader()-&gt;setSectionResizeMode(i, QHeaderView::Fixed); ui-&gt;tableWidget1-&gt;setColumnWidth(i, width);&#125;for (int i = 0; i &lt; ui-&gt;tableWidget2-&gt;columnCount(); ++i) &#123; ui-&gt;tableWidget2-&gt;horizontalHeader()-&gt;setSectionResizeMode(i, QHeaderView::Fixed); ui-&gt;tableWidget2-&gt;setColumnWidth(i, width);&#125; 上下偏移也与此同理，只要不超过表格控件的高度就行 问题二编辑动作的捕获：有cellChanged和closeEditor两个信号，前者是单元格内容发生变化时触发，但这个当控件新建时也会触发；如果想要单纯的捕获编辑动作本身，建议用后者 12345connect(ui-&gt;tableWidget-&gt;itemDelegate(), &amp;QAbstractItemDelegate::closeEditor, this, [=]() &#123; int row = ui-&gt;tableWidget-&gt;currentRow(); int column = ui-&gt;tableWidget-&gt;currentColumn(); this-&gt;onCellChanged(row, column);&#125;); 如果单元格插入了一些自定义的控件，例如QComboBox，需要统一一个专门处理单元格的函数，将row和column的参数传到同一的接口处理 123456789itemWidget = new QComboBox;itemWidget-&gt;addItem(&quot;禁用&quot;);itemWidget-&gt;addItem(&quot;固定时间&quot;);itemWidget-&gt;addItem(&quot;固定坡度&quot;);itemWidget-&gt;setCurrentIndex(p-&gt;rampMode);ui-&gt;tableWidget-&gt;setCellWidget(6, 1, itemWidget);connect(itemWidget, QOverload&lt;int&gt;::of(&amp;QComboBox::currentIndexChanged), this, [=](int) &#123; this-&gt;onCellChanged(6, 1);&#125;);","tags":["Qt","上位机","表格"],"categories":["程序设计"]},{"title":"开发板LED电路问题定位","path":"//board-led-problem.html","content":"背景淘宝买的RK3399开发板的电源LED1突然不亮了，刚开始被吓到以为烧坏了，但是开发板上电没有问题，在给客服投诉之前秉持着专业的精神给它做了个分析 电路图LED1串联了一个10kΩ的电阻，这个电路图贼简单，电阻主要是分压限流的作用，这个LED是红色的 LED的正常工作电压电流参考（电流大小无非是亮度强弱的问题，实际只要偏置电压给够就行） 颜色 电压 电流 红色 1.8-2.2V 20mA 绿色 2.0-2.4V 20mA 蓝色 3-4V 20mA 白色 3-3.4V 20mA 万用表旁边的红光LED2正常点亮，量了一下电压，大概在1.8V左右，这个正好可以作为对比 再量一下LED1的电压，测量值为5V，说明分压的电阻根本没有电流通过，LED1内部已经开路了 解决办法手动更换、焊接一个红光LED，只能自己掏钱买一个LED灯了","tags":["LED","硬件","RK3399"],"categories":["嵌入式"]},{"title":"关于千年虫问题的思考","path":"//y2k-problem-thinking.html","content":"背景千年虫问题（Y2K Problem），又称“2000年问题”或“Y2K漏洞”，是指在20世纪的计算机系统中，年份通常只用两位数字表示（例如“98”代表1998年），当时间从1999年12月31日跨入2000年1月1日时，系统可能会将“00”错误地识别为1900年，从而导致计算机程序出现逻辑错误或崩溃。 介绍最近在做嵌入式自动化设备开发遇到一个时间戳的问题，要用这个时间戳保存一些设备信息、运行状态信息、波形数据、文件信息，时间精度要求1ms，下位机是没有RTC的！因为单片机是32位的，所以自然而然地想到用uint32_t来表示这个时间戳，但认真想想这个时间戳其实是有一些漏洞在里边的，好比如上面介绍的千年虫问题 uint32_t我们计算一下uint32_t变量保存的毫秒最大能存储多少天 uint64_t我们计算一下uint64_t变量保存的毫秒最大能存储多少天 总结综上，我最后选择了uint64_t作为时间戳的存储变量类型，因为自动化设备是一年365天不停机的，如果用uint32_t，设备隔了50天就复位时间戳了，这个肯定不能满足要求！","tags":["时间戳","千年虫"],"categories":["程序设计"]},{"title":"QtCreator快捷键合集","path":"//qtcreator-shortcuts.html","content":"前言QtCreator是一款跨平台的IDE，专为Qt开发设计，支持C/C++/JS/Python编程，支持设备远程调试，支持代码高亮，集成帮助文档，原生支持cmake和git，确实是一款朴实而又强大的集成开发环境，让人有种爱不释手的感觉 编辑 功能 快捷键 复制 Ctrl + C 粘贴 Ctrl + V 剪切 Ctrl + X 代码片段格式化（自动缩进） Ctrl + I 统一修改某个关键字 Ctrl + Shift + R 代码注释开关 Ctrl + &#x2F; 查看粘贴板 Ctrl + Shift + V 可视化空白字符 Ctrl + E, Ctrl + V 剪切行 Shift + Del 复制行 Ctrl + Ins 大写转换 Alt + Shift + U 小写转换 Alt + U 代码折叠 Ctrl + &lt; 代码展开 Ctrl + &gt; 跳转到块起始 Ctrl + [ 跳转到块末尾 Ctrl + ] 切换书签 Ctrl + M 定位到某一行代码 Ctrl + L 增大字体 Ctrl + + 减小字体 Ctrl + - 重置字体大小 Ctrl + 0 文件 功能 快捷键 打开文件 Ctrl + O 关闭文件 Ctrl + W 关闭所有文件 Ctrl + Shift + W 保存所有文件 Ctrl + Shift + S 切换头文件&#x2F;源文件 F4 显示历史文件列表 Ctrl + Tab 窗口 功能 快捷键 全屏 Ctrl + Shift + F11 左侧栏收起&#x2F;展开 Alt + 0 右侧栏收起&#x2F;展开 Alt + Shift + 0 上下分割窗口 Ctrl + E + 2 左右分割窗口 Ctrl + E + 3 窗口复原 Ctrl + E + 1 退出软件 Ctrl + Q 切换功能模式 Ctrl + 1&#x2F;2&#x2F;3&#x2F;4&#x2F;5 切换控制台功能 Alt + 1-8 关闭IDE Ctrl + Q 关闭当前代码文件窗口 Ctrl + W 调试 功能 快捷键 运行 Ctrl + R 构建当前工程 Ctrl + B 构建所有工程 Ctrl + Shift + B 切换构建模式 Ctrl + T 开始调试 F5 中断&#x2F;继续 F5 单步跳过 F10 单步进入 F11 单步跳出 Shift + F11 切换断点 F9 检索 功能 快捷键 定位器（文件&#x2F;符号检索） Ctrl + K 快速检索文件引用出处 Ctrl + Shift + U 帮助文档 F1（按两次） 帮助页面定位到搜索框 Alt + L 版本控制 功能 快捷键 查看当前文件改动 Alt + G, Alt + D 查看当前工程改动 Alt + G, Alt + Shift + D 当前文件修改记录 Alt + G, Alt + L 查看当前工程修改记录 Alt + G, Alt + K 暂存区代码提交 Alt + G, Alt + C","tags":["Qt","快捷键","QtCreator","IDE"],"categories":["开发工具"]},{"title":"按钮Tab分栏功能实现","path":"//exclusive-tab-buttons.html","content":"前言我想实现一个左侧的上下的Tab分栏功能，看了Qt官方的文档好像没有合适的解决方案，于是自己自定义了一个 介绍在上位机开发中，如果想要做一个侧边栏点击切换分页的功能，大家都想到用一组QPushButton和自定义的QWidget来做 然后我们用样式表修饰QPushButton，同时用QWidget自定一些Pages 123456789101112131415QPushButton &#123; font-size: 18px; / color: white; background-color: rgb(10,88,163); border: 2px solid rgb(114,188,51); text-align: left; padding-left: 10px; font-weight: bold;&#125;QPushButton:focus &#123; background-color: rgb(41,51,57);\tcolor: rgb(114,188,51);\tborder-width: 4px;&#125; 用信号和槽把Buttons和Pages绑定起来，很快，一个切换分栏的用户界面就大功告成了 123456789101112131415connect(ui-&gt;button1, &amp;QPushButton::clicked, this, [=]() &#123; page1-&gt;setVisible(true);&#125;);connect(ui-&gt;button2, &amp;QPushButton::clicked, this, [=]() &#123; page2-&gt;setVisible(true);&#125;);connect(ui-&gt;button3, &amp;QPushButton::clicked, this, [=]() &#123; page3-&gt;setVisible(true);&#125;);connect(ui-&gt;button4, &amp;QPushButton::clicked, this, [=]() &#123; page4-&gt;setVisible(true);&#125;); 问题这样做的思路并没有错，但是会遇到一些问题，就是Pages里边如果有一些强焦点属性的控件，很容易把左侧栏的Buttons焦点拿走，导致focus样式失效！问题的关键在于侧边栏和分页是在同一个界面下的，Buttons的焦点是很容易丧失的 解决引入QButtonGroup功能，确保每个Button都是exclusive的 12345678m_group = new QButtonGroup(this);m_group-&gt;setExclusive(true);m_group-&gt;addButton(ui-&gt;alarm);m_group-&gt;addButton(ui-&gt;operate);m_group-&gt;addButton(ui-&gt;communication);m_group-&gt;addButton(ui-&gt;systemLearn);m_group-&gt;addButton(ui-&gt;conductanceCurves);m_group-&gt;addButton(ui-&gt;about); 在Button切换焦点的时候变更样式，捕获QButtonGroup的buttonClicked信号 12345678910111213141516171819202122connect(m_group, QOverload&lt;QAbstractButton *&gt;::of(&amp;QButtonGroup::buttonClicked), [=](QAbstractButton *button)&#123; for(auto &amp;but : m_group-&gt;buttons()) &#123; if(button != but) &#123; but-&gt;setStyleSheet(&quot;QPushButton &#123; font-size: 18px;\\ color: white;\\ background-color: rgb(10,88,163);\\ border: 2px solid rgb(114,188,51);\\ text-align: left;\\ padding-left: 10px;\\ font-weight: bold;&#125;&quot;); &#125; else &#123; but-&gt;setStyleSheet(&quot;QPushButton &#123; font-size: 18px;\\ color: rgb(114,188,51);\\ background-color: rgb(41,51,57);\\ border: 4px solid rgb(114,188,51);\\ text-align: left;\\ padding-left: 10px;\\ font-weight: bold;&#125;&quot;); &#125; &#125;&#125;); 直接不要样式表里边的focus属性了，大致的实现效果如下 当然，要记得默认一个最开始的Button 12345678ui-&gt;operate-&gt;setFocus();ui-&gt;operate-&gt;setStyleSheet(&quot;QPushButton &#123; font-size: 18px;\\ color: rgb(114,188,51);\\ background-color: rgb(41,51,57);\\ border: 4px solid rgb(114,188,51);\\ text-align: left;\\ padding-left: 10px;\\ font-weight: bold;&#125;&quot;); 总结样式表能解决大部分问题，但是一些边边角角的东西需要自己琢磨（写C++代码）实现","tags":["Qt","GUI","按键"],"categories":["程序设计"]},{"title":"开源软件推荐指南","path":"//open-software-guide.html","content":"介绍开源，极大促进了软件行业的繁荣；知识共享、技术迭代、协同工作成了信息时代的主流；开源不是免费，用户仍可以选择为技术服务买单 视频播放VLC Media Player，一款开源、强大的音视频播放软件，支持网络播放源 图像编辑GIMP是Photoshop的绝佳替代品，支持多个操作系统平台，开源、小巧、免费，日常修图需求都可以满足，使用教程可以参考我的CSDN专栏 文本编辑器VSCode是一款功能堪比IDE的文本编辑器，它能无缝切换嵌入式、Web、PC、移动端的开发环境，而且还开源和跨平台，支持多种开发插件，像常见的cmake、git、gdb、stlink都能集成，使用参考：ROS开发、NXP MCU开发 nodepad++，推荐它的原因是因为小巧玲珑，界面干净整洁，而且它从不卡顿 开源的IDEQtCreator是Qt官方出品的集成开发环境，支持嵌入式、移动端、PC开发，甚至写驱动代码也没有问题，对cmake的支持堪称一流！代码高亮、文档查看也相当不错，支持多个操作系统平台，比VS更轻量级，使用参考：快捷键、Qt6安装及使用 文档系统MrDoc是基于Python开发的在线文档系统，适合作为个人和中小型团队的私有云文档、云笔记和知识管理工具，致力于成为优秀的私有化在线文档部署方案 开源云盘openmediavault，这个本质是一个NAS方案，可以用来存储私人的数据，通过安装个性化的app和插件实现各种数据存储服务 项目管理Overview - Redmine是一款工作在web端的项目管理软件，支持进度查看、工时登记等功能 缺陷管理Bugzilla的界面简单，但是功能齐全，支持Bug的追溯查看，缺陷评论、邮件服务也不错 办公套件LibreOffice，如果厌倦了WPS和MS office的广告和雍总，这个软件也是一个不错的选择！正真自由免费的全能办公套件，以前安装Ubuntu都会自带这个办公套件 网络调试wireshark是一款强大的网络数据可视化工具，能抓取多种网络接口（以太网、WLAN、CAN）的数据包并将数据可视化，帮助我们更好地调试和分析网络通信的过程以及异常情况 高效调试SavvyCAN是一款小巧强大的CAN分析诊断工具，支持CAN&#x2F;CANFD数据表格可视化、支持DBC协议解析、支持数据过滤、UDS协议扫描与解码、支持脚本接口扩展功能，是汽车电子工作者的必备神器！ 视频剪辑OpenShot是一款强大、开源、跨平台的视频剪辑软件，有详尽的文档操作指南，支持音视频混合编辑、3D动画 打包工具Windows平台的exe打包工具：Inno Setup，经典小巧又耐用，做上位机开发必备工具，使用教程可以参考链接","tags":["开源"],"categories":["方法论"]},{"title":"RT-Thread拉新工程编译报错","path":"//rt-thread-new-project-compile-problem.html","content":"问题一拉新RT-Thread开源代码后发现编译出错，rt_vsnprintf库编译有问题 1.\\build\\keil\\Obj\\rt-thread.axf: Error: L6218E: Undefined symbol rt_vsnprintf (referred from kstdio.o). 打开menuconfig ：RT-Thread Kernel → klibc options → rt_vsnprintf options，开启以下选项 问题二rt_vsscanf库编译问题 1.\\build\\keil\\Obj\\rt-thread.axf: Error: L6218E: Undefined symbol rt_vsscanf (referred from kstdio.o). 打开menuconfig ：RT-Thread Kernel → klibc options → rt_vsscanf options，开启以下选项 总结这两个问题是因为RT-Thread改了rt_vsnprintf和rt_vsscanf两个库的链接方式：做成了开关的配置形式","tags":["RT-Thread"],"categories":["嵌入式"]},{"title":"cmake自定义软件信息","path":"//cmake-define-software-info.html","content":"用法版本号 1add_definitions(-DSOFTWARE_VERSION=&quot;1.0.2&quot;) 编译类型 1add_definitions(-DBUILD_TYPE=&quot;Debug&quot;) 作者信息 1add_definitions(-DAUTHOR=&quot;hywing&quot;) 公司 1add_definitions(-DCOMPANY=&quot;iotstuff&quot;) 编译生成时间 12string(TIMESTAMP CURRENT_TIME &quot;%Y-%m-%d %H:%M:%S&quot;)add_definitions(-DBUILD_DATE=&quot;$&#123;CURRENT_TIME&#125;&quot;) 以上信息在cmake中通过add_definitions关键字生成相应的宏定义，在代码中只要直接使用这些宏就可以了 12ui-&gt;version-&gt;setText(SOFTWARE_VERSION);ui-&gt;buildDate-&gt;setText(BUILD_DATE); 如果你在一个工程代码中点击找不到宏定义的出处，那么它大概率在工程文件中被定义了！ 注意如果你要发布版本，这种做法需要每次编译打包前执行一下cmake，否则你的时间信息有可能不是最新的！","tags":["cmake"],"categories":["程序设计"]},{"title":"stm32移植LCD2002驱动","path":"//stm32-lcd2002-driver.html","content":"介绍LCD2002支持20X2个字符串显示，引脚功能和读写时序跟LCD1602都很像 LCD类型：字符点阵 点 阵 数：20×2 外形尺寸：116.0mm×37.0mm（长宽） 视域尺寸：83.0mm×18.6mm 点 距 离：0.05mm×0.05mm 点 大 小：0.65mm×0.6mm 控 制 器：SPLC780 玻璃类型：FSTN或STN 显示内容：20（例）×2（行） 背光类型：LED白光（白底黑字，蓝底白字） 数据传输：并口 工作电压：5V LCD2002的应用场景有： 物联网数据采集端显示：展示传感器数值 工业自动化：电机控制展示信息 嵌入式场景：智能家居终端设备 引脚LCD2002有16Pin引脚，每个引脚功能如下 管脚号 符号 功能 1 Vss 电源地（ GND） 2 Vdd 电源电压(+5V) 3 V0 LCD 驱动电压(可调) 4 RS 寄存器选择输入端，输入 MPU 选择模块内部寄存器类型信号：RS&#x3D;0，当 MPU 进行写模块操作，指向指令寄存器；当 MPU 进行读模块操作，指向地址计数器；RS&#x3D;1，无论 MPU 读操作还是写操作，均指向数据寄存器 5 R&#x2F;W 读写控制输入端，输入 MPU 选择读&#x2F;写模块操作信号：R&#x2F;W&#x3D;0 读操作； R&#x2F;W&#x3D;1 写操作 6 E 使能信号输入端，输入 MPU 读&#x2F;写模块操作使能信号：读操作时，高电平有效；写操作时，下降沿有效 7 DB0 数据输入&#x2F;输出口， MPU 与模块之间的数据传送通道 8 DB1 数据输入&#x2F;输出口， MPU 与模块之间的数据传送通道 9 DB2 数据输入&#x2F;输出口， MPU 与模块之间的数据传送通道 10 DB3 数据输入&#x2F;输出口， MPU 与模块之间的数据传送通道 11 DB4 数据输入&#x2F;输出口， MPU 与模块之间的数据传送通道 12 DB5 数据输入&#x2F;输出口， MPU 与模块之间的数据传送通道 13 DB6 数据输入&#x2F;输出口， MPU 与模块之间的数据传送通道 14 DB7 数据输入&#x2F;输出口， MPU 与模块之间的数据传送通道 15 A 背光的正端+5V 16 K 背光的负端 0V 原装的LCD并没有焊接排针，需要自己手动焊接 移植引脚定义，一般只需要用到以下13个Pin 12345678910111213#define LCD_RS_PIN GET_PIN(A, 4)#define LCD_RW_PIN GET_PIN(A, 5)#define LCD_E_PIN GET_PIN(A, 6)#define LCD_D0_PIN GET_PIN(A, 7)#define LCD_D1_PIN GET_PIN(B, 0)#define LCD_D2_PIN GET_PIN(B, 1)#define LCD_D3_PIN GET_PIN(B, 2)#define LCD_D4_PIN GET_PIN(B, 10)#define LCD_D5_PIN GET_PIN(B, 11)#define LCD_D6_PIN GET_PIN(B, 12)#define LCD_D7_PIN GET_PIN(B, 13)#define LCD_V0 GET_PIN(B, 4)#define LCD_BL GET_PIN(B, 5) 初始化LCD2002引脚 12345678910111213141516void LCD_GPIO_Init() &#123; rt_pin_mode(LCD_V0, PIN_MODE_OUTPUT); rt_pin_mode(LCD_BL, PIN_MODE_OUTPUT); rt_pin_mode(LCD_RS_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LCD_RW_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LCD_E_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LCD_D0_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LCD_D1_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LCD_D2_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LCD_D3_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LCD_D4_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LCD_D5_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LCD_D6_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LCD_D7_PIN, PIN_MODE_OUTPUT);&#125; 写数据 1234567891011121314151617void LCD_WriteData(uint8_t data) &#123; rt_pin_write(LCD_RS_PIN, PIN_HIGH); rt_pin_write(LCD_RW_PIN, PIN_LOW); rt_pin_write(LCD_E_PIN, PIN_LOW); rt_pin_write(LCD_D0_PIN, (data &amp; 0x01) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D1_PIN, (data &amp; 0x02) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D2_PIN, (data &amp; 0x04) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D3_PIN, (data &amp; 0x08) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D4_PIN, (data &amp; 0x10) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D5_PIN, (data &amp; 0x20) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D6_PIN, (data &amp; 0x40) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D7_PIN, (data &amp; 0x80) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_E_PIN, PIN_HIGH); rt_thread_mdelay(5); rt_pin_write(LCD_E_PIN, PIN_LOW); &#125; 写命令 1234567891011121314151617void LCD_WriteCommand(uint8_t command) &#123; rt_pin_write(LCD_RS_PIN, PIN_LOW); rt_pin_write(LCD_RW_PIN, PIN_LOW); rt_pin_write(LCD_E_PIN, PIN_LOW); rt_pin_write(LCD_D0_PIN, (command &amp; 0x01) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D1_PIN, (command &amp; 0x02) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D2_PIN, (command &amp; 0x04) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D3_PIN, (command &amp; 0x08) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D4_PIN, (command &amp; 0x10) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D5_PIN, (command &amp; 0x20) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D6_PIN, (command &amp; 0x40) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D7_PIN, (command &amp; 0x80) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_E_PIN, PIN_HIGH); rt_thread_mdelay(5); rt_pin_write(LCD_E_PIN, PIN_LOW); &#125; 设置光标位置 12345678void LCD_SetCursor(uint8_t col, uint8_t row) &#123; uint8_t address = col; if (row == 1) &#123; address += 0x40; &#125; LCD_WriteCommand(0x80 | address); &#125; 绘制字符，需要配合LCD_SetCursor接口使用 123456void LCD_Print(char* str) &#123; while (*str) &#123; LCD_WriteData(*str++); &#125;&#125; LCD初始化，设置清屏、光标位置自动累加等 12345678910111213void LCD_Init() &#123; rt_pin_write(LCD_V0, PIN_HIGH); rt_pin_write(LCD_BL, PIN_HIGH); rt_thread_mdelay(15); LCD_WriteCommand(0x38); rt_thread_mdelay(5); LCD_WriteCommand(0x0c); rt_thread_mdelay(5); LCD_WriteCommand(0x06); rt_thread_mdelay(5); LCD_WriteCommand(0x01); rt_thread_mdelay(5);&#125; 测试用例，在屏幕第一行显示Levitation字样 123456789101112131415161718192021222324252627282930static void lcd2002_entry(void* parameter) &#123;\tLCD_GPIO_Init(); LCD_Init();\tLCD_WriteCommand( 0x80 ); LCD_SetCursor(5, 0); LCD_Print(&quot;Levitation&quot;); while(1) &#123; rt_thread_mdelay(500); &#125;&#125;int main()&#123;\t// lcd2002 rt_thread_t lcd2002_thread = rt_thread_create(&quot;lcd2002&quot;, lcd2002_entry, RT_NULL, 512, 21, 20); if (lcd2002_thread != RT_NULL) &#123; rt_thread_startup(lcd2002_thread); &#125; while (1) &#123; rt_pin_write(LED0_PIN, PIN_HIGH); rt_thread_mdelay(10); rt_pin_write(LED0_PIN, PIN_LOW); rt_thread_mdelay(10); &#125; return RT_EOK;&#125; 显示效果 总结买的是5V供电的LCD2002，但它的数据引脚是可以兼容3.3V的GPIO的，详细可参考数据手册关于芯片引脚电气特性的说明 立创上面汉昇的LCD2002背光引脚BLK、BLA的说明是错误的 延申BLA背光和V0对比度通过使用1KHz方波改变占空比可以实现背光和对比度的调节，可以节约硬件Bom成本，减少电位器的使用 对比度调节效果 亮度调节效果","tags":["stm32","LCD2002"],"categories":["嵌入式"]},{"title":"下位机没有RTC模块如何做时间同步","path":"//lower-device-time-sync.html","content":"如题：开发环境下，如果stm32没有板载RTC模块，怎么跟上位机做时间同步呢？ 如果有以太网，可以考虑移植NTP协议，借用网络中比较可靠的时钟源作为时间参考 如果有串口，可以考虑使用GNSS模块，获取NMEA-0183卫星时间作为时间参考，GNSS也带有PPS做时间校准 如果跟上位机建立通信连接，可以采用上位机时刻+定期心跳机制获取一个大致的时间参考 如果跟PLC建立EtherCAT通信，也可以用PLC的时间做参考","tags":["下位机","RTC","时间同步"],"categories":["嵌入式"]},{"title":"msvc与g++编译器字符编码问题","path":"//msvc-g++-coder-problem.html","content":"介绍同一份代码，都是用utf-8保存的文件，用g++编译中文是不会乱码的，换成msvc2017编译就乱码了 解决在包含中文的源文件头部添加以下代码，设置字符编码为utf-8 123#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1600)# pragma execution_character_set(&quot;utf-8&quot;)#endif","tags":["msvc","g++","编译器","字符编码"],"categories":["程序设计"]},{"title":"信号和槽函数重载写法参考","path":"//qt-signal-slot-overload.html","content":"信号重载最常见的重载信号就是QComboBox::currentIndexChanged，它有int和const QString &amp;两种重载参数 12345678910111213connect(ui-&gt;algorithm, QOverload&lt;int&gt;::of(&amp;QComboBox::currentIndexChanged), this, [=](int index) &#123; if(index == 0) &#123; this-&gt;initTable(PID); &#125; else &#123; this-&gt;initTable(Model); &#125; emit this-&gt;changeAlgorithm(index);&#125;);connect(ui-&gt;algorithm, QOverload&lt;const QString &amp;&gt;::of(&amp;QComboBox::currentIndexChanged), this, [=](const QString &amp;text) &#123; qDebug() &lt;&lt; text;&#125;); 槽函数重载以传递自定义参数类型为例，自定义结构体需要注册成Qt的元数据类型 123456789101112131415#pragma pack (4)typedef struct &#123; ...&#125; TAlgorithmModel;#pragma pack ()Q_DECLARE_METATYPE(TAlgorithmModel *)#pragma pack (4)typedef struct &#123;\t...&#125; TAlgorithmPid;#pragma pack ()Q_DECLARE_METATYPE(TAlgorithmPid *) 发送方信号 123// 原始信号void NetworkManager::updateModel(const TAlgorithmModel *);void NetworkManager::updatePid(const TAlgorithmPid *); 接收方槽函数重载 123// 重载槽函数void OperatePage::onUpdateTable(const TAlgorithmModel *p);void OperatePage::onUpdateTable(const TAlgorithmPid *p); 信号和槽写法参考 12connect(NetworkManager::getInstance(), &amp;NetworkManager::updateModel, operate, QOverload&lt;const TAlgorithmModel *&gt;::of(&amp;OperatePage::onUpdateTable));connect(NetworkManager::getInstance(), &amp;NetworkManager::updatePid, operate, QOverload&lt;const TAlgorithmPid *&gt;::of(&amp;OperatePage::onUpdateTable));","tags":["Qt","信号","槽","重载"],"categories":["程序设计"]},{"title":"Git仓库重定向","path":"//git-repository.html","content":"前言在开发过程，如果想把代码从某一个仓库转移到另外一个仓库，比如，你现在在gitee上面有一个zhd-desktop的仓库，后面你不想要了，你想把它放到GitHub上面，怎么办才能保留原来的提交信息和分支呢？ 解决命令行 在原来的仓库里边添加远端仓库链接 1git remote add upstream https://github.com/hywing/zhd-desktop.git 往upstream推送develop分支 1git push upstream develop -f tortoiseGit 先添加远程仓库 选择远程仓库后push","tags":["git","upstream"],"categories":["开发工具"]},{"title":"long数据类型跨平台问题","path":"//long-data-size.html","content":"示例代码以下代码用于打印long类型数据的大小 1234567#include &lt;iostream&gt;int main()&#123;\tstd::cout &lt;&lt; &quot;size of long : &quot; &lt;&lt; sizeof(long) &lt;&lt; std::endl;\treturn 0;&#125; WindowsQt5.12.9 MSVC2017 64bit编译器：long -&gt; 32位 LinuxQt5.12.9 g++9.4.0编译器：long -&gt; 64位 建议跨平台程序尽量采用跨平台库，如Boost 123456789101112131415161718192021222324252627282930313233343536373839namespace boost&#123; using ::int8_t; using ::int_least8_t; using ::int_fast8_t; using ::uint8_t; using ::uint_least8_t; using ::uint_fast8_t; using ::int16_t; using ::int_least16_t; using ::int_fast16_t; using ::uint16_t; using ::uint_least16_t; using ::uint_fast16_t; using ::int32_t; using ::int_least32_t; using ::int_fast32_t; using ::uint32_t; using ::uint_least32_t; using ::uint_fast32_t;# ifndef BOOST_NO_INT64_T using ::int64_t; using ::int_least64_t; using ::int_fast64_t; using ::uint64_t; using ::uint_least64_t; using ::uint_fast64_t;# endif using ::intmax_t; using ::uintmax_t;&#125; 或者stdint.h 1234567891011121314151617181920212223242526272829typedef signed char int8_t;typedef short int16_t;typedef int int32_t;typedef long long int64_t;typedef unsigned char uint8_t;typedef unsigned short uint16_t;typedef unsigned int uint32_t;typedef unsigned long long uint64_t;typedef signed char int_least8_t;typedef short int_least16_t;typedef int int_least32_t;typedef long long int_least64_t;typedef unsigned char uint_least8_t;typedef unsigned short uint_least16_t;typedef unsigned int uint_least32_t;typedef unsigned long long uint_least64_t;typedef signed char int_fast8_t;typedef int int_fast16_t;typedef int int_fast32_t;typedef long long int_fast64_t;typedef unsigned char uint_fast8_t;typedef unsigned int uint_fast16_t;typedef unsigned int uint_fast32_t;typedef unsigned long long uint_fast64_t;typedef long long intmax_t;typedef unsigned long long uintmax_t;","tags":["Windows","linux","long","跨平台"],"categories":["程序设计"]},{"title":"Windows平台git clone文件路径太长报错","path":"//git-clone-url-too-long.html","content":"问题描述在Windows下拉取一些比较大的开源项目经常会提示文件路径太长（filename too long），然后死活都不成功 解决办法1.配置git 1git config --system core.longpaths true 2.修改文件C:\\Program Files\\Git\\etc\\gitconfig（需要以管理员身份打开） 12345[core]\tautocrlf = true\tfscache = true\tsymlinks = false\tlongpaths = true longpaths = true表示允许路径字符串超过260 3.输入命令查看 1git config --system core.longpaths 显示结果为true表示已经成功设置","tags":["Windows","git"],"categories":["程序设计"]},{"title":"ros2 foxy订阅话题问题","path":"//ros2-foxy-subscribe-problem.html","content":"代码片段这部分代码在galactic版本编译是OK的，可在foxy下编译就出了问题 123456789101112131415161718192021222324252627TeleopPanel::TeleopPanel(QWidget* parent) : rviz_common::Panel(parent), playRate_(1.0)&#123; signalPub_ = nh_-&gt;create_publisher&lt;std_msgs::msg::Int16&gt;(&quot;/pixel/lv/run_signal&quot;, 5); beginPub_ = nh_-&gt;create_publisher&lt;std_msgs::msg::Float32&gt;(&quot;/pixel/lv/begin_signal&quot;, 5); ratePub_ = nh_-&gt;create_publisher&lt;std_msgs::msg::Float32&gt;(&quot;/pixel/lv/rate_signal&quot;, 5); currTimeSub_ = nh_-&gt;create_subscription&lt;std_msgs::msg::String&gt;(&quot;/pixel/lv/current_time&quot;, 10, std::bind(&amp;TeleopPanel::CurrTimeSub, this, std::placeholders::_1)); selectPtSub_ = nh_-&gt;create_subscription&lt;sensor_msgs::msg::PointCloud2&gt;(&quot;/rviz_selected_points&quot;, 10, std::bind(&amp;TeleopPanel::SelectPtSub, this, std::placeholders::_1)); std::thread t(&amp;TeleopPanel::StartSpin, this); t.detach(); SetPanelLayout();&#125;void TeleopPanel::CurrTimeSub(const std_msgs::msg::String&amp; msg)&#123; QString currTime = QString::fromStdString(msg.data); currentTimeEditor_-&gt;setText(currTime);&#125;void TeleopPanel::SelectPtSub(const sensor_msgs::msg::PointCloud2&amp; msg)&#123; const auto ptsNum = msg.width; QString ptsNumQStr = QString::fromStdString(std::to_string(ptsNum)); selectPtsEditor_-&gt;setText(ptsNumQStr);&#125; 出错部分两个create_subscription调用出错 12currTimeSub_ = nh_-&gt;create_subscription&lt;std_msgs::msg::String&gt;(&quot;/pixel/lv/current_time&quot;, 10, std::bind(&amp;TeleopPanel::CurrTimeSub, this, std::placeholders::_1));selectPtSub_ = nh_-&gt;create_subscription&lt;sensor_msgs::msg::PointCloud2&gt;(&quot;/rviz_selected_points&quot;, 10, std::bind(&amp;TeleopPanel::SelectPtSub, this, std::placeholders::_1)); create_subscription函数原型 1234567891011std::shared_ptr&lt;SubscriptionT&gt; create_subscription( const std::string &amp; topic_name, const rclcpp::QoS &amp; qos, CallbackT &amp;&amp; callback, const SubscriptionOptionsWithAllocator&lt;AllocatorT&gt; &amp; options = SubscriptionOptionsWithAllocator&lt;AllocatorT&gt;(), typename MessageMemoryStrategyT::SharedPtr msg_mem_strat = ( MessageMemoryStrategyT::create_default() ) ); 出错内容 下面是其中一部分报错内容 12345678910111213141516// 报错一play_panel.cpp:26: error: no match for ‘operator=’ (operand types are ‘rclcpp::Subscription&lt;sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt; &gt;::SharedPtr’ &#123;aka ‘std::shared_ptr&lt;rclcpp::Subscription&lt;sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt; &gt; &gt;’&#125; and ‘std::shared_ptr&lt;rclcpp::Subscription&lt;const sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt;&amp;, std::allocator&lt;void&gt;, rclcpp::message_memory_strategy::MessageMemoryStrategy&lt;const sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt;&amp;, std::allocator&lt;void&gt; &gt; &gt; &gt;’) 26 | selectPtSub_ = nh_-&gt;create_subscription&lt;sensor_msgs::msg::PointCloud2&gt;(&quot;/rviz_selected_points&quot;, 10, std::bind(&amp;TeleopPanel::SelectPtSub, this, std::placeholders::_1)); | ^// 报错二play_panel.cpp:26:25: error: no matching member function for call to &#x27;create_subscription&#x27;node_impl.hpp:91:7: note: candidate template ignored: substitution failure [with MessageT = sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt;, CallbackT = std::_Bind&lt;void (LidarViewRos2::RvizPlugin::TeleopPanel::*(LidarViewRos2::RvizPlugin::TeleopPanel *, std::_Placeholder&lt;1&gt;))(const sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt; &amp;)&gt;, AllocatorT = std::allocator&lt;void&gt;, CallbackMessageT = const sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt; &amp;, SubscriptionT = rclcpp::Subscription&lt;const sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt; &amp;, std::allocator&lt;void&gt;, rclcpp::message_memory_strategy::MessageMemoryStrategy&lt;const sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt; &amp;, std::allocator&lt;void&gt; &gt; &gt;, MessageMemoryStrategyT = rclcpp::message_memory_strategy::MessageMemoryStrategy&lt;const sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt; &amp;, std::allocator&lt;void&gt; &gt;]// 报错三/opt/ros/foxy/include/rclcpp/subscription_factory.hpp:97: error: no matching function for call to ‘rclcpp::AnySubscriptionCallback&lt;const sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt;&amp;, std::allocator&lt;void&gt; &gt;::set(std::_Bind&lt;void (LidarViewRos2::RvizPlugin::TeleopPanel::*(LidarViewRos2::RvizPlugin::TeleopPanel*, std::_Placeholder&lt;1&gt;))(const sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt;&amp;)&gt;)’ 97 | any_subscription_callback.set(std::forward&lt;CallbackT&gt;(callback)); | ^~~~~~~~~~~~~~~~~~~~~~~~~ // 报错四/usr/include/c++/9/ext/new_allocator.h:64: error: forming pointer to reference type ‘const sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt;&amp;’typedef const _Tp* const_pointer; 其实就是模板函数的原型不匹配导致的，CallbackT的模板参数需要传入指针类型才能正确解参数类型，传入引用类型是不对的 正确写法 只要把CurrTimeSub和SelectPtSub两个函数的原型修改一下（入参改成指针）就OK了 123456789101112void TeleopPanel::CurrTimeSub(const std_msgs::msg::String::SharedPtr msg)&#123; QString currTime = QString::fromStdString(msg-&gt;data); currentTimeEditor_-&gt;setText(currTime);&#125;void TeleopPanel::SelectPtSub(const sensor_msgs::msg::PointCloud2::SharedPtr msg)&#123; const auto ptsNum = msg-&gt;width; QString ptsNumQStr = QString::fromStdString(std::to_string(ptsNum)); selectPtsEditor_-&gt;setText(ptsNumQStr);&#125; 总结foxy和galactic及后续版本在create_subscription模板函数的实现有区别，移植的时候要注意兼容性，参考issue ros2 add arguments to callback - ROS Answers: Open Source Q&amp;A Forum","tags":["编译","ros2","foxy"],"categories":["程序设计"]},{"title":"各种编译模式的区别","path":"//complile-mode.html","content":"debug调试版本，带有完整的调试信息（函数、变量符号表、文件路径、行号），加载速度慢，体积大，比较适合在开发阶段使用 release发布版本，几乎没有调试信息，加载速度快（通常带有代码优化），体积小，一般在发布阶段使用 release with debug informationVisual Studio特有的编译模式，会带有一点点调试符号，但并不是所有函数行的断点都可以命中，而且调试信息也不完善，程序体积比release略大","tags":["编译"],"categories":["程序设计"]},{"title":"Windows应用发布时禁止cmd窗口弹出","path":"//windows-forbid-cmd.html","content":"解决很简单，就是在Release模式下告诉编译器：这是一个win32的app就行了 1234567if(CMAKE_BUILD_TYPE AND (CMAKE_BUILD_TYPE STREQUAL &quot;Release&quot;)) set(FLAG &quot;WIN32&quot;)else() set(FLAG &quot;&quot;)endif()add_executable(zhd-desktop $&#123;FLAG&#125; main.cpp)","tags":["Windows","上位机","cmake","cmd","release"],"categories":["程序设计"]},{"title":"C++ string与QString中文字符转换关系","path":"//cpp-string-to-qstring.html","content":"1.从QString到std::string12std::string oldString = &quot;你好，hello world&quot;;QString newString = QString::fromLocal8Bit(oldString.c_str()) 2.从std::string到QString12QString oldString = &quot;你好，hello world&quot;;std::string newString = std::string((const char *)oldString.toLocal8Bit().constData()); 3.从std::string到char *12345678910111213141516171819202122char *wchar2char(const wchar_t* source)&#123; char * data; int len= WideCharToMultiByte( CP_ACP ,0,source ,wcslen( source ), nullptr,0, nullptr ,nullptr); data= new char[len+1]; WideCharToMultiByte( CP_ACP ,0,source ,wcslen( source ),data,len, nullptr ,nullptr); data[len]= &#x27;\\0&#x27;; return data;&#125;const char *stringToChar(const std::string&amp; str)&#123; std::wstring wstr = L&quot;&quot;; int len = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), str.size(), nullptr, 0); wchar_t* wchar = new wchar_t[len + 1]; MultiByteToWideChar(CP_UTF8, 0, str.c_str(), str.size(), wchar, len); wchar[len] = &#x27;\\0&#x27;; wstr.append(wchar); const char *data = wchar2char(wchar); delete[] wchar; return data;&#125;","tags":["C++","string","QString","中文字符"],"categories":["程序设计"]},{"title":"n阶行列式求解","path":"//n-det-calculation.html","content":"前言笔者最近在学习线性代数，写了一个求解n阶行列式的程序，拿出来给大家分享借鉴一下。 实现用递归的方法求解n阶行列式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126/*\t1.名字：\tdeterminant.c 2.功能：\t求解n阶行列式值 3.编者：\tHeavenMo &lt;1621326181@qq.com&gt; 4.时间：\t2015-10-2 22:42 5.叙述：\t递归法实现n阶行列式的求解 6.申明：\tWin 8.1 pro / GCC 4.8.1编译器亲测通过 7.结构： a)main函数部分完成行列式的输入操作 b)det函数完成行列式的值的返回 c)det函数中，将原来的n阶行列式不断的递归分解， 如，n阶矩阵分解为n个(n-1)阶余子矩阵，(n-1)阶分解成(n-1)个(n-2)阶余子矩阵， ...，以此类推 d)递归至2阶时，计算2阶行列式的值，并返回给上一层，...， 以此类推*///有关头文件的包含，因为要用到动态内存的分配，所以包含stdlib.h# include &lt;stdio.h&gt;# include &lt;stdlib.h&gt;//定制数据类型，方便修改typedef int data_type;typedef unsigned int uint;//计算n阶行列式的函数声明data_type det(data_type *p, uint n);int main(void)&#123;\t//n为行列式的阶数，i，n，m为非负值，所以定义为uint\tuint i, n, m;\t//提示输入行列式的阶数\tprintf(&quot;请输入行列式的阶数: &quot;);\tscanf(&quot;%u&quot;, &amp;n);\tm = n * n;\t//程序的关键所在，将n阶行列式看成是一个长度是n*n的一维数组，m为数组的长度\tdata_type *p = (data_type *)calloc(m, sizeof(data_type));\tprintf(&quot;请输入行列式的元素值: &quot;);\tfor(i = 0; i &lt; m; i++)\t&#123; scanf(&quot;%d&quot;, p + i);\t&#125;\tprintf(&quot; 所求行列式的值 = %d &quot;, det(p, n)); //释放相应的内存\tfree(p);\treturn 0;&#125;//p指向长度为n*n的数组，n为行列式的阶数data_type det(data_type *p, uint n)&#123;\t//n = 1时的情况\tif(n == 1)\t&#123; return *p;\t&#125;\t//递归基准\tif(n == 2)\t&#123; return ((*p) * (*(p + 3)) - (*(p + 1)) * (*(p + 2)));\t&#125;\t//m1:当前行列式的元素个数，m2：分解后的行列式的元素个数\tuint i, j, k, m1, m2;\tm1 = n * n;\tm2 = (n - 1) * (n - 1); //为分配后的n个n-1阶的行列式分配内存的基址\tdata_type *p_list[n];\tfor(i = 0; i &lt; n; i++)\t&#123; p_list[i] = (data_type *)calloc(m2, sizeof(data_type));\t&#125;\t//关键一步，筛选出代数余子矩阵，i(0 - n-1)：原矩阵可以分解为n个n-1阶代数余子矩阵\tfor(i = 0; i &lt; n; i++)\t&#123; //j = n意为筛选元素要从第二行开始，k变量统计代数余子矩阵的元素个数 for(j = n, k = 0; j &lt; m1; j++) &#123; //考察原矩阵与余子矩阵的关系，构造余子矩阵 if(j % n != i) &#123; *(p_list[i] + k) = *(p + j); k++; &#125; &#125;\t&#125; //根据递推公式求和，sign为代数余子式的符号，与行数(其实是第一行)，列数有关\tint sign = -1;\tdata_type sum = 0;\tfor(i = 0; i &lt; n; i++)\t&#123; sign *= -1; //调用函数，通过对第一行的各元素与相应的代数余子矩阵的行列式值之积求和，实现递归求值 sum += sign * (*(p + i)) * det(p_list[i], n - 1);\t&#125; //返回函数值\treturn sum;&#125; 运行附上cmd运行结果：","tags":["n阶行列式","线性代数","算法"],"categories":["学科"]},{"title":"cmake生成应用程序logo","path":"//cmake-app-logo.html","content":"logo.ico去专门的ico图标网站下载，也可以通过普通的图片转换：png-to-ico resource.rc这个用于指定要到的图片文件 1IDI_ICON1 ICON &quot;logo.ico&quot; CMakeLists.txt在cmake文件里边加上rc文件 1add_executable($&#123;PROJECT_NAME&#125; main.cpp resource.rc)","tags":["上位机","cmake","logo"],"categories":["开发工具"]},{"title":"cmake之find_library问题","path":"//cmake-find-library.html","content":"附上工程源码库文件工程PS：这个工程用于导出库 CMakeLists.txt 1234567891011121314cmake_minimum_required(VERSION 3.5)project(demo LANGUAGES CXX)set(CMAKE_INCLUDE_CURRENT_DIR ON)set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED ON)add_library(demo SHARED demo.cpp demo.h)target_compile_definitions(demo PRIVATE DEMO_LIBRARY) demo.h 123456789101112#ifndef DEMO_H#define DEMO_Hclass Demo&#123;public: Demo(); void Print();&#125;;#endif // DEMO_H demo.cpp 1234567891011#include &quot;demo.h&quot;#include &lt;iostream&gt;Demo::Demo()&#123;&#125;void Demo::Print()&#123; std::cout &lt;&lt; &quot;this is a demo&quot; &lt;&lt; std::endl;&#125; 主程序工程PS：这个工程用于链接demo库 CMakeLists.txt 1234567891011121314cmake_minimum_required(VERSION 3.5)project(find-library LANGUAGES CXX)set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED ON)include_directories($&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/inc)find_library(LIB_DEMO demo $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/lib)add_executable($&#123;PROJECT_NAME&#125; main.cpp)target_link_libraries($&#123;PROJECT_NAME&#125; $&#123;LIB_DEMO&#125;) main.cpp 1234567891011#include &lt;iostream&gt;#include &quot;demo.h&quot;using namespace std;int main()&#123; Demo d; d.Print(); return 0;&#125; 问题情形首先这两个工程在Linux下使用没有问题的，find-library工程编译正常，可以正确链接demo库；但是在Windows平台就死活不行了，find-library工程CMakeLists.txt第10行老是报错提示demo库找不到 12LIB_DEMO linked by target &quot;find-library&quot; in directory E:/workspace/daily-project/cpp/find-library 但明明是把demo工程生成的库拷贝到find-library工程的lib目录下了，为啥就是死活会报错？Windows难道对库文件的格式有要求？ 解决办法尝试把demo工程的CMakeLists.txt第9行SHARED改成STATIC，重新编译demo，再把生成的静态库文件demo.lib拷贝到find-library工程的lib目录下，重新编译该工程却出乎意料的成功了！但参考官网find_library的用法却没有得到解析 总结下次写跨平台编译的代码的时候记得在cmake上面配置生成不同类型的库（Windows平台生成两种库准没错）","tags":["Windows","cmake"],"categories":["开发工具"]},{"title":"cJson数据格式问题","path":"//cjson-file-format-problem.html","content":"问题描述Linux的换行符是 ，Windows的换行符是\\r ，在Linux系统下使用cJson库解析本地json文件没有问题，但如果把Windows的json文件拷贝到Linux下需要把\\r 给过滤掉，否则传入文件buffer就解析不出cJson对象！ 解决办法 一个简单的办法通过vim设置set ff=unix将文件改为Unix文件格式 通过c&#x2F;c++实现trim或者trimmed接口过滤掉首尾两端空白符","tags":["Windows","linux","cJson"],"categories":["程序设计"]},{"title":"QNX移植mongoose","path":"//qnx-port-mongoose.html","content":"移植方法MG_ARCH表示Unix架构，SSL可以开启，也可以不开启，需要链接m，c，socket几个库 12source ~/qnx700/qnxsdp-env.sh # 使用前先source一下工具链aarch64-unknown-nto-qnx7.0.0-gcc -D MG_ARCH=1 -D MG_ENABLE_SSL=1 main.c ../../mongoose.* -l../../ -lm -lc -lsocket -o example","tags":["服务器","QNX","mongoose","开源库"],"categories":["程序设计"]},{"title":"电气自动化专业英语词汇","path":"//professional-english.html","content":"前言电子信息、电气工程、自动化、半导体、计算机专业英语词汇汇总，不定期更新 常用 Asynchronous：异步 synchronous：同步 notification：通知 blade：平面 shaft：轴 magnetic：磁场的 bearing：轴承 valve：阀 heat sink：散热片 separated：分离的 excitation amp：激励放大器 Axial：轴的，轴向的 Supervisor：管理员 front：前面的 rear：后面的 sheet metal：钣金 constraints：约束 Radial sensor：径向传感器 Axial sensor：轴向传感器 Magnetic bearing ：磁悬浮轴承 Thermal：热的 earth terminals：接地端子 Electromagnetic Interference，EMI：电磁干扰 reentrant：可重入的 simultaneously：同时 specifications：产品规格、约束 anticipate：预料 consequences：后果 hazards：危害 warranty：保证 herein：请进 Outlet：出口 series：产品系列 outer：外面的 bending：弯曲 obstacles：障碍 rack：架子 screw：螺钉 Levitation：悬浮 电子电气 circuit：电路 Impedance：阻抗 inductance：电感 resistor：电阻 capacitance：电容 thermistor：热敏电阻 braker Resistor：制动电阻 cable：线缆 Leakage current：漏电流 Fuse：保险丝 Insulation：绝缘 reflection：反射率 threshold：阈值 acquisition：采集 resistance：电阻 capacitance：电容 inductance：电感 diode：二极管 LED：light-emitting diode，发光二极管 Bipolar Junction Transistor：三极管 Field Effect Transistor：场效应管 beam：光线，波束 magnet：磁体 Radio Frequency：RF，射频，表示可以辐射到空间的电磁频率，频率范围从300kHz～300GHz之间 Metal-Oxide-Semiconductor Field-Effect Transistor：MOSFET，金氧半场效晶体管 interlock：联锁，为人身安全和设备安全设计的安全联锁装置 laser：激光 自动化 motor：电机 pump：泵 BEMF (back electromotive force）：反电动势 GPIO：General-Purpose Input&#x2F;Output，通用输入输出 pwm：Pulse Width Modulation，脉冲宽度调制效应 adc：analog-to-digital converter，模数转换器 dac：Digital to Analog Converter，数字模拟转换器 SCI：Serial Communications Interface，串行通信接口 can：Controller Area Network，近场通信协议 fan：风扇 braker：制动器、刹车 OPC UA：open platform communication unified architecture，开放平台统一架构 IPC：industrial PC，工控机 PLC：Programmable Logic Controller，可编程逻辑控制器 displacement：位移 malfunction：故障 PoE：power over ethernet，以太网供电技术 计算机 computer：计算机 design pattern：设计模式 data structure：数据结构 algorithm：算法 operating system：操作系统： compiler principle：编译原理 database：数据库 milliseconds：毫秒 loop back：回环，数据回环 protocol：协议 MQTT：Message Queuing Telemetry Transport 算法和数据结构 array：数组 linked list：链表 stack：栈 queue：队列 binary tree：二叉树 hash：哈希 graph：图 string：字符串 set：集合 map：映射 generic programming：泛型编程 sort：排序 图形学 pipeline：管线 shader：着色器 texture：纹理 VBO：Vertex Buffer Object，顶点缓冲对象 VAO：Vertex Array Object，顶点数组对象 EBO：Element Buffer Object，元素索引对象 viewport：视口 vector：向量 matrix：矩阵 NDC：Normalized Device Coordinates，标准化设备坐标 local space：局部空间 world space：世界空间 view space：观察空间 clip space：裁剪空间 screen space：屏幕空间 euler angles：欧拉角，偏航角、俯仰角、滚转角 yaw：偏航角 pitch：俯仰角 roll：滚转角 Phong Lighting Model：冯氏光照模型 Ambient Lighting：环境光 Diffuse Lighting：漫反射光 Specular Lighting：镜面光 Normal Vector：法向量 Material：材质 机器人 trajectory：轨迹 local path planning：局部路径规划 global path planning：全局路径规划 costmap：代价地图 acml：adaptive Monte Carlo localization，自适应蒙特卡洛定位 自动驾驶 RTK：Real-time kinematic，实时动态测量 longitude：经度 latitude：纬度 altitude：高程、海拔高度 GNSS：Global Navigation Satellite System，全球导航卫星系统 Antenna：天线 LiDAR：Light Detection And Ranging，激光雷达 camera：相机 IMU：Inertial Measurement Unit，惯性测量单元 accelerometer：加速度计，缩写accel gyroscope：陀螺仪，缩写gyro Magnetometer：磁力计，缩写mag 半导体 wafer：晶圆 PVD：物理气相沉积 CVD：化学气相沉积 etch：刻蚀 Ion implantation：离子注入 vacuum：真空 Miscellaneous：掺杂 butterfly valve：蝶阀 Pneumatic valves：气动阀 molecular pump：分子泵 Vacuum Gauge：真空规、真空计 flowmeter：流量计 Special Gas：特气 Gas cabinet：特气柜 Radio Frequency power supply：射频电源 Vacuum manipulator：真空机械手 Wafer alignment：晶圆对准 Reactor：反应炉","tags":["English","电气自动化","专业英语"],"categories":["学科"]},{"title":"cmake获取指定目录下的所有文件","path":"//cmake-recurse-files.html","content":"需求编写跨平台的工程时，因为项目比较大，文件很多，开发人员很多，不想一一列举add_executable里边的文件 解决用FILE宏获取某个指定目录下的同一类型的所有文件，用DIAGNOSTIC和SERIALIZE两个变量来分别存储所有符合条件的文件名，include_directories也可以自动包含目录下的所有头文件 12345FILE(GLOB_RECURSE DIAGNOSTIC $&#123;CMAKE_SOURCE_DIR&#125;/diagnostic/*.c)include_directories($&#123;CMAKE_SOURCE_DIR&#125;/diagnostic)FILE(GLOB_RECURSE SERIALIZE $&#123;CMAKE_SOURCE_DIR&#125;/serialize/*.c)include_directories($&#123;CMAKE_SOURCE_DIR&#125;/serialize) 再在add_executable里边添加DIAGNOSTIC和SERIALIZE两个变量，这样新增文件只要执行一下cmake就可以了 1234567add_executable(zhd-desktop main.c $&#123;DIAGNOSTIC&#125; $&#123;SERIALIZE&#125; logo.rc res.qrc) 示例以下是一个动态添加源文件（SRC）、头文件（HEADERS）、资源文件（RES）的工程示例，cmake脚本一下子清爽了好多 1234567891011121314151617181920212223242526272829303132333435363738cmake_minimum_required(VERSION 3.5)project(tractor LANGUAGES CXX)set(CMAKE_INCLUDE_CURRENT_DIR ON)set(CMAKE_AUTOUIC ON)set(CMAKE_AUTOMOC ON)set(CMAKE_AUTORCC ON)set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED ON)find_package(Qt5 COMPONENTS Widgets REQUIRED)include_directories($&#123;CMAKE_SOURCE_DIR&#125;)set(SRC_DIR $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;)file(GLOB SRC &quot;$&#123;SRC_DIR&#125;/*.cpp&quot; &quot;$&#123;SRC_DIR&#125;/*.cxx&quot; &quot;$&#123;SRC_DIR&#125;/*.cc&quot; &quot;$&#123;SRC_DIR&#125;/*.c&quot;)file(GLOB HEADERS &quot;$&#123;SRC_DIR&#125;/*.h&quot; &quot;$&#123;SRC_DIR&#125;/*.hpp&quot; &quot;$&#123;SRC_DIR&#125;/*.hxx&quot;)file(GLOB RES &quot;$&#123;SRC_DIR&#125;/*.ui&quot; &quot;$&#123;SRC_DIR&#125;/*.qrc&quot;)add_executable($&#123;PROJECT_NAME&#125; $&#123;SRC&#125; $&#123;HEADERS&#125; $&#123;RES&#125;)target_link_libraries($&#123;PROJECT_NAME&#125; PRIVATE Qt5::Widgets) 总结 需要约定俗成的编码规范：比如源文件放哪里、头文件放哪里、资源文件放哪里 每次删减文件都需要执行一下cmake file函数可以实现递归式检索，但一般一级目录就够了 需要递归检索用GLOB_RECURSE，只需要当前目录用GLOB，前者不能将构建目录放在递归检索目录！","tags":["cmake"],"categories":["开发工具"]},{"title":"与NXP的一点缘分","path":"//nxp-stuff.html","content":"介绍NXP是老牌的芯片巨头，做汽车电子的人尤为熟悉，比如它的LPC系列、S32K系列、imx系列；我的老东家周立功就是靠NXP的代理权发家致富的；去年接触（白嫖）NXP的MCU方案比较多，特别是FRDM这个开发板系列，给RT-Thread贡献了开源文档、教程以及多个PR 开发板MCXN947这个板子的资源比较丰富，最大亮点是集成了神经处理单元 MCXA153资源比947稍微少一些，没有CAN和ETH，是中规中矩的MCU MCXW71专为无线连接设计的板子，支持Matter、Thread、Zigbee和BLE的多协议无线子系统，我已经给它移植了RT-Thread系统 礼品参与NXP相关的活动，收到的一些礼物 机械键盘参加947的测评活动送的一份沉甸甸的礼物：RT-Thread定制版机械键盘 发光鼠标垫这个可以发光，颜色会变化，超大的垫子 充电宝这个是新年收到的礼物，20000mAh的充电宝，以后户外调试开发板就不愁没有电源了！","tags":["NXP","blog"],"categories":["嵌入式"]},{"title":"网络数据Hex格式转换","path":"//qt-string-to-hex.html","content":"前言Qt中TCP通信一般用QByteArray作为数据传输对象，使用Hex格式的情形要考虑一下变换，否则服务器和客户端的数据长度对不上 发送字符串本身就是hex格式，需要转成QByteArray格式进行传输 123QString hex = &quot;03000010560155aa010023000000d750&quot;;QByteArray data = QByteArray::fromHex(hex.toLatin1());m_socket-&gt;write(data); 接收QByteArray转为hex格式 12QString hex = m_socket-&gt;readAll().toHex();qDebug() &lt;&lt; hex;","tags":["Qt","hex"],"categories":["程序设计"]},{"title":"一个简单的Windows TCP服务器实现","path":"//winsock2-server.html","content":"需要使用到winsock2这个库 12#include &lt;winsock2.h&gt;#include &lt;stdio.h&gt; 需要链接的库文件 1ws2_32.lib winsocket初始化 123456789WSADATA wsaData;SOCKET serverSocket, clientSocket;struct sockaddr_in serverAddr = &#123; 0x00 &#125;;struct sockaddr_in clientAddr = &#123; 0x00 &#125;;int clientAddrLen = sizeof(clientAddr);if (WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0) &#123; printf(&quot;WSAStartup failed. &quot;);&#125; 创建winsocket 1234if ((serverSocket = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET) &#123; printf(&quot;Socket failed. &quot;); WSACleanup();&#125; IP及端口号配置 123456789serverAddr.sin_family = AF_INET;serverAddr.sin_addr.s_addr = INADDR_ANY;serverAddr.sin_port = htons(9988);if (bind(serverSocket, (struct sockaddr*)&amp;serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) &#123; printf(&quot;Bind failed. &quot;) closesocket(serverSocket); WSACleanup();&#125; 监听客户端连接 12345if (listen(serverSocket, 5) == SOCKET_ERROR) &#123; printf(&quot;Listen failed. &quot;); closesocket(serverSocket); WSACleanup();&#125; 接受客户端连接 12345if ((clientSocket = accept(serverSocket, (struct sockaddr*)&amp;clientAddr, &amp;clientAddrLen)) == INVALID_SOCKET) &#123; printf(&quot;Accept failed. &quot;); closesocket(serverSocket); WSACleanup();&#125; 接收数据 1int bytesReceived = recv(clientSocket, (char*)(_sRxBuffer + _sRxLenght), BUFFER_SIZE, 0); 发送数据 1int txPacketlenght = send(socket, (const char*)_sTxBuffer, txPacketlenght, 0); 回收winsocket资源 123closesocket(clientSocket);closesocket(serverSocket);WSACleanup(); 检查连接断开情形 1234567891011int bytesReceived = recv(clientSocket, buffer, bufferSize, 0);if (bytesReceived == 0) &#123; printf(&quot;Client socket disconnected gracefully. &quot;);&#125; else if (bytesReceived == SOCKET_ERROR) &#123; int error = WSAGetLastError(); if (error == WSAECONNRESET) &#123; printf(&quot;Client socket disconnected unexpectedly. &quot;); &#125; else &#123; printf(&quot;Recv failed with error: %d &quot;, error); &#125;&#125;","tags":["Windows","服务器","tcp"],"categories":["程序设计"]},{"title":"Windows常用快捷键集合","path":"//windows-common-shortcuts.html","content":"介绍工欲善其事必先利其器，用对工具往往事半功倍 快捷键 打开运行对话框：win + R 打开Windows粘贴板：win + V 打开Home菜单：win + X 打开搜索对话框：win + S 截图：win + Shift + S 打开控制面板：win + I 在某个文件路径迅速打开cmd命令行：Ctrl + L，输入cmd即可 拓展屏幕配置：win + P 光标聚焦任务栏：win + T 光标聚焦状态栏：win + B 所有窗口最小化：win + M 所有窗口最小化（可恢复）：win + D 锁屏：win + L Windows防火墙：win + R后输入filewall.cpl 运行任务栏的程序：win + 1，2，3，4对应从左到右的程序序号 打开Windows通知面板：win + A 唤醒画画及截屏功能：win + W 切换虚拟桌面：CTRL + win + ⬅ 、➡ 预览管理桌面：win + Tab","tags":["Windows","快捷键"],"categories":["开发工具"]},{"title":"Qt Enter和HoverEnter事件","path":"//qt-enter-hoverenter.html","content":"介绍做PC开发的过程中或多或少都会接触到鼠标的悬停事件，Qt中处理鼠标悬停有Enter和HoverEnter两种事件 相同点 QEvent::Enter对应QEnterEvent，描述的是鼠标进入控件坐标范围之内的行为，QEnterEvent可以抓取鼠标的位置 QEvent::HoverEnter对应QHoverEvent，控件开启Qt::WA_Hover属性可以达到Enter事件一样的效果，QHoverEvent同样可以抓取鼠标的位置 不同点QHoverEvent附带有QEvent::Paint重绘行为，QEnterEvent没有触发控件本身的重绘的能力，请按照具体的场景区别使用","tags":["Qt","鼠标事件"],"categories":["程序设计"]},{"title":"Qt TCP通信案例","path":"//qt-tcp-communication-example.html","content":"服务器使用前要在cmake工程文件里边添加network模块 123find_package(Qt5 COMPONENTS core network REQUIRED)target_link_libraries($&#123;PROJECT_NAME&#125; Qt5::Core Qt5::Network) TCP通信服务器的核心类是QTcpServer，头文件同名 1#include &lt;QTcpServer&gt; 使用也特别简单，先绑定IP地址和端口号，listen的返回结果如果是false则端口号有可能被占用，Windows上建议用netstat -aon | findstr &quot;9090&quot;事先看一下端口占用情况，Linux下则是用netstat -tlp | grep 9090 12QTcpServer server;bool ret = server.listen(QHostAddress(&quot;127.0.0.1&quot;), 9090); 编写newConnection信号对应的槽函数，服务器通过nextPendingConnection接口获取已建立的socket，然后对socket进行读写 1234567891011QObject::connect(&amp;server, &amp;QTcpServer::newConnection, [&amp;]() &#123; auto &amp;&amp;socket = server.nextPendingConnection(); auto timer = new QTimer(); QObject::connect(timer, &amp;QTimer::timeout, [&amp;, socket]() &#123; socket-&gt;write(QByteArray(&quot;hello world&quot;)); &#125;); timer-&gt;start(1000); QObject::connect(socket, &amp;QTcpSocket::readyRead, [&amp;, socket]() &#123; qDebug() &lt;&lt; &quot;Server : &quot; &lt;&lt; socket-&gt;readAll(); &#125;);&#125;); 客户端客户端同理，使用前也要在cmake工程文件里边添加network模块 123find_package(Qt5 COMPONENTS core network REQUIRED)target_link_libraries($&#123;PROJECT_NAME&#125; Qt5::Core Qt5::Network) 客户端使用QTcpSocket进行TCP通信 1#include &lt;QTcpSocket&gt; 调用connectToHost接口建立服务器通信连接 12QTcpSocket socket;socket.connectToHost(QHostAddress(&quot;127.0.0.1&quot;), 9090); 需要处理几个跟连接相关的信号：connected、disconnected、readyRead 12345678910111213// connected表示连接已建立QObject::connect(&amp;socket, &amp;QTcpSocket::connected, [&amp;]() &#123; timer-&gt;start(1000); qDebug() &lt;&lt; &quot;Client connected server&quot;;&#125;);// disconnected表示连接已断开QObject::connect(&amp;socket, &amp;QTcpSocket::disconnected, [&amp;]() &#123; qDebug() &lt;&lt; &quot;Client disconnected server&quot;;&#125;);// readyRead表示缓冲区有数据可读QObject::connect(&amp;socket, &amp;QTcpSocket::readyRead, [&amp;]() &#123; qDebug() &lt;&lt; &quot;Client : &quot; &lt;&lt; socket.readAll();&#125;); 基类QIODevice的读写接口 12345678910qint64 read(char *data, qint64 maxlen);QByteArray read(qint64 maxlen);QByteArray readAll();qint64 readLine(char *data, qint64 maxlen);QByteArray readLine(qint64 maxlen = 0);qint64 write(const char *data, qint64 len);qint64 write(const char *data);inline qint64 write(const QByteArray &amp;data)&#123; return write(data.constData(), data.size()); &#125; 结果 以上的服务器和客户端在互相给对方发hello world数据 QTcpServer那里巧妙抽象了QTcpSocket的操作方式，客户端和服务器都是对QTcpSocket读写","tags":["Qt","TCP","服务器","客户端"],"categories":["程序设计"]},{"title":"uboot剖析之命令行延时","path":"//uboot-bootdelay.html","content":"在configs/rk3506_defconfig文件中可以配置启动延时选项 1CONFIG_BOOTDELAY=3 common&#x2F;main.c –&gt; main_loop：bootdelay_process处理delay延时值解析，按键捕获由autoboot_command负责 123456789101112131415161718192021222324252627void main_loop(void)&#123; const char *s; bootstage_mark_name(BOOTSTAGE_ID_MAIN_LOOP, &quot;main_loop&quot;);#ifdef CONFIG_VERSION_VARIABLE env_set(&quot;ver&quot;, version_string); /* set version variable */#endif /* CONFIG_VERSION_VARIABLE */ cli_init(); run_preboot_environment_command();#if defined(CONFIG_UPDATE_TFTP) update_tftp(0UL, NULL, NULL);#endif /* CONFIG_UPDATE_TFTP */ s = bootdelay_process(); if (cli_process_fdt(&amp;s)) cli_secure_boot_cmd(s); autoboot_command(s); cli_loop(); panic(&quot;No CLI available&quot;);&#125; common&#x2F;autoboot.c –&gt; bootdelay_process：要么从环境变量bootdelay里边获取，要么就从CONFIG_BOOTDELAY里边获取，最后更新stored_bootdelay 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const char *bootdelay_process(void)&#123; char *s; int bootdelay;#ifdef CONFIG_BOOTCOUNT_LIMIT unsigned long bootcount = 0; unsigned long bootlimit = 0;#endif /* CONFIG_BOOTCOUNT_LIMIT */#ifdef CONFIG_BOOTCOUNT_LIMIT bootcount = bootcount_load(); bootcount++; bootcount_store(bootcount); env_set_ulong(&quot;bootcount&quot;, bootcount); bootlimit = env_get_ulong(&quot;bootlimit&quot;, 10, 0);#endif /* CONFIG_BOOTCOUNT_LIMIT */ s = env_get(&quot;bootdelay&quot;); bootdelay = s ? (int)simple_strtol(s, NULL, 10) : CONFIG_BOOTDELAY;#ifdef CONFIG_OF_CONTROL bootdelay = fdtdec_get_config_int(gd-&gt;fdt_blob, &quot;bootdelay&quot;, bootdelay);#endif debug(&quot;### main_loop entered: bootdelay=%d &quot;, bootdelay);#if defined(CONFIG_MENU_SHOW) bootdelay = menu_show(bootdelay);#endif bootretry_init_cmd_timeout();#ifdef CONFIG_POST if (gd-&gt;flags &amp; GD_FLG_POSTFAIL) &#123; s = env_get(&quot;failbootcmd&quot;); &#125; else#endif /* CONFIG_POST */#ifdef CONFIG_BOOTCOUNT_LIMIT if (bootlimit &amp;&amp; (bootcount &gt; bootlimit)) &#123; printf(&quot;Warning: Bootlimit (%u) exceeded. Using altbootcmd. &quot;, (unsigned)bootlimit); s = env_get(&quot;altbootcmd&quot;); &#125; else#endif /* CONFIG_BOOTCOUNT_LIMIT */ s = env_get(&quot;bootcmd&quot;); process_fdt_options(gd-&gt;fdt_blob); stored_bootdelay = bootdelay; return s;&#125; common&#x2F;autoboot.c –&gt; autoboot_command：在执行启动命令run_command_list前先检查stored_bootdelay值 12345678910111213141516171819202122232425void autoboot_command(const char *s)&#123; debug(&quot;### main_loop: bootcmd=\\&quot;%s\\&quot; &quot;, s ? s : &quot;&lt;UNDEFINED&gt;&quot;); if (stored_bootdelay != -1 &amp;&amp; s &amp;&amp; !abortboot(stored_bootdelay)) &#123;#if defined(CONFIG_AUTOBOOT_KEYED) &amp;&amp; !defined(CONFIG_AUTOBOOT_KEYED_CTRLC) int prev = disable_ctrlc(1); /* disable Control C checking */#endif run_command_list(s, -1, 0); autoboot_command_fail_handle();#if defined(CONFIG_AUTOBOOT_KEYED) &amp;&amp; !defined(CONFIG_AUTOBOOT_KEYED_CTRLC) disable_ctrlc(prev); /* restore Control C checking */#endif &#125;#ifdef CONFIG_MENUKEY if (menukey == CONFIG_MENUKEY) &#123; s = env_get(&quot;menucmd&quot;); if (s) run_command_list(s, -1, 0); &#125;#endif /* CONFIG_MENUKEY */&#125; common&#x2F;autoboot.c –&gt; abortboot：真正的功能实现在__abortboot 1234567891011121314static int abortboot(int bootdelay)&#123; int abort = 0; if (bootdelay &gt;= 0) abort = __abortboot(bootdelay);#ifdef CONFIG_SILENT_CONSOLE if (abort) gd-&gt;flags &amp;= ~GD_FLG_SILENT;#endif return abort;&#125; common&#x2F;autoboot.c –&gt; __abortboot：bootdelay延时计数 + 等待按键ctrl+c输入 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static int __abortboot(int bootdelay)&#123; int abort = 0; unsigned long ts;#ifdef CONFIG_MENUPROMPT printf(CONFIG_MENUPROMPT);#else printf(&quot;Hit key to stop autoboot(&#x27;CTRL+C&#x27;): %2d &quot;, bootdelay);#endif#ifdef CONFIG_ARCH_ROCKCHIP if (!IS_ENABLED(CONFIG_CONSOLE_DISABLE_CLI) &amp;&amp; ctrlc()) &#123; /* we press ctrl+c ? */#else /* * Check if key already pressed */ if (tstc()) &#123; /* we got a key press */#endif (void) getc(); /* consume input */ puts(&quot;\\b\\b\\b 0&quot;); abort = 1; /* don&#x27;t auto boot */ &#125; while ((bootdelay &gt; 0) &amp;&amp; (!abort)) &#123; --bootdelay; /* delay 1000 ms */ ts = get_timer(0); do &#123; if (ctrlc()) &#123; /* we got a ctrl+c key press */ abort = 1; /* don&#x27;t auto boot */ bootdelay = 0; /* no more delay */# ifdef CONFIG_MENUKEY menukey = 0x03; /* ctrl+c key code */# endif break; &#125; udelay(10000); &#125; while (!abort &amp;&amp; get_timer(ts) &lt; 1000); printf(&quot;\\b\\b\\b%2d &quot;, bootdelay); &#125; putc(&#x27; &#x27;); return abort;&#125; 如果不小心把启动延时设置为0，需要手动设置bootdelay的值才可以进入uboot配置菜单","tags":["串口","uboot","rk3506","控制台"],"categories":["嵌入式"]},{"title":"Qt按钮美化教程","path":"//qt-button-design.html","content":"前言Qt按钮美化主要有三种方式：QSS、属性和自绘 QPushButtonQSS字体大小 1font-size: 18px; 文字颜色 1color: white; 背景颜色 1background-color: rgb(10,88,163); 按钮边框 1border: 2px solid rgb(114,188,51); 文字对齐 1text-align: left; 左侧内边距 1padding-left: 10px; 文字加粗 1font-weight: bold; 边框的大小 1border-width: 4px; 边框的半径 1border-radius: 3px; 整合样式 123456789101112131415QPushButton &#123; font-size: 18px; /* 设置字体大小 */ color: white; /* 设置字体颜色 */ background-color: rgb(10,88,163); /* 设置背景颜色 */ border: 2px solid rgb(114,188,51); /* 设置边框 */ text-align: left; /* 文字左对齐 */ padding-left: 10px; /* 左侧内边距 */ font-weight: bold;&#125;QPushButton:pressed &#123; background-color: rgb(41,51,57); color: rgb(114,188,51); /* 设置字体颜色 */ border-width: 4px;&#125; 属性添加hover tooltip 修改text 焦点策略，一般默认StrongFocus 坐标和大小 自绘重写paintEvent虚函数，这个一般用的不多 12345678CPushButton::paintEvent(QPaintEvent *event)&#123; /* 这里增加自绘的代码：文字、图片等等 */ QPainter p(this); p.drawText(10, 10, &quot;Clicked me&quot;); p.drawPixmap(20, 10, QIcon(&quot;:/res/button.png&quot;)); QPushButton::paintEvent(event);&#125; 效果附上QSS+属性美化后的button效果（自己写的，你嫌丑我还嫌丑哩） QToolButton有时候需要定制图片跟文字同时显示的按钮（在触摸屏用的比较多），QToolButton是一个不错的选择 QSS添加底图 1qproperty-icon: url(:/resource/home.png) center; 底图大小设置 1qproperty-iconSize: 32px 32px; 聚焦时显示激活效果 1234QToolButton::focus&#123;\tbackground-image: url(:/resource/menu-active.png);&#125; 属性改变图片和文字的相对位置 在平板上面操作的话焦点策略改为ClickFocus 自绘QToolButton如无意外，不需要自绘 效果显示效果","tags":["Qt","button"],"categories":["程序设计"]},{"title":"Qt6串口数据协议解析","path":"//qt6-serial-protocol.html","content":"介绍绑定QSerialPort对象的readyRead信号时，从串口接收缓冲区读取的数据大概率不是一次就能接收完成的，有可能分成n次接收；这是一种什么情况呢，它有可能多次readyRead：1次，2次，3次，4次……这样子！如果不对数据的边界进行有效识别，就很难分别出哪些是我们要的数据 定长协议比如接收够15个字节才算接收完成，可以用QSerialPort::bytesAvailable这个接口进行组包，理论上给出头部标记就能识别有效的一帧数据：$ 10 0123456789 CS 1234567891011121314151617181920212223242526#define MAX_SIZE 15QByteArray buffer;int size = 0;auto callback = [&amp;]() &#123; auto &amp;&amp;data = this-&gt;readData(); if(data.startsWith(&quot;$&quot;)) &#123; size = m_serial-&gt;bytesAvailable(); buffer.clear(); buffer += data; if(size == MAX_SIZE) &#123; size = 0; emit this-&gt;sendOneFrame(buffer); &#125; &#125; else &#123; size += m_serial-&gt;bytesAvailable(); buffer += data; if(size == MAX_SIZE) &#123; size = 0; emit this-&gt;sendOneFrame(buffer); &#125; &#125;&#125;;connect(m_serial, &amp;QSerialPort::readyRead, this, callback); 不定长协议这个需要识别数据的边界（头部跟尾部）在哪里，比如用$头部，@做尾部，我们把分段的数据依次拼接起来 12345678910111213141516171819202122232425QByteArray buffer;auto callback = [&amp;]() &#123; qDebug() &lt;&lt; m_serial-&gt;bytesAvailable(); auto &amp;&amp;data = this-&gt;readData(); if(data.startsWith(&quot;$&quot;)) &#123; buffer.clear(); buffer += data; if(data.endsWith(&quot;@&quot;)) &#123; emit this-&gt;sendOneFrame(buffer); &#125; qDebug() &lt;&lt; &quot;1 : &quot; &lt;&lt; buffer; &#125; else &#123; if(!data.endsWith(&quot;@&quot;)) &#123; buffer += data; qDebug() &lt;&lt; &quot;2 : &quot; &lt;&lt; buffer; &#125; else &#123; buffer += data; qDebug() &lt;&lt; &quot;3 : &quot; &lt;&lt; buffer; emit this-&gt;sendOneFrame(buffer); &#125; &#125;&#125;;connect(m_serial, &amp;QSerialPort::readyRead, this, callback); 总结串口数据解析本质是一个文本处理的过程，如果接收端用C语言写，简单的协议还好，复杂的协议简直要命（请用高级语言）！","tags":["Qt","serial","串口"],"categories":["程序设计"]},{"title":"vim轻度使用指南","path":"//vim-light-usage.html","content":"介绍vim是一款运行在命令行的文本编辑器，它的功能很强大，可完全依靠键盘进行编辑操作，它是vi编辑器的增强版本；其实vi是自带的版本，不过功能弱了点，ARM Linux通常会预装vi而不是vim 安装以Ubuntu系统为例，安装配置vim工具 1sudo apt install vim 完全删除卸载 1sudo apt remove --purge vim 编辑文件 12345678910# 直接打开编辑器vim# 打开文件（不存在的也可以）vim demo.txt# 定位到文件的第十行vim demo.txt +10# 打开两个文件，水平视图并列展示vim a.txt b.txt -O# 打开两个文件，垂直视图并列展示vim a.txt b.txt -o 配置文件 1~/.vimrc 配置vim的配置几天几夜都讲不完，只能挑选一些基本、常用的 开启行号：set nu 高亮行：set cul 高亮列：set cuc 高亮搜索关键字：set hls 绑定Esc快捷键：inoremap jj &lt;Esc&gt; tab大小配置：set ts&#x3D;4 命令行以下是在命令行模式下的一些命令和快捷操作： 命令行模式按i、I、a、A可以进入编辑模式 编辑模式下按Esc进入命令行模式 在命令行模式用/关键字向下搜索，?关键字向上搜索 命令行模式用vs垂直分割窗口、sp水平分割窗口 在分割窗口之间移动：先按CTRL + W再按H、L 替换：s/替换前字符/替换后字符/g 命令行模式保存：w 命令行模式退出：q 命令行模式保存并退出：wq 命令行模式强制退出：q! 复制行：yy 删除剪切行：dd 粘贴：p 光标移动 上：k 下：j 左：h 右：l 行末：$ 行首：^ 快捷键 退出当前窗口：CTRL + W + Q 多视图模式切换当前窗口：Ctrl + W","tags":["linux","vim"],"categories":["开发工具"]},{"title":"Git工具的使用","path":"//git-usage.html","content":"介绍会不会使用Git已经是区别一个是否现代化、有没有参与过大型项目的标志了 基本使用先从远程仓库拉新代码（万事先fetch） 1git fetch 在当前分支基础上新建一个分支 1git checkout -b qml 下载远程仓库的更新 1git pull 查看本地修改了哪些文件 1git status -s 添加文件到暂存区 1git add file1 file2 file3 删除不需要的文件 1git rm -r file dir/ 写入提交日志 1git commit -m &quot;这是一段日志&quot; -a 提交到远程仓库 1git push -f origin main 提交一个新的分支到远程仓库 1git push --set-upstream origin qml 缓存修改（工作区和暂存区） 1git stash push -u xxx 将暂存修改同步回来 1git stash pop 自动化集成使用脚本自动化提交（这个对Github Pages非常有帮助） 1234git add .current_time=$(date &quot;+%Y-%m-%d %H:%M:%S&quot;)git commit -m &quot;$current_time -&gt; docs updated!&quot; -agit push 开源项目冲突管理：以解决一次RT-Thread的冲突为例讲解怎么解决开源项目代码冲突问题 ① 进入代码仓库所在目录 1cd REPOSITORY ② 合并分支改动 1git merge origin develop --no-ff ③ 查看冲突文件 1git status -s ④ 解决冲突，可以使用文本编辑器手动编辑，一般冲突以&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD开头，以&gt;&gt;&gt;&gt;&gt;&gt;&gt; BRANCH-NAME结尾，以=======为分隔符 123456789101112&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADtag: bsp_stm32h723-st-nucleopath: bsp/stm32/stm32h723-st-nucleoowners: 下里巴人(hywing)&lt;hywing.sir@qq.com&gt;tag: bsp_stm32g030-tiny-boardpath: bsp/stm32/stm32g030-tiny-boardowners: 下里巴人(hywing)&lt;hywing.sir@qq.com&gt;=======path: bsp/stm32owners: Liya Huang(wdfk-prog)&lt;1425075683@qq.com&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BRANCH-NAME ⑤ 编辑冲突文件，跟别人冲突的地方解决掉（去掉冲突标志开头、结尾和中间分隔符，现实中最好跟冲突方商量一下） 12345678910path: bsp/stm32owners: Liya Huang(wdfk-prog)&lt;1425075683@qq.com&gt;tag: bsp_stm32h723-st-nucleopath: bsp/stm32/stm32h723-st-nucleoowners: 下里巴人(hywing)&lt;hywing.sir@qq.com&gt;tag: bsp_stm32g030-tiny-boardpath: bsp/stm32/stm32g030-tiny-boardowners: 下里巴人(hywing)&lt;hywing.sir@qq.com&gt; ⑥ 重新提交代码 123git add .git commit -m &quot;Resolve merge conflict&quot;git push maintainer","tags":["git"],"categories":["开发工具"]},{"title":"MDK Keil5快捷键","path":"//mdk-keil5-shortcut.html","content":"常见快捷键合集 开始&#x2F;停止调试：CTRL + F5 运行：F5 单步进入：F11 单步跳出：CTRL + F11 单步：F10 执行到指定位置：CTRL + F10 检索：CTRL + F 插入或者移除断点：F9 移除所有断点：CTRL + Shift + F9 烧录程序：F8 编译当前文件：CTRL + F7 构建当前工程：F7 打开工程配置：Alt + F7 跳到指定行：CTRL + G 剪切当前行：CTRL + L 前进：CTRL + Shift + - 后退：CTRL + -","tags":["keil","快捷键"],"categories":["开发工具"]},{"title":"一个比较理想的嵌入式产品模型","path":"//ideal-embedded-product-model.html","content":"介绍示波器是一个比较典型、通用、明确的嵌入式产品案例，工作这么多年，很多产品业务模型或多或少都跟示波器的开发有点像！我敢说以下列举的软件、硬件、机械的部分在很多嵌入式产品中（不管是医疗、自动化还是汽车电子）普遍存在，所以我觉得自己经常在做示波器的类似物 软件嵌入式软件的复杂度大概在40-50w代码量左右 数据采集：电压、can、温度信号 数据可视化：主要是波形、报文的展示 文件存储：把数据文件录制下来，方便回读分析 HMI用户界面交互：按键、飞梭、旋钮、触摸屏 指令控制：SCPI指令控制设备，完成自动化测量功能 设备校准：一些标定校准的数据文件、抑制设备老化带来的参数漂移 设备驱动：按键板驱动、触摸屏驱动、usb驱动、pcie驱动、数据采集&#x2F;控制驱动 软件升级：自升级 + 外设升级 上位机上位机主要是解析波形文件、指令控制、校准维护、外设升级等功能 web设备调参、诊断使用、OTA升级 操作系统裸机、RTOS、Linux、Windows（配套上位机） 硬件硬件的组成按数字芯片分类有以下几个部分 fpgafpga主要负责前端数据的采集、预处理 armarm是嵌入式软件运行的载体 dsp集成波形处理的算法，这个是算法的载体 mcu按键板、采集卡里边的芯片、电源管理芯片 x64x64是终端软件运行的载体、软件升级工具 机械机械部件比较中规中矩，如探头、机箱外壳、显示屏部件、按键部件、采集卡的外壳 总结综上，示波器是一个终极的嵌入式产品案例，业务模型通常都具有相似性，只要深入了解一个，便可以举一反三","tags":["产品","嵌入式"],"categories":["方法论"]},{"title":"上位机和下位机的基本通信协议","path":"//upper-computer-lower-computer-communication-protocol.html","content":"介绍上位机和下位机的通信方式多种多样，一般有usart、can、usb、ethernet等，走什么通信方式视下位机的设备资源而定；以ethernet tcp通信为例，大部分情形下，下位机即嵌入式设备作为server端，PC端作为client端；嵌入式设备需要默认一个IP地址，比如192.168.137.22，还要有一个端口号，比如8738 帧格式帧格式的设计应包含四个部分：帧头 + 长度 + 数据段 + 校验 帧头：两个字节，例如固定为0xaa 0x55 长度：uint16，大端，整个包的长度，包含帧头、长度、数据段和校验四个部分的总长 度。单个包的最大长度为512 数据段：包荷载的内容，长度不固定 校验：两个字节，帧头、长度和数据段的CRC16计算值，当然也可以用异或校验 心跳包心跳包设计原则： 最好仅支持一个设备连接 客户端请求，服务器应答 约定一个心跳时间，如30秒进行一次心跳查询；还要一个超时时间，如300秒没有任何应答则视为连接已经断开 请求请求报文格式参考：协议码 + 消息类型 + 功能码 + 序号 + 功能数据 应答应答报文格式参考：协议码 + 消息类型 + 功能码 + 序号 + 错误码 + 功能数据 总结以上请求和应答设计范例其实是一种web服务的思想","tags":["通信协议","上位机","下位机"],"categories":["程序设计"]},{"title":"tar命令","path":"//tar-common-usage.html","content":"查看压缩包比如想看看rootfs.tar里边有什么东西，避免解压有坑 12tar -tf rootfs.tartar tf rootfs.tar.xz 解压默认全部解压，当然参数部分也可以带压缩包类型：J表示xz、j表示bz2、z表示gz 1tar xf demo.tar.xx tar创建默认tar包 1tar -cf archive.tar foo bar xzxz文件压缩 1tar cJf rootfs.tar.xz rootfs/ bz2bz2文件压缩 1tar cjf rootfs.tar.bz2 rootfs/ gzgz文件压缩 1tar czf rootfs.tar.gz rootfs/","tags":["linux","tar"],"categories":["开发工具"]},{"title":"编程中的同步和异步概念","path":"//program-synchronization-asynchronous.html","content":"普通理解同步，即同时进行、一起做，比如：一边开会，一边做笔记，这两件事就是同步进行的 异步，跟同步相反，做事的时间顺序不一致，比如：常见的电影声音和字幕不一致 编程概念同步一个函数如果在调用的时候随即能拿到结果并返回，这就是同步，比如：调用一个LedOn()函数，Led灯就会马上亮起来、函数退出；一般，单线程的环境应用比较多，因为只有一条时间线，干不了很多的活，这是比较好理解的 异步异步调用一般出现在多线程或者中断情景下，有一些事情需要分给不同的任务做，而你又无法准确把握别的任务什么时候完成（它可能不知道干嘛去了），你不想等它，所以只能设置一个回调接口callback来让它告知你，这跟现实世界很像，你打电话给外卖小哥，外卖小哥说他没有空在送别的外卖，让你留个电话号码，等出单或者到了再告诉你，而你又可以不用一直等这个外卖了（忙别的事情），明显你和外卖小哥是活在不同时间线的，双方都很自由；大部分事件处理都是异步调用来的，像按键中断，只有按键值输入的时候你才需要做按键事件处理；还有倍福ADS接口：客户端注册一个回调函数，当事件发生时，ADS库会自动调用该函数，当目标变量（如PLC中的某个变量）的值发生变化时，ADS服务器会主动通知客户端 总结 编程其实是对现实生活的抽象 业务模型也具有普适性，不管物联网、自动化、还是汽车电子","tags":["反思","同步","异步"],"categories":["程序设计"]},{"title":"vscode支持ros2程序debug","path":"//vscode-ros2-debug.html","content":"安装下载 1wget https://az764295.vo.msecnd.net/stable/1a5daa3a0231a0fbba4f14db7ec463cf99d7768e/code_1.84.2-1699528352_amd64.deb 安装 1sudo dpkg -i code_1.84.2-1699528352_amd64.deb 打开 1code . 插件在打开ros2工程前需要安装几个插件 CMake CMake Tools Python Ros XML Tools 配置c_cpp_properties.json这个文件用于配置编译条件，我这里用的是foxy版本的ros2，其他版本可以参考着改 1234567891011121314151617&#123; &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Linux&quot;, &quot;includePath&quot;: [ &quot;$&#123;workspaceFolder&#125;/**&quot;, &quot;/opt/ros/foxy/include/**&quot; ], &quot;defines&quot;: [], &quot;compilerPath&quot;: &quot;/usr/bin/gcc&quot;, &quot;cStandard&quot;: &quot;c99&quot;, &quot;cppStandard&quot;: &quot;c++14&quot;, &quot;intelliSenseMode&quot;: &quot;clang-x64&quot; &#125; ], &quot;version&quot;: 4&#125; launch.json这个文件用于启动ros2 package，target选项用于配置package运行脚本，一般用相对位置比较合适 123456789101112131415&#123; // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;ROS: Launch&quot;, &quot;type&quot;: &quot;ros&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;target&quot;: &quot;./install/aglidar_sdk/share/aglidar_sdk/launch/start.py&quot; &#125; ]&#125; settings.jsonvscode的基本配置，关联一些cpp的库、其它文件类型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&#123; &quot;editor.tabSize&quot;: 8, &quot;editor.rulers&quot;: [ 100 ], &quot;files.associations&quot;: &#123; &quot;*.repos&quot;: &quot;yaml&quot;, &quot;*.world&quot;: &quot;xml&quot;, &quot;*.xacro&quot;: &quot;xml&quot;, &quot;chrono&quot;: &quot;cpp&quot;, &quot;cctype&quot;: &quot;cpp&quot;, &quot;clocale&quot;: &quot;cpp&quot;, &quot;cmath&quot;: &quot;cpp&quot;, &quot;csignal&quot;: &quot;cpp&quot;, &quot;cstdarg&quot;: &quot;cpp&quot;, &quot;cstddef&quot;: &quot;cpp&quot;, &quot;cstdio&quot;: &quot;cpp&quot;, &quot;cstdlib&quot;: &quot;cpp&quot;, &quot;cstring&quot;: &quot;cpp&quot;, &quot;ctime&quot;: &quot;cpp&quot;, &quot;cwchar&quot;: &quot;cpp&quot;, &quot;cwctype&quot;: &quot;cpp&quot;, &quot;any&quot;: &quot;cpp&quot;, &quot;array&quot;: &quot;cpp&quot;, &quot;atomic&quot;: &quot;cpp&quot;, &quot;strstream&quot;: &quot;cpp&quot;, &quot;bit&quot;: &quot;cpp&quot;, &quot;*.tcc&quot;: &quot;cpp&quot;, &quot;bitset&quot;: &quot;cpp&quot;, &quot;codecvt&quot;: &quot;cpp&quot;, &quot;complex&quot;: &quot;cpp&quot;, &quot;condition_variable&quot;: &quot;cpp&quot;, &quot;cstdint&quot;: &quot;cpp&quot;, &quot;deque&quot;: &quot;cpp&quot;, &quot;forward_list&quot;: &quot;cpp&quot;, &quot;list&quot;: &quot;cpp&quot;, &quot;map&quot;: &quot;cpp&quot;, &quot;set&quot;: &quot;cpp&quot;, &quot;unordered_map&quot;: &quot;cpp&quot;, &quot;vector&quot;: &quot;cpp&quot;, &quot;exception&quot;: &quot;cpp&quot;, &quot;algorithm&quot;: &quot;cpp&quot;, &quot;functional&quot;: &quot;cpp&quot;, &quot;iterator&quot;: &quot;cpp&quot;, &quot;memory&quot;: &quot;cpp&quot;, &quot;memory_resource&quot;: &quot;cpp&quot;, &quot;numeric&quot;: &quot;cpp&quot;, &quot;optional&quot;: &quot;cpp&quot;, &quot;random&quot;: &quot;cpp&quot;, &quot;ratio&quot;: &quot;cpp&quot;, &quot;string&quot;: &quot;cpp&quot;, &quot;string_view&quot;: &quot;cpp&quot;, &quot;system_error&quot;: &quot;cpp&quot;, &quot;tuple&quot;: &quot;cpp&quot;, &quot;type_traits&quot;: &quot;cpp&quot;, &quot;utility&quot;: &quot;cpp&quot;, &quot;fstream&quot;: &quot;cpp&quot;, &quot;future&quot;: &quot;cpp&quot;, &quot;initializer_list&quot;: &quot;cpp&quot;, &quot;iomanip&quot;: &quot;cpp&quot;, &quot;iosfwd&quot;: &quot;cpp&quot;, &quot;iostream&quot;: &quot;cpp&quot;, &quot;istream&quot;: &quot;cpp&quot;, &quot;limits&quot;: &quot;cpp&quot;, &quot;mutex&quot;: &quot;cpp&quot;, &quot;new&quot;: &quot;cpp&quot;, &quot;ostream&quot;: &quot;cpp&quot;, &quot;shared_mutex&quot;: &quot;cpp&quot;, &quot;sstream&quot;: &quot;cpp&quot;, &quot;stdexcept&quot;: &quot;cpp&quot;, &quot;streambuf&quot;: &quot;cpp&quot;, &quot;thread&quot;: &quot;cpp&quot;, &quot;cfenv&quot;: &quot;cpp&quot;, &quot;cinttypes&quot;: &quot;cpp&quot;, &quot;typeindex&quot;: &quot;cpp&quot;, &quot;typeinfo&quot;: &quot;cpp&quot;, &quot;valarray&quot;: &quot;cpp&quot;, &quot;variant&quot;: &quot;cpp&quot; &#125;, // Autocomplete from ros python packages &quot;python.autoComplete.extraPaths&quot;: [ &quot;/opt/ros/foxy/lib/python3.8/site-packages/&quot; ], // Environment file lets vscode find python files within workspace &quot;python.envFile&quot;: &quot;$&#123;workspaceFolder&#125;/.env&quot;, // Use the system installed version of autopep8 &quot;python.formatting.autopep8Path&quot;: &quot;/usr/bin/autopep8&quot;, &quot;python.formatting.autopep8Args&quot;: [ &quot;--max-line-length=100&quot; ], &quot;C_Cpp.default.intelliSenseMode&quot;: &quot;clang-x64&quot;, &quot;C_Cpp.formatting&quot;: &quot;Disabled&quot;, &quot;uncrustify.useReplaceOption&quot;: true, &quot;uncrustify.configPath.linux&quot;: &quot;/opt/ros/foxy/lib/python3.8/site-packages/ament_uncrustify/configuration/ament_code_style.cfg&quot;, &quot;cSpell.words&quot;: [ &quot;RTPS&quot;, &quot;athackst&quot;, &quot;autopep&quot;, &quot;cmake&quot;, &quot;cppcheck&quot;, &quot;cpplint&quot;, &quot;deque&quot;, &quot;devcontainer&quot;, &quot;ints&quot;, &quot;noqa&quot;, &quot;pytest&quot;, &quot;rclcpp&quot;, &quot;rclpy&quot;, &quot;repos&quot;, &quot;rosdistro&quot;, &quot;rosidl&quot;, &quot;uncrustify&quot;, &quot;xmllint&quot; ], &quot;search.exclude&quot;: &#123; &quot;**/node_modules&quot;: true, &quot;**/bower_components&quot;: true, &quot;**/*.code-search&quot;: true, &quot;**/build&quot;: true, &quot;**/install&quot;: true, &quot;**/log&quot;: true &#125;, &quot;python.analysis.extraPaths&quot;: [ &quot;/opt/ros/foxy/lib/python3.8/site-packages/&quot; ], &quot;cSpell.allowCompoundWords&quot;: true, &quot;cSpell.ignorePaths&quot;: [ &quot;**/package-lock.json&quot;, &quot;**/node_modules/**&quot;, &quot;**/vscode-extension/**&quot;, &quot;**/.git/objects/**&quot;, &quot;.vscode&quot;, &quot;.vscode-insiders&quot;, &quot;.devcontainer/devcontainer.json&quot; ], &quot;ros.distro&quot;: &quot;foxy&quot;, &quot;cmake.sourceDirectory&quot;: &quot;/home/asensing/workspace/Asensing_LiDAR_ROS/aglidar_sdk&quot;&#125; tasks.json编译任务配置，debug需求的可以改成debug编译类型 123456789101112131415161718&#123; // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ &#123; &quot;label&quot;: &quot;build&quot;, &quot;detail&quot;: &quot;Build workspace (default)&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;colcon build --cmake-args &#x27;-DCMAKE_BUILD_TYPE=Debug&#x27; -Wall -Wextra -Wpendantic&quot;, &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true &#125;, &quot;problemMatcher&quot;: &quot;$gcc&quot; &#125; ]&#125; 调试调试快捷键列表，基本就是Visual Studio那一套 序号 功能 按键 1 单步 F10 2 单步进入 F11 3 单步跳出 Shift + F11 4 恢复 F5 5 暂停 F5 6 停止 Shift + F5 7 重新运行 Ctrl + Shift + F5 8 运行task编译工程 Ctrl + Shift + B 9 切换断点 F9 10 前进 Ctrl + Shift + - 11 后退 Ctrl + Alt + - 12 运行 Ctrl + Shift + D 调试界面效果","tags":["ROS2","vscode","debug"],"categories":["开发工具"]},{"title":"QMainWindow子窗口独立全屏","path":"//qmainwindow-subwindow-fullscreen.html","content":"事件过滤器QMainWindow的子类对象的构造函数中安装事件过滤器 1centralWidget()-&gt;installEventFilter(this); 信号和槽由QAction触发进入全屏 123456connect(this-&gt;Internals-&gt;actionFull_Screen, &amp;QAction::triggered, this, [=](bool flag) &#123; auto widget = centralWidget(); m_windowFlags = widget-&gt;windowFlags(); widget-&gt;setWindowFlag(Qt::Window); widget-&gt;showFullScreen();&#125;); 退出全屏重写QMainWindow子类对象的eventFilter虚函数，在里边添加以下代码 12345678910if(obj == centralWidget() &amp;&amp; ev-&gt;type() == QEvent::KeyPress) &#123; auto keyEvent = static_cast&lt;QKeyEvent *&gt;(ev); if(keyEvent-&gt;key() == Qt::Key_Escape) &#123; auto widget = centralWidget(); widget-&gt;setWindowFlags(m_windowFlags); widget-&gt;showNormal(); this-&gt;Internals-&gt;actionFull_Screen-&gt;setChecked(false); return true; &#125;&#125;","tags":["Qt","QMainWindow","全屏"],"categories":["嵌入式"]},{"title":"ARM Linux远程调试","path":"//qt-project-remote-debug.html","content":"准备虚拟机既能ping通开发板，又能ping通外网，还要能ping通Windows主机（如果你有上位机通信（tftp、vsftp、ssh）的需求） VMware添加网络适配器2用作桥接网卡，原有的网络适配器保持为NAT模式 打开虚拟网络编辑器，配置VMnet0为桥接模式，外部连接设置为Realtek PCIe GbE Family Controller Ubuntu虚拟机配置ip 1sudo ifconfig ens37 192.168.137.33 netmask 255.255.255.0 其中ens33为NAT模式分配的网卡，它可以通过笔记本的无线网卡上网；ens37为桥接网卡，通过有线网卡跟开发板通信 Board开发板端配置IP 1ifconfig eth0 192.168.137.22 netmask 255.255.255.0 Windows手动配置IP 连接1）需要准备一些工具（交叉编译），gdb和gdbserver的移植可以参考文章 ssh：openssh或者dropbear，开发板端部署sshd、宿主机端部署ssh sftp：一般跟ssh配套的，这个也放开发板端 arm-gdb：放在宿主机端 gdbserver：放在开发板端 2）在QtCreator添加Remote Device，保证ssh连接上 3）在Build &amp; Run里边配置Kits Device Sysroot Compiler Debugger Qt version rk3399-kit配置参考 远程部署cmakecmake需要写一个部署文件：QtCreatorDeployment.txt，写法参考如下： 12远程绝对路径宿主文件路径:远程相对路径 添加开发板所需要的文件到&#x2F;root目录（相对路径不填写就是放到默认的远程绝对路径下） 12/root/home/topeet/workspace/harvester/build/harvester: 添加文件到指定的目录下 123/root/home/topeet/workspace/harvester/build/harvester: /home/topeet/workspace/harvester/simulator.sh:/can qmakeqmake pro文件写法：local.path表示本地路径，target.path表示远程路径，通过addFiles的属性赋值添加要部署的目录或文件（file1、file2） 123456local.path = $$OUT_PWDlocal.path ~= s/builds.*/target.path = /rootaddFiles.path = $$target.pathaddFiles.files += file1addFiles.files += file2 示例：部署app放到&#x2F;root目录下 1234local.path = $$OUT_PWDlocal.path ~= s/builds.*/target.path = /rootINSTALLS += target 运行配置部署配置 运行配置 运行环境变量配置，以wayland-egl为例 可以通过Batch Edit方式批量配置 12QT_QPA_PLATFORM=wayland-eglXDG_RUNTIME_DIR=/tmp/.xdg","tags":["Qt","远程调试","Linux","ARM"],"categories":["嵌入式"]},{"title":"增量和存量市场","path":"//incremental-stock-market.html","content":"前言作为一名技术人，要对产品的市场动态时刻保持敏感，了解产品的昨天、今天、明天，才能有的放矢；不懂产品的程序员不是好程序员，我去过的公司，大部分也是程序员主导产品的研发流程，一部分人要承担项目前期的需求挖掘、客户拜访、可行性调研、产品文档编写、技术支持、产品运营等工作，可见市场敏感度对技术人来说很重要 增量市场定义 市场存在大量的需求，产品的潜力未有被充分挖掘，各种因素如政治、经济、疫情等导致需求的爆发，各方有百花齐放的趋势，巨头还没有出现，人称蓝海 特点 产品还没有充分被定义，存在着各种各样的发展方向和技术路线 需求量比较大，有引领时代潮流的趋势，堪称风口 时效性，产品也有它的生命周期，不会永远保持旺盛的产品力 与地缘政治、经济因素、社会动态强烈相关 识别 激光雷达：2022年激光雷达是增量市场，但2024年不是 半导体设备：如光刻机、CVD、PVD、Etch设备等 机器人：医护机器人、工业机器人等 核磁共振设备 与养老相关的保健品、福利院等设施 存量市场定义 产品已经被定义、被市场接纳，行业的巨头有形成垄断的趋势，价格已经被打下来，利润空间很少了，称为红海，一般不建议加入存量市场 特点 需求已经明确，供应链稳定 行业垄断，头部竞争者占据优势地位（资本、技术、市场、人才） 利润空间不大 识别 2022年激光雷达是增量市场，但2024年不是，如今的汽车也不再是增量市场 2024年的新能源汽车是存量市场，价格战越演越烈，特斯拉、比亚迪等巨头体量优势特别明显，新势力则是赔本赚吆喝 公民教育，随着人口出生率下降，受教育的需求没有以前那么旺盛，教育市场已趋于饱和","tags":["产品","市场"],"categories":["方法论"]},{"title":"汽车零部件研发的各个阶段","path":"//auto-parts-stage.html","content":"A样原型机开发阶段，问题较多且功能有限，以功能原理验证为主，一般是人工制造为主，比如拼模块组装，简易打板或者直接购买demo板 B样积累了一定的解决问题的经验，基本结构已经成型（产品参数），也有了成型的PCB板，软硬件处于不断的磨合阶段，此阶段硬件、软件的改动比较频繁，产品研发的主要阶段，持续时间比较长，还是人工制造为主 C样已经能够在生产线小批量生产，快速部署，还需要进行各项测试，可以借助一些自动化软件、设备辅助生产，提高生产效率 D样已经能够批量交付用户使用，可用于相关部门的检查、认证，此时也有完整的用户手册，出现问题也有技术支持","tags":["产品","汽车电子"],"categories":["方法论"]},{"title":"项目概要设计说明书","path":"//project-overview-specification.html","content":"项目介绍xxx是一个什么样的项目，技术点、人力投入、工期 需求概述把客户的目标需求大致讲清楚 应用领域 运行环境 功能指标 性能指标 条件限制 技术可行性分析材料、结构、硬件、软件、测试角度分析 需要采购什么设备、走什么认证流程、用什么测试手段 系统架构 &#x2F; 总体设计软硬件系统组成结构 上位机 下位机 服务器 通信协议 人员职责需要的人员以及工种，每个人负责的工作点，大概估算多少人、多少工时 美工 软件 硬件 机械 测试 运维 产品 功能模块对系统架构里边的模块逐一拆解、分析，列出系统框图 模块1 模块2 模块3 每个模块工作流程图 流程1 流程2 流程3 接口设计模块的通信接口进行定义 接口1 接口2 接口3 通信协议硬件接口 软件协议 测试前置依赖：需要什么人、什么设备、什么条件 性能、参数指标测试 黑盒、白盒 维护客户现场出现问题怎么解决，材料、结构、硬件、软件的职责范围","tags":["管理","项目","说明书"],"categories":["方法论"]},{"title":"Ubuntu22.04搭建ROS2运行环境","path":"//ubuntu22.04-install-ros2.html","content":"区域语言设置设置区域语言为US 123456789sudo apt updatesudo apt install localessudo locale-gen en_US en_US.UTF-8sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8export LANG=en_US.UTF-8 必备软件组件如果已经安装，可以跳过这一步骤 1234567sudo apt updatesudo apt-get install -y libyaml-cpp-devsudo apt-get install -y libpcap-devsudo apt install -y curl gnupg lsb-release 更新远程仓库源更新/etc/hosts文件，防止raw.githubusercontent.com被墙，可以通过nslookup命令查看域名服务器地址 12345185.199.110.133\traw.githubusercontent.com185.199.110.133 user-images.githubusercontent.com185.199.110.133 avatars2.githubusercontent.com185.199.100.133 avatars1.githubusercontent.com20.205.243.166 github.com 如果已经添加过源，这一步也可以跳过 12345sudo curl -sSL http://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpgecho &quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(source /etc/os-release &amp;&amp; echo $UBUNTU_CODENAME) main&quot; | sudo tee /etc/apt/sources.list.d/ros2.list &gt; /dev/nullsudo apt update 安装humble桌面版和基础版二选一 12sudo apt install ros-humble-desktop # 桌面版sudo apt install ros-humble-ros-base\t# 基础版 安装软件包colcon和libbackward-ros都安装一下 12sudo apt-get install python3-colcon-common-extensionssudo apt-get install -y ros-humble-backward-ros 验证ROS2借用小乌龟来验证是否成功，humble版本如果没有预装turtlesim的话请事先安装 1sudo apt install ros-humble-turtlesim 运行turtlesim_node和turtle_teleop_key两个节点 123source /opt/ros/humble/setup.bashros2 run turtlesim turtlesim_noderos2 run turtlesim turtle_teleop_key 控制效果 完全卸载如果你不想用humble这个版本，请用以下命令卸载干净 1sudo apt-get autoremove --purge ros-humble-desktop","tags":["ROS2","ubuntu22.04"],"categories":["操作系统"]},{"title":"解决csv文件导出时间戳精度丢失的问题","path":"//csv-file-lose-precision.html","content":"丢失精度以圆周率数据输出为例，如果直接通过ostream输出到文件，则会丢失精度 123ostream stream;double value = 3.1415926;stream &lt;&lt; value; 保留精度需要通过std::setprecision函数来指定浮点数的精度 123ostream stream;double value = 3.1415926;stream &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; value;","tags":["C++","csv"],"categories":["程序设计"]},{"title":"Windows程序读取不了中文路径问题","path":"//windows-program-chinese-path-problem.html","content":"问题描述今天调试发现win32接口GetFileAttributesW居然不支持中文路径，于是寻找解决方案，找了半天，尝试用boost的fileystem库发现能解决问题，而且boost能跨平台！ 不支持中文win32接口获取文件属性，当传入参数带有中文字符时，它获取的属性就会异常 1DWORD GetFileAttributesW([in] LPCWSTR lpFileName); 支持中文boost判断是否为文件 123std::string realpath = &quot;D:\\\\新建文件夹\\\\a.txt&quot;;boost::filesystem::path p(realpath);boost::filesystem::is_regular_file(p); boost判断是否为文件夹 123std::string realpath = &quot;D:\\\\新建文件夹&quot;;boost::filesystem::path p(realpath);boost::filesystem::is_directory(p); 总结人生苦短，我用boost！","tags":["Windows","win32","中文路径"],"categories":["程序设计"]},{"title":"嵌入式代码优化技巧","path":"//embedded-code-optimization.html","content":"内存管理技巧1.C&#x2F;C++工程应尽量避免深拷贝，尽量用浅拷贝（指针或者引用），如果指针需要频繁拷贝，用智能指针是一种不错的选择 2.启用内存池管理线程的内存开销，事先在堆里边分配好，然后快速使用 避免复杂的浮点运算1.复杂的浮点运算尽量避免，有些芯片是不支持硬件双精度浮点数的，比如全志T3，实在是非用不可，可以用查表的方式加快速度 2.数据传输可以用整型数据压缩减少带宽，这个在can数据传输比较常见 空间换时间比如一个数据模型体积很大，加载起来很耗时，可以考虑把它编译到软件里边去，然后运行的时候提前加载到内存 算法复杂度优化1.时间复杂度，减少循环使用次数 2.空间复杂度的角度优化 并行框架openMP了解一下，在关键的代码段加上omp并行处理 字节对齐用好字节对齐功能可以优化cpu流水线的处理效率 内核态的利用可以把一些业务操作写进驱动，利用操作系统的调度优化，内核态和用户态哪一个更高效，这个是相对的，得看系统调用和库函数的颗粒度，可以值得尝试一下 线程调度尝试调整一些线程的优先级提高调度效率，另外Linux也允许绑核操作 防御性编程 申请一段buffer后总是习惯性的将其内容memset为0，当然这是针对plain类型的数据，防止在数据解析的时候解析到不合法的数据 总是习惯性的判断数组的边界 申请指针不应该悬空，应该给它一个值或者是nullptr，使用前判断它是否为空 巧用断言","tags":["调优","优化"],"categories":["嵌入式"]},{"title":"软件版本那些事","path":"//software-version.html","content":"软件版本跟测试阶段或者软件的生命周期所处的阶段有关，一般有以下几个版本 alpha内测版本，仅限团队内部测试使用，不对外公开。大多数软件产品在向公众发布之前都要经过多个步骤。alpha版本是该系统的一部分，用于开发高效、准确和无缺陷的软件程序。这一阶段软件会频繁改动。 项目处于不稳定状态。可能有许多未修复的错误，包括安全问题。API可能会更改，恕不另行通知。安装新的alpha版本需要卸载项目，从而丢失所有数据。只针对那些想要提前预览项目的人。尚不适合共享发展。不适合生产现场使用。目标受众是希望参与项目测试、调试和开发的开发人员。 beta通过内部测试之后的版本，开放给外部渠道使用。Beta版本通常在外观、感觉和功能上与最终产品相当接近；在这一阶段变更还是会经常发生。 所有重要的数据丢失和安全漏洞得到解决。如果模块提供了一个API，它应该被认为是冻结的，这样那些使用API的人就可以开始升级他们的项目了。如果是项目的升级或更新，则应提供升级&#x2F;更新路径，并且现有用户应该能够在不丢失数据的情况下升级&#x2F;更新到新版本。所有文档都应该是最新的。目标受众是想要参与项目的测试、调试和开发的开发人员，以及与项目对接的其他项目的开发人员。通常不适用于生产站点，但如果站点管理员非常了解项目，并且知道如何处理任何遗留问题，则可以在某些生产站点上使用。 rcrelease candidate，beta版本迭代之后比较成熟的版本，按照惯例，每当程序的更新几乎准备就绪时，测试版本就会被赋予rc号。如果发现了需要修复的关键错误，则更新程序并以更高的rc号重新发布。当没有严重错误存在，或者没有发现额外的严重错误时，rc名称将被删除。 release正式提供给客户使用的版本 stablerelease版本中的稳定版本，一般比较少使用","tags":["版本"],"categories":["方法论"]},{"title":"工程师健康备忘录","path":"//engineer-health-guide.html","content":"前言前不久，IT界的大佬左耳朵耗子陈皓心梗逝世，享年仅47岁，真是天妒英才，据说他是一名工作狂……好的身体是革命的本钱，年纪越大，就会发现编程并不是脑力活，其实更偏向体力活！长时间工作吃的是人的体力和精力，开会、写文档、编码、测试样样工作都需要有充沛和持续的精力投入 感慨在中国这种996工作制遍地开花的国度，如果你没有铁一样的身体素质，你基本很难熬35岁这道坎，这也是为什么很多公司喜欢招小年轻的原因；并且，久坐在办公室容易引发很多疾病：眼疲劳、关节疼痛、头晕眼花、颈椎病……新闻经常能听到这样的剧本：某某大厂员工在加班的时候突然猝死，留下背负房贷的妻儿老小……说了这么多，想必大家已经知道拥有一个好身体对程序员来说是多么的重要，下面将从几个方面介绍一些程序员健康指南，希望能对广大程序员有所帮助 作息篇规律的作息对身体是一种补偿，建议买个健康手表定期叮嘱自己 早点睡，11点前尽量睡了 多睡点，每日8个钟 睡好点，深睡眠的时间每晚约占睡眠总时长的 **15%~25%**才好 尽量午睡，这个我觉得脑力工作者就要睡（中午不睡，下午崩溃） 饮食篇民以食为天，经常坐着不动容易长肚子（中年人的悲哀） 少吃甜食 少盐 少油 多喝水 荤素搭配 运动篇上班期间适合做的健身运动 扩胸运动，每天100个 （增加肺活量、锻炼胸部肌肉） 高抬腿，每天30个（纠正腿部、腰部力量） 双手合紧，向后方拉伸，夹紧肩胛骨（纠正肩膀肌肉） 慢走15分钟（有氧运动，增加肺活量） 米字操，用头向前方画一个米字（放松颈部肌肉） 工作篇 番茄工作法，将一个任务分解一个个工作包，以一个工作包为单位执行 学会坦然，现实生活中技术问题往往不是最重要的问题，大多数问题也跟编程无关 向上管理，遇到问题学会及时反馈，而不是一个人扛着 提高工作效率，要做的事情排一个优先级 生活篇 多遵循内心的意愿 学会拒绝 有什么喜欢的事情要趁着年轻去追寻，尝试一些爱好，如学学钢琴、听听音乐会 张弛有道，切勿绷得像机械钟的发条一样紧 社交篇 尊重他人的想法 遵循自己的内心 语录《活着》 没有什么比时间更具有说服力了，因为时间无需通知我们就可以改变一切 人是为活着本身而活着，而不是为了活着之外的任何事物所活着 一个人命再大，要是自己想死，那就怎么也活不了 《百年孤独》 我们终究会死。所以我们的人生目标不该是长命百岁，而应该做点自己想做的","tags":["健康","职业"],"categories":["学科"]},{"title":"gdb8.3交叉编译","path":"//gdb8.3-porting.html","content":"下载去gdb官网下载gdb8.3 1wget https://ftp.gnu.org/gnu/gdb/gdb-8.3.tar.xz 下载完成后解压xz文件 12tar xf gdb-8.3.tar.xzcd gdb-8.3 配置环境变量 1export PATH=$PATH:/home/topeet/rk3399/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin 编译gdb 12./configure --target=aarch64-linux-gnu --prefix=$PWD/buildmake -j8 编译gdbserver 123cd gdb./configure --target=aarch64-linux-gnu --host=aarch64-linux-gnu --prefix=$PWD/build CXXFLAGS=&#x27;-fPIC -static&#x27;make -j8 测试将gdbserver部署到开发板文件系统，并运行gdbserver 1gdbserver --multi :10000 demo 宿主机端运行aarch64-linux-gnu-gdb 1target remote 192.168.137.22:10000","tags":["gdb","交叉编译"],"categories":["嵌入式"]},{"title":"RT-Thread技术沙龙","path":"//rt-thread-tech-salon.html","content":"主题会议由RT-Thread &amp;&amp; Infineon共同主持，PSoc62开发板现场演示从0到1搭建智能数据网关 RT-ThreadRT-Thread社区负责人郭占鑫郭工介绍RT-Thread生态 合作伙伴英飞凌产品负责人介绍英飞凌的产品动态、分享未来的一些嵌入式技术发展方向以及应用案例 技术分享技术人员介绍有关钩子函数在开源项目、日常项目的用法 idle线程 uart接收 IoT项目案例 实验环节现场撸了英飞凌开发板的点灯代码（万物基于点灯），这个必须记录下来！ 1234567891011121314151617181920212223242526272829303132#include &lt;rtthread.h&gt;#include &lt;rtdevice.h&gt;#include &quot;drv_gpio.h&quot;#define LED0_PIN GET_PIN(0, 1)#define USER_KEY GET_PIN(6, 2)void irq_callback()&#123; static int flag = 0; rt_kprintf(&quot;Key Pressed!\\r &quot;); if(flag == 0) &#123; rt_pin_write(LED0_PIN, PIN_HIGH); flag = 1; &#125; else &#123; rt_pin_write(LED0_PIN, PIN_LOW); flag = 0; &#125;&#125;int main(void)&#123; rt_pin_mode(LED0_PIN, PIN_MODE_OUTPUT); rt_pin_mode(USER_KEY, PIN_MODE_INPUT_PULLUP); rt_pin_attach_irq(USER_KEY, PIN_IRQ_MODE_RISING, irq_callback, RT_NULL); rt_pin_irq_enable(USER_KEY, PIN_IRQ_ENABLE); return 0;&#125; 实验点灯效果 抽奖环节开发板免费送 抽奖环节我居然也是幸运观众，RT-Thread抱枕一个 合影RT-Thread社区人员、Infineon、现场开发者人员集体合影 致谢 感谢RT-Thread社区为这次技术分享所作的努力，祝愿RT-Thread开源事业越来越红火 感谢英飞凌合作伙伴的大力支持，祝英飞凌芯片大卖","tags":["RT-Thread","开源"],"categories":["开源社区"]},{"title":"创客峰会杂感","path":"//maker-summit.html","content":"前言一年一度的大湾区国际创客峰会11月11日至12日在深圳南山万科云设计公社举行 见闻在阶梯会议室看到了树莓派基金会的创始人和Seeed Studio的创始人 很有意思的机器人音乐项目 每日积点功德之电子木鱼，真的是脑洞大开！ 外国友人的温室大棚项目，思考😀 络绎不绝的NVIDIA、seeed studio、树莓派展厅 日本友人的生化项目，没点专业知识真的看不懂！ 合影和两位伙伴们的留影（两位开源界的巨擘） 感慨如果你问我，中国的maker和外国的maker有啥不一样？我会回答，一个不纯粹，一个纯粹，没有可比性，中国人通常都带着某种目的去玩创客（我逼自己一把），外国人明显没有这种心理包袱，在现场我甚至看到了大学生毕业设计玩烂的温室大棚环境监控系统，可见他们只是just for fun，有个日本人展示了他的电子乐器，甚至还有一个电子木鱼，兴致勃勃的给路人讲解他的发明，他的那种passion是大多数中国人不能理解的","tags":["开源","创客"],"categories":["开源社区"]},{"title":"about","path":"/about/index.html","content":"关于我是一名热爱编程与艺术的开发者，喜欢用代码创造美好的事物，从事物联网、自动化、汽车电子开发工作；具有丰富的调试和设计经验，兴趣包括设计、跑步、烹饪、旅行、音乐、摄影和写作 内容分享一些工作中的问题、想法，与技术、管理、产品相关的记录、思考、沉淀，希望对读者有帮助 免责这个是我的个人博客，如果对你有帮助是我莫大的荣幸，自行更改请恕不另行通知！另外，这也是一个自由的博客，没有任何广告 联系如果你对鄙人感兴趣，欢迎通过以下方式联系我：hywing.sir@qq.com"},{"title":"启动流程","path":"/wiki/kernel/index.html","content":"介绍"},{"title":"51单片机介绍","path":"/wiki/mcs51/index.html","content":"介绍"},{"title":"Bootloader实现","path":"/wiki/stm32/Bootloader实现.html","content":"介绍bootloader 应用程序"},{"title":"ADC使用","path":"/wiki/stm32/ADC使用.html","content":"介绍ADC读取电阻分压"},{"title":"GPIO使用","path":"/wiki/stm32/GPIO使用.html","content":"介绍虽说使用stm32CubeMX配置GPIO是一件很轻松的事情，但还是有必要从代码的角度理解GPIO的配置过程 初始化GPIO初始化流程： 初始化GPIO_InitTypeDef结构体 使能GPIO端口时钟 设置Pin口状态 GPIO_InitTypeDef结构体，一般需要设置Pin、Model、Pull、Speed几项参数 1234567891011121314151617typedef struct&#123; uint32_t Pin; /*!&lt; Specifies the GPIO pins to be configured. This parameter can be any value of @ref GPIO_pins */ uint32_t Mode; /*!&lt; Specifies the operating mode for the selected pins. This parameter can be a value of @ref GPIO_mode */ uint32_t Pull; /*!&lt; Specifies the Pull-up or Pull-Down activation for the selected pins. This parameter can be a value of @ref GPIO_pull */ uint32_t Speed; /*!&lt; Specifies the speed for the selected pins. This parameter can be a value of @ref GPIO_speed */ uint32_t Alternate; /*!&lt; Peripheral to be connected to the selected pins This parameter can be a value of @ref GPIOEx_Alternate_function_selection */&#125; GPIO_InitTypeDef; HAL_GPIO_Init 1void HAL_GPIO_Init(GPIO_TypeDef *GPIOx, GPIO_InitTypeDef *GPIO_Init) GPIO读 1GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin) GPIO写 1void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState) RCC配置 123/* GPIO Ports Clock Enable */__HAL_RCC_GPIOA_CLK_ENABLE();__HAL_RCC_GPIOB_CLK_ENABLE(); 初始化示例 1234567891011121314151617181920void MX_GPIO_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStruct = &#123;0&#125;; /* GPIO Ports Clock Enable */ __HAL_RCC_GPIOA_CLK_ENABLE(); __HAL_RCC_GPIOB_CLK_ENABLE(); /*Configure GPIO pin Output Level */ HAL_GPIO_WritePin(GPIOB, GPIO_PIN_4, GPIO_PIN_RESET); /*Configure GPIO pin : PB4 */ GPIO_InitStruct.Pin = GPIO_PIN_4; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);&#125; 使用示例 12345678HAL_Init();SystemClock_Config();MX_GPIO_Init();while (1)&#123; HAL_GPIO_TogglePin(GPIOB,GPIO_PIN_4); HAL_Delay(100);&#125;"},{"title":"KEY驱动","path":"/wiki/stm32/KEY驱动.html","content":"介绍GPIONVIC中断处理"},{"title":"PWM驱动","path":"/wiki/stm32/PWM驱动.html","content":"介绍生成1KHz的方波"},{"title":"LCD驱动","path":"/wiki/stm32/LCD驱动.html","content":"介绍LCD2002驱动教程"},{"title":"Sensor驱动","path":"/wiki/stm32/Sensor驱动.html","content":"介绍读取内部温度传感器的值"},{"title":"RTC使用","path":"/wiki/stm32/RTC使用.html","content":"介绍获取准确的时钟源"},{"title":"USART使用","path":"/wiki/stm32/USART使用.html","content":"配置GPIO USART 中断发送接收printf1234567#include &lt;stdio.h&gt;#include &lt;stm32g0xx_hal.h&gt;int fputc(int ch, FILE *f) &#123; HAL_UART_Transmit(&amp;huart2, (uint8_t *)&amp;ch, 1, HAL_MAX_DELAY); return ch;&#125;"},{"title":"stm32g030c8t6介绍","path":"/wiki/stm32/index.html","content":"介绍STM32G030x6/x8 系列主流微控制器基于高性能的 Arm® Cortex®-M0+ 32 位 RISC 内核，最高工作频率可达 64 MHz；stm32g030c8t6这款芯片集成了丰富的片上资源，适用于消费、工业和家电领域的广泛应用 MCU：主频最高可达64MHz SRAM：8K FLASH：64K GPIO：44路多用途IO TIMER：1路高级定时器、2路通用定时器、一路systick、2路看门狗 I2C：2路 USART：2路 SPI：2路 RTC：一个 ADC：1路，支持多大19个通道 c8系列芯片采用LQFP48封装，管脚分布如下： 开发进行stm32的开发需要准备以下软件或者工具 MDK Keil keil的安装比较简单，现在最新版本是免费的了，避免了盗版的问题 STM32CubeMX 这个工具是用来配置芯片资源的，软硬件工程师都可以用，ST官网可以免费下载安装 另外还需要准备：ST-LINK V2和CH340 USB转串口作作为调试工具 工程新建CubeMX工程 选择芯片型号stm32g030c8t6，然后双击进去 配置外设资源，常见的有GPIO、NVIC、RCC、USART等 修改时钟：RTC为32.768KHz，HCLK为16MHz 导出工程配置，然后点击右上角GENERATE CODE就可以导出MDK KEIL工程到指定目录下了 正常用Keil5打开编译是没有什么问题的，到Debug栏配置ST-Link Debugger就可以烧录了 电气关于stm32g030c8t6这款芯片的一些电气特性，搭配外设使用的时候要注意： 电源：3.3V供电，2.0 V to 3.6 V 最大输出电流：80mA 最大输入电流：100mA 工作温度：-40 - 85℃ 这款芯片在嘉立创商城的价格也就3-5RMB左右，如果用来替代51这样的单片机问题不大，各方面性能都很优越 说明这里使用stm32CubeMX是为了导出SDK，当然也可以使用CubeMX图形化的方式进行编程，但初学者建议把HAL的代码亲手撸一遍"},{"title":"ros2介绍","path":"/wiki/ros2/index.html","content":"介绍"},{"title":"启动流程","path":"/wiki/uboot/index.html","content":"介绍"}]