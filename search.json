[{"title":"cmake获取指定目录下的所有文件","path":"//cmake-recurse-files.html","content":"需求编写跨平台的工程时，因为项目比较大，文件很多，开发人员很多，不想一一列举add_executable里边的文件 解决用FILE宏获取某个指定目录下的同一类型的所有文件，用DIAGNOSTIC和SERIALIZE两个变量来分别存储所有符合条件的文件名，include_directories也可以自动包含目录下的所有头文件 12345FILE(GLOB_RECURSE DIAGNOSTIC $&#123;CMAKE_SOURCE_DIR&#125;/diagnostic/*.c)include_directories($&#123;CMAKE_SOURCE_DIR&#125;/diagnostic)FILE(GLOB_RECURSE SERIALIZE $&#123;CMAKE_SOURCE_DIR&#125;/serialize/*.c)include_directories($&#123;CMAKE_SOURCE_DIR&#125;/serialize) 再在add_executable里边添加DIAGNOSTIC和SERIALIZE两个变量，这样新增文件只要执行一下cmake就可以了 1234567add_executable(zhd-desktop main.c $&#123;DIAGNOSTIC&#125; $&#123;SERIALIZE&#125; logo.rc res.qrc)","tags":["cmake"],"categories":["开发工具"]},{"title":"与NXP的一点缘分","path":"//nxp-stuff.html","content":"介绍NXP是老牌的芯片巨头，做汽车电子的人尤为熟悉，比如它的LPC系列、S32K系列；去年接触（白嫖）NXP的MCU方案比较多，特别是FRDM这个开发板系列，给RT-Thread贡献了多个PR 开发板MCXN947这个板子的资源比较丰富，最大亮点是集成了神经处理单元 MCXA153资源比947稍微少一些，没有CAN和ETH，是中规中矩的MCU MCXW71专为无线连接设计的板子 礼品参与NXP相关的活动，收到的一些礼物 机械键盘参加947的测评活动送的一份沉甸甸的礼物 发光鼠标垫这个可以发光，颜色会变化 充电宝这个是新年收到的礼物，20000mAh的充电宝","tags":["NXP"],"categories":["嵌入式"]},{"title":"网络数据Hex格式转换","path":"//qt-string-to-hex.html","content":"前言Qt中TCP通信一般用QByteArray作为数据传输对象，使用Hex格式的情形要考虑一下变换，否则服务器和客户端的数据长度对不上 发送字符串本身就是hex格式，需要转成QByteArray格式进行传输 123QString hex = &quot;03000010560155aa010023000000d750&quot;;QByteArray data = QByteArray::fromHex(hex.toLatin1());m_socket-&gt;write(data); 接收QByteArray转为hex格式 12QString hex = m_socket-&gt;readAll().toHex();qDebug() &lt;&lt; hex;","tags":["Qt"],"categories":["程序设计"]},{"title":"一个简单的Windows服务器实现","path":"//winsock2-server.html","content":"初始化 123456789WSADATA wsaData;SOCKET serverSocket, clientSocket;struct sockaddr_in serverAddr = &#123; 0x00 &#125;;struct sockaddr_in clientAddr = &#123; 0x00 &#125;;int clientAddrLen = sizeof(clientAddr);if (WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0) &#123; printf(&quot;WSAStartup failed. &quot;);&#125; 创建socket 1234if ((serverSocket = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET) &#123; printf(&quot;Socket failed. &quot;); WSACleanup();&#125; IP及端口号配置 123456789serverAddr.sin_family = AF_INET;serverAddr.sin_addr.s_addr = INADDR_ANY;serverAddr.sin_port = htons(9988);if (bind(serverSocket, (struct sockaddr*)&amp;serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) &#123; printf(&quot;Bind failed. &quot;) closesocket(serverSocket); WSACleanup();&#125; 监听客户端连接 12345if (listen(serverSocket, 5) == SOCKET_ERROR) &#123; printf(&quot;Listen failed. &quot;); closesocket(serverSocket); WSACleanup();&#125; 接受客户端连接 12345if ((clientSocket = accept(serverSocket, (struct sockaddr*)&amp;clientAddr, &amp;clientAddrLen)) == INVALID_SOCKET) &#123; printf(&quot;Accept failed. &quot;); closesocket(serverSocket); WSACleanup();&#125; 接收 1int bytesReceived = recv(clientSocket, (char*)(_sRxBuffer + _sRxLenght), BUFFER_SIZE, 0); 发送 1int txPacketlenght = send(socket, (const char*)_sTxBuffer, txPacketlenght, 0); 回收socket资源 123closesocket(clientSocket);closesocket(serverSocket);WSACleanup();","tags":["服务器","Windows"],"categories":["程序设计"]},{"title":"Windows常用快捷键集合","path":"//windows-common-shortcuts.html","content":"介绍工欲善其事必先利其器，用对工具往往事半功倍 快捷键 打开运行对话框：win + R 打开Windows粘贴板：win + V 打开Home菜单：win + X 打开搜索对话框：win + S 截图：win + Shift + S 打开控制面板：win + I 在某个文件路径迅速打开cmd命令行：Ctrl + L，输入cmd即可 拓展屏幕配置：win + P 光标聚焦任务栏：win + T 光标聚焦状态栏：win + B 所有窗口最小化：win + M 锁屏：win + L Windows防火墙：win + R后输入filewall.cpl 运行任务栏的程序：win + 1，2，3，4对应从左到右的程序序号 打开Windows通知面板：win + A 唤醒画画及截屏功能：win + W","tags":["Windows，快捷键"],"categories":["开发工具"]},{"title":"Qt Enter和HoverEnter事件","path":"//qt-enter-hoverenter.html","content":"介绍做PC开发的过程中或多或少都会接触到鼠标的悬停事件，Qt中处理鼠标悬停有Enter和HoverEnter两种事件 相同点 QEvent::Enter对应QEnterEvent，描述的是鼠标进入控件坐标范围之内的行为，QEnterEvent可以抓取鼠标的位置 QEvent::HoverEnter对应QHoverEvent，控件开启Qt::WA_Hover属性可以达到Enter事件一样的效果，QHoverEvent同样可以抓取鼠标的位置 不同点QHoverEvent附带有QEvent::Paint重绘行为，QEnterEvent没有触发控件本身的重绘的能力，请按照具体的场景区别使用","tags":["Qt"],"categories":["程序设计"]},{"title":"Qt TCP通信案例","path":"//qt-tcp-communication-example.html","content":"服务器使用前要在cmake工程文件里边添加network模块 123find_package(Qt5 COMPONENTS core network REQUIRED)target_link_libraries($&#123;PROJECT_NAME&#125; Qt5::Core Qt5::Network) TCP通信服务器的核心类是QTcpServer，头文件同名 1#include &lt;QTcpServer&gt; 使用也特别简单，先绑定IP地址和端口号，listen的返回结果如果是false则端口号有可能被占用，Windows上建议用netstat -aon | findstr &quot;9090&quot;事先看一下端口占用情况，Linux下则是用netstat -tlp | grep 9090 12QTcpServer server;bool ret = server.listen(QHostAddress(&quot;127.0.0.1&quot;), 9090); 编写newConnection信号对应的槽函数，服务器通过nextPendingConnection接口获取已建立的socket，然后对socket进行读写 1234567891011QObject::connect(&amp;server, &amp;QTcpServer::newConnection, [&amp;]() &#123; auto &amp;&amp;socket = server.nextPendingConnection(); auto timer = new QTimer(); QObject::connect(timer, &amp;QTimer::timeout, [&amp;, socket]() &#123; socket-&gt;write(QByteArray(&quot;hello world&quot;)); &#125;); timer-&gt;start(1000); QObject::connect(socket, &amp;QTcpSocket::readyRead, [&amp;, socket]() &#123; qDebug() &lt;&lt; &quot;Server : &quot; &lt;&lt; socket-&gt;readAll(); &#125;);&#125;); 客户端客户端同理，使用前也要在cmake工程文件里边添加network模块 123find_package(Qt5 COMPONENTS core network REQUIRED)target_link_libraries($&#123;PROJECT_NAME&#125; Qt5::Core Qt5::Network) 客户端使用QTcpSocket进行TCP通信 1#include &lt;QTcpSocket&gt; 调用connectToHost接口建立服务器通信连接 12QTcpSocket socket;socket.connectToHost(QHostAddress(&quot;127.0.0.1&quot;), 9090); 需要处理几个跟连接相关的信号：connected、disconnected、readyRead 12345678910111213// connected表示连接已建立QObject::connect(&amp;socket, &amp;QTcpSocket::connected, [&amp;]() &#123; timer-&gt;start(1000); qDebug() &lt;&lt; &quot;Client connected server&quot;;&#125;);// disconnected表示连接已断开QObject::connect(&amp;socket, &amp;QTcpSocket::disconnected, [&amp;]() &#123; qDebug() &lt;&lt; &quot;Client disconnected server&quot;;&#125;);// readyRead表示缓冲区有数据可读QObject::connect(&amp;socket, &amp;QTcpSocket::readyRead, [&amp;]() &#123; qDebug() &lt;&lt; &quot;Client : &quot; &lt;&lt; socket.readAll();&#125;); 基类QIODevice的读写接口 12345678910qint64 read(char *data, qint64 maxlen);QByteArray read(qint64 maxlen);QByteArray readAll();qint64 readLine(char *data, qint64 maxlen);QByteArray readLine(qint64 maxlen = 0);qint64 write(const char *data, qint64 len);qint64 write(const char *data);inline qint64 write(const QByteArray &amp;data)&#123; return write(data.constData(), data.size()); &#125; 结果 以上的服务器和客户端在互相给对方发hello world数据 QTcpServer那里巧妙抽象了QTcpSocket的操作方式，客户端和服务器都是对QTcpSocket读写","tags":["Qt","TCP","服务器","客户端"],"categories":["程序设计"]},{"title":"uboot剖析之命令行延时","path":"//uboot-bootdelay.html","content":"在configs/rk3506_defconfig文件中可以配置启动延时选项 1CONFIG_BOOTDELAY=3 main_loop：bootdelay_process处理delay延时值解析，按键捕获由autoboot_command负责 123456789101112131415161718192021222324252627void main_loop(void)&#123; const char *s; bootstage_mark_name(BOOTSTAGE_ID_MAIN_LOOP, &quot;main_loop&quot;);#ifdef CONFIG_VERSION_VARIABLE env_set(&quot;ver&quot;, version_string); /* set version variable */#endif /* CONFIG_VERSION_VARIABLE */ cli_init(); run_preboot_environment_command();#if defined(CONFIG_UPDATE_TFTP) update_tftp(0UL, NULL, NULL);#endif /* CONFIG_UPDATE_TFTP */ s = bootdelay_process(); if (cli_process_fdt(&amp;s)) cli_secure_boot_cmd(s); autoboot_command(s); cli_loop(); panic(&quot;No CLI available&quot;);&#125; bootdelay_process：要么从环境变量bootdelay里边获取，要么就从CONFIG_BOOTDELAY里边获取，最后更新stored_bootdelay 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const char *bootdelay_process(void)&#123; char *s; int bootdelay;#ifdef CONFIG_BOOTCOUNT_LIMIT unsigned long bootcount = 0; unsigned long bootlimit = 0;#endif /* CONFIG_BOOTCOUNT_LIMIT */#ifdef CONFIG_BOOTCOUNT_LIMIT bootcount = bootcount_load(); bootcount++; bootcount_store(bootcount); env_set_ulong(&quot;bootcount&quot;, bootcount); bootlimit = env_get_ulong(&quot;bootlimit&quot;, 10, 0);#endif /* CONFIG_BOOTCOUNT_LIMIT */ s = env_get(&quot;bootdelay&quot;); bootdelay = s ? (int)simple_strtol(s, NULL, 10) : CONFIG_BOOTDELAY;#ifdef CONFIG_OF_CONTROL bootdelay = fdtdec_get_config_int(gd-&gt;fdt_blob, &quot;bootdelay&quot;, bootdelay);#endif debug(&quot;### main_loop entered: bootdelay=%d &quot;, bootdelay);#if defined(CONFIG_MENU_SHOW) bootdelay = menu_show(bootdelay);#endif bootretry_init_cmd_timeout();#ifdef CONFIG_POST if (gd-&gt;flags &amp; GD_FLG_POSTFAIL) &#123; s = env_get(&quot;failbootcmd&quot;); &#125; else#endif /* CONFIG_POST */#ifdef CONFIG_BOOTCOUNT_LIMIT if (bootlimit &amp;&amp; (bootcount &gt; bootlimit)) &#123; printf(&quot;Warning: Bootlimit (%u) exceeded. Using altbootcmd. &quot;, (unsigned)bootlimit); s = env_get(&quot;altbootcmd&quot;); &#125; else#endif /* CONFIG_BOOTCOUNT_LIMIT */ s = env_get(&quot;bootcmd&quot;); process_fdt_options(gd-&gt;fdt_blob); stored_bootdelay = bootdelay; return s;&#125; autoboot_command：在执行启动命令run_command_list前先检查stored_bootdelay值 12345678910111213141516171819202122232425void autoboot_command(const char *s)&#123; debug(&quot;### main_loop: bootcmd=\\&quot;%s\\&quot; &quot;, s ? s : &quot;&lt;UNDEFINED&gt;&quot;); if (stored_bootdelay != -1 &amp;&amp; s &amp;&amp; !abortboot(stored_bootdelay)) &#123;#if defined(CONFIG_AUTOBOOT_KEYED) &amp;&amp; !defined(CONFIG_AUTOBOOT_KEYED_CTRLC) int prev = disable_ctrlc(1); /* disable Control C checking */#endif run_command_list(s, -1, 0); autoboot_command_fail_handle();#if defined(CONFIG_AUTOBOOT_KEYED) &amp;&amp; !defined(CONFIG_AUTOBOOT_KEYED_CTRLC) disable_ctrlc(prev); /* restore Control C checking */#endif &#125;#ifdef CONFIG_MENUKEY if (menukey == CONFIG_MENUKEY) &#123; s = env_get(&quot;menucmd&quot;); if (s) run_command_list(s, -1, 0); &#125;#endif /* CONFIG_MENUKEY */&#125; abortboot：真正的功能实现在__abortboot 1234567891011121314static int abortboot(int bootdelay)&#123; int abort = 0; if (bootdelay &gt;= 0) abort = __abortboot(bootdelay);#ifdef CONFIG_SILENT_CONSOLE if (abort) gd-&gt;flags &amp;= ~GD_FLG_SILENT;#endif return abort;&#125; __abortboot：bootdelay延时计数 + 等待按键ctrl+c输入 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static int __abortboot(int bootdelay)&#123; int abort = 0; unsigned long ts;#ifdef CONFIG_MENUPROMPT printf(CONFIG_MENUPROMPT);#else printf(&quot;Hit key to stop autoboot(&#x27;CTRL+C&#x27;): %2d &quot;, bootdelay);#endif#ifdef CONFIG_ARCH_ROCKCHIP if (!IS_ENABLED(CONFIG_CONSOLE_DISABLE_CLI) &amp;&amp; ctrlc()) &#123; /* we press ctrl+c ? */#else /* * Check if key already pressed */ if (tstc()) &#123; /* we got a key press */#endif (void) getc(); /* consume input */ puts(&quot;\\b\\b\\b 0&quot;); abort = 1; /* don&#x27;t auto boot */ &#125; while ((bootdelay &gt; 0) &amp;&amp; (!abort)) &#123; --bootdelay; /* delay 1000 ms */ ts = get_timer(0); do &#123; if (ctrlc()) &#123; /* we got a ctrl+c key press */ abort = 1; /* don&#x27;t auto boot */ bootdelay = 0; /* no more delay */# ifdef CONFIG_MENUKEY menukey = 0x03; /* ctrl+c key code */# endif break; &#125; udelay(10000); &#125; while (!abort &amp;&amp; get_timer(ts) &lt; 1000); printf(&quot;\\b\\b\\b%2d &quot;, bootdelay); &#125; putc(&#x27; &#x27;); return abort;&#125;","tags":["uboot","rk3506"],"categories":["嵌入式"]},{"title":"Qt按钮美化教程","path":"//qt-button-design.html","content":"前言Qt按钮美化主要有三种方式：QSS、属性和自绘 QPushButtonQSS字体大小 1font-size: 18px; 文字颜色 1color: white; 背景颜色 1background-color: rgb(10,88,163); 按钮边框 1border: 2px solid rgb(114,188,51); 文字对齐 1text-align: left; 左侧内边距 1padding-left: 10px; 文字加粗 1font-weight: bold; 边框的大小 1border-width: 4px; 边框的半径 1border-radius: 3px; 整合样式 123456789101112131415QPushButton &#123; font-size: 18px; /* 设置字体大小 */ color: white; /* 设置字体颜色 */ background-color: rgb(10,88,163); /* 设置背景颜色 */ border: 2px solid rgb(114,188,51); /* 设置边框 */ text-align: left; /* 文字左对齐 */ padding-left: 10px; /* 左侧内边距 */ font-weight: bold;&#125;QPushButton:pressed &#123; background-color: rgb(41,51,57); color: rgb(114,188,51); /* 设置字体颜色 */ border-width: 4px;&#125; 属性添加hover tooltip 修改text 焦点策略，一般默认StrongFocus 坐标和大小 自绘重写paintEvent虚函数，这个一般用的不多 12345678CPushButton::paintEvent(QPaintEvent *event)&#123; /* 这里增加自绘的代码：文字、图片等等 */ QPainter p(this); p.drawText(10, 10, &quot;Clicked me&quot;); p.drawPixmap(20, 10, QIcon(&quot;:/res/button.png&quot;)); QPushButton::paintEvent(event);&#125; 效果附上QSS+属性美化后的button效果（自己写的，你嫌丑我还嫌丑哩） QToolButton有时候需要定制图片跟文字同时显示的按钮（在触摸屏用的比较多），QToolButton是一个不错的选择 QSS添加底图 1qproperty-icon: url(:/resource/home.png) center; 底图大小设置 1qproperty-iconSize: 32px 32px; 聚焦时显示激活效果 1234QToolButton::focus&#123;\tbackground-image: url(:/resource/menu-active.png);&#125; 属性改变图片和文字的相对位置 在平板上面操作的话焦点策略改为ClickFocus 自绘QToolButton如无意外，不需要自绘 效果显示效果","tags":["Qt"],"categories":["程序设计"]},{"title":"Qt6串口数据协议解析","path":"//qt6-serial-protocol.html","content":"介绍绑定QSerialPort对象的readyRead信号时，从串口接收缓冲区读取的数据大概率不是一次就能接收完成的，有可能分成n次接收；这是一种什么情况呢，它有可能多次readyRead：1次，2次，3次，4次……这样子！如果不对数据的边界进行有效识别，就很难分别出哪些是我们要的数据 定长协议比如接收够15个字节才算接收完成，可以用QSerialPort::bytesAvailable这个接口进行组包，理论上给出头部标记就能识别有效的一帧数据：$ 10 0123456789 CS 1234567891011121314151617181920212223242526#define MAX_SIZE 15QByteArray buffer;int size = 0;auto callback = [&amp;]() &#123; auto &amp;&amp;data = this-&gt;readData(); if(data.startsWith(&quot;$&quot;)) &#123; size = m_serial-&gt;bytesAvailable(); buffer.clear(); buffer += data; if(size == MAX_SIZE) &#123; size = 0; emit this-&gt;sendOneFrame(buffer); &#125; &#125; else &#123; size += m_serial-&gt;bytesAvailable(); buffer += data; if(size == MAX_SIZE) &#123; size = 0; emit this-&gt;sendOneFrame(buffer); &#125; &#125;&#125;;connect(m_serial, &amp;QSerialPort::readyRead, this, callback); 不定长协议这个需要识别数据的边界（头部跟尾部）在哪里，比如用$头部，@做尾部，我们把分段的数据依次拼接起来 12345678910111213141516171819202122232425QByteArray buffer;auto callback = [&amp;]() &#123; qDebug() &lt;&lt; m_serial-&gt;bytesAvailable(); auto &amp;&amp;data = this-&gt;readData(); if(data.startsWith(&quot;$&quot;)) &#123; buffer.clear(); buffer += data; if(data.endsWith(&quot;@&quot;)) &#123; emit this-&gt;sendOneFrame(buffer); &#125; qDebug() &lt;&lt; &quot;1 : &quot; &lt;&lt; buffer; &#125; else &#123; if(!data.endsWith(&quot;@&quot;)) &#123; buffer += data; qDebug() &lt;&lt; &quot;2 : &quot; &lt;&lt; buffer; &#125; else &#123; buffer += data; qDebug() &lt;&lt; &quot;3 : &quot; &lt;&lt; buffer; emit this-&gt;sendOneFrame(buffer); &#125; &#125;&#125;;connect(m_serial, &amp;QSerialPort::readyRead, this, callback); 总结串口数据解析本质是一个文本处理的过程，如果接收端用C语言写，简单的协议还好，复杂的协议简直要命（请用高级语言）！","tags":["Qt"],"categories":["程序设计"]},{"title":"vim轻度使用","path":"//vim-usage.html","content":"安装 1sudo apt install vim 卸载 1sudo apt remove --purge vim 配置文件 1~/.vimrc 配置 开启行号：set nu 高亮行：set cul 高亮列：set cuc 高亮搜索关键字：set hls 绑定Esc快捷键：inoremap jj &lt;Esc&gt; tab大小配置：set ts&#x3D;4 使用 命令行模式按i、I、a、A可以进入编辑模式 编辑模式下按Esc进入命令行模式 在命令行模式用/关键字向下搜索，?关键字向上搜索 命令行模式用vs垂直分割窗口、sp水平分割窗口 在分割窗口之间移动：先按CTRL + W再按H、L 替换：s/替换前字符/替换后字符/g 命令行模式保存：w 命令行模式退出：q 命令行模式保存并退出：wq 命令行模式强制退出：q! 光标移动 上：k 下：j 左：h 右：l 快捷键 退出编辑器：CTRL + W + Q","tags":["vim"],"categories":["开发工具"]},{"title":"最小git提交","path":"//mini-git-commit.html","content":"先从远程仓库拉新代码 1git fetch 合并分支改动 1git merge origin develop --no-ff 下载远程仓库的更新 1git pull 查看本地修改了哪些文件 1git status -s 添加文件到暂存区 1git add file1 file2 file3 写入提交日志 1git commit -m &quot;这是一段日志&quot; -a 提交到远程仓库 1git push -f origin main","tags":["git"],"categories":["开发工具"]},{"title":"MDK Keil5快捷键","path":"//mdk-keil5-shortcut.html","content":"常见快捷键合集 开始&#x2F;停止调试：CTRL + F5 运行：F5 单步进入：F11 单步跳出：CTRL + F11 单步：F10 执行到指定位置：CTRL + F10 检索：CTRL + F 插入或者移除断点：F9 移除所有断点：CTRL + Shift + F9 烧录程序：F8 编译当前文件：CTRL + F7 构建当前工程：F7 打开工程配置：Alt + F7 跳到指定行：CTRL + G 剪切当前行：CTRL + L 前进：CTRL + Shift + - 后退：CTRL + -","tags":["keil"],"categories":["开发工具"]},{"title":"一个比较理想的嵌入式产品模型","path":"//ideal-embedded-product-model.html","content":"介绍示波器是一个比较典型、通用、明确的嵌入式产品案例，工作这么多年，很多产品业务模型或多或少都跟示波器的开发有点像！我敢说以下列举的软件、硬件、机械的部分在很多嵌入式产品中（不管是医疗、自动化还是汽车电子）普遍存在，所以我觉得自己经常在做示波器的类似物 软件嵌入式软件的复杂度大概在40-50w代码量左右 数据采集：电压、can、温度信号 数据可视化：主要是波形、报文的展示 文件存储：把数据文件录制下来，方便回读分析 HMI用户界面交互：按键、飞梭、旋钮、触摸屏 指令控制：SCPI指令控制设备，完成自动化测量功能 设备校准：一些标定校准的数据文件、抑制设备老化带来的参数漂移 设备驱动：按键板驱动、触摸屏驱动、usb驱动、pcie驱动、数据采集&#x2F;控制驱动 软件升级：自升级 + 外设升级 上位机上位机主要是解析波形文件、指令控制、校准维护、外设升级等功能 web设备调参、诊断使用、OTA升级 操作系统裸机、RTOS、Linux、Windows（配套上位机） 硬件硬件的组成按数字芯片分类有以下几个部分 fpgafpga主要负责前端数据的采集、预处理 armarm是嵌入式软件运行的载体 dsp集成波形处理的算法，这个是算法的载体 mcu按键板、采集卡里边的芯片、电源管理芯片 x64x64是终端软件运行的载体、软件升级工具 机械机械部件比较中规中矩，如探头、机箱外壳、显示屏部件、按键部件、采集卡的外壳 总结综上，示波器是一个终极的嵌入式产品案例，业务模型通常都具有相似性，只要深入了解一个，便可以举一反三","tags":["产品"],"categories":["方法论"]},{"title":"上位机和下位机的基本通信协议","path":"//upper-computer-lower-computer-communication-protocol.html","content":"介绍上位机和下位机的通信方式多种多样，一般有usart、can、usb、ethernet等，走什么通信方式视下位机的设备资源而定；以ethernet tcp通信为例，大部分情形下，下位机即嵌入式设备作为server端，PC端作为client端；嵌入式设备需要默认一个IP地址，比如192.168.137.22，还要有一个端口号，比如8738 帧格式帧格式的设计应包含四个部分：帧头 + 长度 + 数据段 + 校验 帧头：两个字节，例如固定为0xaa 0x55 长度：uint16，大端，整个包的长度，包含帧头、长度、数据段和校验四个部分的总长 度。单个包的最大长度为512 数据段：包荷载的内容，长度不固定 校验：两个字节，帧头、长度和数据段的CRC16计算值，当然也可以用异或校验 心跳包心跳包设计原则： 最好仅支持一个设备连接 客户端请求，服务器应答 约定一个心跳时间，如30秒进行一次心跳查询；还要一个超时时间，如300秒没有任何应答则视为连接已经断开 请求请求报文格式参考：协议码 + 消息类型 + 功能码 + 序号 + 功能数据 应答应答报文格式参考：协议码 + 消息类型 + 功能码 + 序号 + 错误码 + 功能数据 总结以上请求和应答设计范例其实是一种web服务的思想","tags":["通信协议"],"categories":["程序设计"]},{"title":"tar命令","path":"//tar-common-usage.html","content":"查看压缩包比如想看看rootfs.tar里边有什么东西，避免解压有坑 12tar -tf rootfs.tartar tf rootfs.tar.xz 解压默认全部解压，当然参数部分也可以带压缩包类型：J表示xz、j表示bz2、z表示gz 1tar xf demo.tar.xx tar创建默认tar包 1tar -cf archive.tar foo bar xzxz文件压缩 1tar cJf rootfs.tar.xz rootfs/ bz2bz2文件压缩 1tar cjf rootfs.tar.bz2 rootfs/ gzgz文件压缩 1tar czf rootfs.tar.gz rootfs/","tags":["linux"],"categories":["开发工具"]},{"title":"编程中的同步和异步概念","path":"//program-synchronization-asynchronous.html","content":"普通理解同步，即同时进行、一起做，比如：一边开会，一边做笔记，这两件事就是同步进行的 异步，跟同步相反，做事的时间顺序不一致，比如：常见的电影声音和字幕不一致 编程概念同步一个函数如果在调用的时候随即能拿到结果并返回，这就是同步，比如：调用一个LedOn()函数，Led灯就会马上亮起来、函数退出；一般，单线程的环境应用比较多，因为只有一条时间线，干不了很多的活，这是比较好理解的 异步异步调用一般出现在多线程或者中断情景下，有一些事情需要分给不同的任务做，而你又无法准确把握别的任务什么时候完成（它可能不知道干嘛去了），你不想等它，所以只能设置一个回调接口callback来让它告知你，这跟现实世界很像，你打电话给外卖小哥，外卖小哥说他没有空在送别的外卖，让你留个电话号码，等出单或者到了再告诉你，而你又可以不用一直等这个外卖了（忙别的事情），明显你和外卖小哥是活在不同时间线的，双方都很自由；大部分事件处理都是异步调用来的，像按键中断，只有按键值输入的时候你才需要做按键事件处理；还有倍福ADS接口：客户端注册一个回调函数，当事件发生时，ADS库会自动调用该函数，当目标变量（如PLC中的某个变量）的值发生变化时，ADS服务器会主动通知客户端 总结 编程其实是对现实生活的抽象 业务模型也具有普适性，不管物联网、自动化、还是汽车电子","tags":["反思"],"categories":["程序设计"]},{"title":"vscode支持ros2程序debug","path":"//vscode-ros2-debug.html","content":"安装下载 1wget https://az764295.vo.msecnd.net/stable/1a5daa3a0231a0fbba4f14db7ec463cf99d7768e/code_1.84.2-1699528352_amd64.deb 安装 1sudo dpkg -i code_1.84.2-1699528352_amd64.deb 打开 1code . 插件在打开ros2工程前需要安装几个插件 CMake CMake Tools Python Ros XML Tools 配置c_cpp_properties.json这个文件用于配置编译条件，我这里用的是foxy版本的ros2，其他版本可以参考着改 1234567891011121314151617&#123; &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Linux&quot;, &quot;includePath&quot;: [ &quot;$&#123;workspaceFolder&#125;/**&quot;, &quot;/opt/ros/foxy/include/**&quot; ], &quot;defines&quot;: [], &quot;compilerPath&quot;: &quot;/usr/bin/gcc&quot;, &quot;cStandard&quot;: &quot;c99&quot;, &quot;cppStandard&quot;: &quot;c++14&quot;, &quot;intelliSenseMode&quot;: &quot;clang-x64&quot; &#125; ], &quot;version&quot;: 4&#125; launch.json这个文件用于启动ros2 package，target选项用于配置package运行脚本，一般用相对位置比较合适 123456789101112131415&#123; // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;ROS: Launch&quot;, &quot;type&quot;: &quot;ros&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;target&quot;: &quot;./install/aglidar_sdk/share/aglidar_sdk/launch/start.py&quot; &#125; ]&#125; settings.jsonvscode的基本配置，关联一些cpp的库、其它文件类型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&#123; &quot;editor.tabSize&quot;: 8, &quot;editor.rulers&quot;: [ 100 ], &quot;files.associations&quot;: &#123; &quot;*.repos&quot;: &quot;yaml&quot;, &quot;*.world&quot;: &quot;xml&quot;, &quot;*.xacro&quot;: &quot;xml&quot;, &quot;chrono&quot;: &quot;cpp&quot;, &quot;cctype&quot;: &quot;cpp&quot;, &quot;clocale&quot;: &quot;cpp&quot;, &quot;cmath&quot;: &quot;cpp&quot;, &quot;csignal&quot;: &quot;cpp&quot;, &quot;cstdarg&quot;: &quot;cpp&quot;, &quot;cstddef&quot;: &quot;cpp&quot;, &quot;cstdio&quot;: &quot;cpp&quot;, &quot;cstdlib&quot;: &quot;cpp&quot;, &quot;cstring&quot;: &quot;cpp&quot;, &quot;ctime&quot;: &quot;cpp&quot;, &quot;cwchar&quot;: &quot;cpp&quot;, &quot;cwctype&quot;: &quot;cpp&quot;, &quot;any&quot;: &quot;cpp&quot;, &quot;array&quot;: &quot;cpp&quot;, &quot;atomic&quot;: &quot;cpp&quot;, &quot;strstream&quot;: &quot;cpp&quot;, &quot;bit&quot;: &quot;cpp&quot;, &quot;*.tcc&quot;: &quot;cpp&quot;, &quot;bitset&quot;: &quot;cpp&quot;, &quot;codecvt&quot;: &quot;cpp&quot;, &quot;complex&quot;: &quot;cpp&quot;, &quot;condition_variable&quot;: &quot;cpp&quot;, &quot;cstdint&quot;: &quot;cpp&quot;, &quot;deque&quot;: &quot;cpp&quot;, &quot;forward_list&quot;: &quot;cpp&quot;, &quot;list&quot;: &quot;cpp&quot;, &quot;map&quot;: &quot;cpp&quot;, &quot;set&quot;: &quot;cpp&quot;, &quot;unordered_map&quot;: &quot;cpp&quot;, &quot;vector&quot;: &quot;cpp&quot;, &quot;exception&quot;: &quot;cpp&quot;, &quot;algorithm&quot;: &quot;cpp&quot;, &quot;functional&quot;: &quot;cpp&quot;, &quot;iterator&quot;: &quot;cpp&quot;, &quot;memory&quot;: &quot;cpp&quot;, &quot;memory_resource&quot;: &quot;cpp&quot;, &quot;numeric&quot;: &quot;cpp&quot;, &quot;optional&quot;: &quot;cpp&quot;, &quot;random&quot;: &quot;cpp&quot;, &quot;ratio&quot;: &quot;cpp&quot;, &quot;string&quot;: &quot;cpp&quot;, &quot;string_view&quot;: &quot;cpp&quot;, &quot;system_error&quot;: &quot;cpp&quot;, &quot;tuple&quot;: &quot;cpp&quot;, &quot;type_traits&quot;: &quot;cpp&quot;, &quot;utility&quot;: &quot;cpp&quot;, &quot;fstream&quot;: &quot;cpp&quot;, &quot;future&quot;: &quot;cpp&quot;, &quot;initializer_list&quot;: &quot;cpp&quot;, &quot;iomanip&quot;: &quot;cpp&quot;, &quot;iosfwd&quot;: &quot;cpp&quot;, &quot;iostream&quot;: &quot;cpp&quot;, &quot;istream&quot;: &quot;cpp&quot;, &quot;limits&quot;: &quot;cpp&quot;, &quot;mutex&quot;: &quot;cpp&quot;, &quot;new&quot;: &quot;cpp&quot;, &quot;ostream&quot;: &quot;cpp&quot;, &quot;shared_mutex&quot;: &quot;cpp&quot;, &quot;sstream&quot;: &quot;cpp&quot;, &quot;stdexcept&quot;: &quot;cpp&quot;, &quot;streambuf&quot;: &quot;cpp&quot;, &quot;thread&quot;: &quot;cpp&quot;, &quot;cfenv&quot;: &quot;cpp&quot;, &quot;cinttypes&quot;: &quot;cpp&quot;, &quot;typeindex&quot;: &quot;cpp&quot;, &quot;typeinfo&quot;: &quot;cpp&quot;, &quot;valarray&quot;: &quot;cpp&quot;, &quot;variant&quot;: &quot;cpp&quot; &#125;, // Autocomplete from ros python packages &quot;python.autoComplete.extraPaths&quot;: [ &quot;/opt/ros/foxy/lib/python3.8/site-packages/&quot; ], // Environment file lets vscode find python files within workspace &quot;python.envFile&quot;: &quot;$&#123;workspaceFolder&#125;/.env&quot;, // Use the system installed version of autopep8 &quot;python.formatting.autopep8Path&quot;: &quot;/usr/bin/autopep8&quot;, &quot;python.formatting.autopep8Args&quot;: [ &quot;--max-line-length=100&quot; ], &quot;C_Cpp.default.intelliSenseMode&quot;: &quot;clang-x64&quot;, &quot;C_Cpp.formatting&quot;: &quot;Disabled&quot;, &quot;uncrustify.useReplaceOption&quot;: true, &quot;uncrustify.configPath.linux&quot;: &quot;/opt/ros/foxy/lib/python3.8/site-packages/ament_uncrustify/configuration/ament_code_style.cfg&quot;, &quot;cSpell.words&quot;: [ &quot;RTPS&quot;, &quot;athackst&quot;, &quot;autopep&quot;, &quot;cmake&quot;, &quot;cppcheck&quot;, &quot;cpplint&quot;, &quot;deque&quot;, &quot;devcontainer&quot;, &quot;ints&quot;, &quot;noqa&quot;, &quot;pytest&quot;, &quot;rclcpp&quot;, &quot;rclpy&quot;, &quot;repos&quot;, &quot;rosdistro&quot;, &quot;rosidl&quot;, &quot;uncrustify&quot;, &quot;xmllint&quot; ], &quot;search.exclude&quot;: &#123; &quot;**/node_modules&quot;: true, &quot;**/bower_components&quot;: true, &quot;**/*.code-search&quot;: true, &quot;**/build&quot;: true, &quot;**/install&quot;: true, &quot;**/log&quot;: true &#125;, &quot;python.analysis.extraPaths&quot;: [ &quot;/opt/ros/foxy/lib/python3.8/site-packages/&quot; ], &quot;cSpell.allowCompoundWords&quot;: true, &quot;cSpell.ignorePaths&quot;: [ &quot;**/package-lock.json&quot;, &quot;**/node_modules/**&quot;, &quot;**/vscode-extension/**&quot;, &quot;**/.git/objects/**&quot;, &quot;.vscode&quot;, &quot;.vscode-insiders&quot;, &quot;.devcontainer/devcontainer.json&quot; ], &quot;ros.distro&quot;: &quot;foxy&quot;, &quot;cmake.sourceDirectory&quot;: &quot;/home/asensing/workspace/Asensing_LiDAR_ROS/aglidar_sdk&quot;&#125; tasks.json编译任务配置，debug需求的可以改成debug编译类型 123456789101112131415161718&#123; // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ &#123; &quot;label&quot;: &quot;build&quot;, &quot;detail&quot;: &quot;Build workspace (default)&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;colcon build --cmake-args &#x27;-DCMAKE_BUILD_TYPE=Debug&#x27; -Wall -Wextra -Wpendantic&quot;, &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true &#125;, &quot;problemMatcher&quot;: &quot;$gcc&quot; &#125; ]&#125; 调试调试快捷键列表，基本就是Visual Studio那一套 序号 功能 按键 1 单步 F10 2 单步进入 F11 3 单步跳出 Shift + F11 4 恢复 F5 5 暂停 F5 6 停止 Shift + F5 7 重新运行 Ctrl + Shift + F5 8 运行task编译工程 Ctrl + Shift + B 9 切换断点 F9 10 前进 Ctrl + Shift + - 11 后退 Ctrl + Alt + - 12 运行 Ctrl + Shift + D 调试界面效果","tags":["ROS2"],"categories":["开发工具"]},{"title":"QMainWindow子窗口独立全屏","path":"//qmainwindow-subwindow-fullscreen.html","content":"事件过滤器QMainWindow的子类对象的构造函数中安装事件过滤器 1centralWidget()-&gt;installEventFilter(this); 信号和槽由QAction触发进入全屏 123456connect(this-&gt;Internals-&gt;actionFull_Screen, &amp;QAction::triggered, this, [=](bool flag) &#123; auto widget = centralWidget(); m_windowFlags = widget-&gt;windowFlags(); widget-&gt;setWindowFlag(Qt::Window); widget-&gt;showFullScreen();&#125;); 退出全屏重写QMainWindow子类对象的eventFilter虚函数，在里边添加以下代码 12345678910if(obj == centralWidget() &amp;&amp; ev-&gt;type() == QEvent::KeyPress) &#123; auto keyEvent = static_cast&lt;QKeyEvent *&gt;(ev); if(keyEvent-&gt;key() == Qt::Key_Escape) &#123; auto widget = centralWidget(); widget-&gt;setWindowFlags(m_windowFlags); widget-&gt;showNormal(); this-&gt;Internals-&gt;actionFull_Screen-&gt;setChecked(false); return true; &#125;&#125;","tags":["Qt"],"categories":["嵌入式"]},{"title":"Qt工程远程调试","path":"//qt-project-remote-debug.html","content":"准备1）需要准备一些工具（交叉编译） ssh：openssh或者dropbear，开发板端部署sshd、宿主机端部署ssh sftp：一般跟ssh配套的，这个也放开发板端 arm-gdb：放在宿主机端 gdbserver：放在开发板端 2）在QtCreator添加Remote Device，保证ssh连接上 3）在Build &amp; Run里边配置Kits Device Sysroot Compiler Debugger Qt version cmakeQtCreatorDeployment.txt写法参考 12远程绝对路径宿主文件路径:远程相对路径 实践：添加开发板所需要的文件到&#x2F;mnt目录 123/mnt//home/uisrc/project/lidarConfig_A_MEMS.json:data/home/uisrc/project/LDR0011A0_APP/demoApp:bin qmakeqmake pro文件写法：local.path表示本地路径，target.path表示远程路径，通过addFiles的属性赋值添加要部署的目录或文件 123456local.path = $$OUT_PWDlocal.path ~= s/builds.*/target.path = /rootaddFiles.path = $$target.pathaddFiles.files += file1addFiles.files += file2 实践：部署app放到&#x2F;root目录下 1234local.path = $$OUT_PWDlocal.path ~= s/builds.*/target.path = /rootINSTALLS += target 运行配置以下是工程配置参考","tags":["Qt","调试"],"categories":["嵌入式"]},{"title":"增量和存量市场","path":"//incremental-stock-market.html","content":"前言作为一名技术人，要对产品的市场动态时刻保持敏感，了解产品的昨天、今天、明天，才能有的放矢；不懂产品的程序员不是好程序员，我去过的公司，大部分也是程序员主导产品的研发流程，一部分人要承担项目前期的需求挖掘、客户拜访、可行性调研、产品文档编写、技术支持、产品运营等工作，可见市场敏感度对技术人来说很重要 增量市场定义 市场存在大量的需求，产品的潜力未有被充分挖掘，各种因素如政治、经济、疫情等导致需求的爆发，各方有百花齐放的趋势，巨头还没有出现，人称蓝海 特点 产品还没有充分被定义，存在着各种各样的发展方向和技术路线 需求量比较大，有引领时代潮流的趋势，堪称风口 时效性，产品也有它的生命周期，不会永远保持旺盛的产品力 与地缘政治、经济因素、社会动态强烈相关 识别 激光雷达：2022年激光雷达是增量市场，但2024年不是 半导体设备：如光刻机、CVD、PVD、Etch设备等 机器人：医护机器人、工业机器人等 核磁共振设备 存量市场定义 产品已经被定义、被市场接纳，行业的巨头有形成垄断的趋势，价格已经被打下来，利润空间很少了，称为红海，一般不建议加入存量市场 特点 需求已经明确，供应链稳定 行业垄断，头部竞争者占据优势地位（资本、技术、市场、人才） 利润空间不大 识别 2022年激光雷达是增量市场，但2024年不是，如今的汽车也不再是增量市场 2024年的新能源汽车是存量市场，价格战越演越烈，特斯拉、比亚迪等巨头体量优势特别明显，新势力则是赔本赚吆喝 公民教育，随着人口出生率下降，受教育的需求没有以前那么旺盛，教育市场已趋于饱和","tags":["产品"],"categories":["方法论"]},{"title":"汽车零部件研发的各个阶段","path":"//auto-parts-stage.html","content":"A样原型机开发阶段，问题较多且功能有限，以功能原理验证为主，一般是人工制造为主，比如拼模块组装，简易打板或者直接购买demo板 B样积累了一定的解决问题的经验，基本结构已经成型（产品参数），也有了成型的PCB板，软硬件处于不断的磨合阶段，此阶段硬件、软件的改动比较频繁，产品研发的主要阶段，持续时间比较长，还是人工制造为主 C样已经能够在生产线小批量生产，快速部署，还需要进行各项测试，可以借助一些自动化软件、设备辅助生产，提高生产效率 D样已经能够批量交付用户使用，可用于相关部门的检查、认证，此时也有完整的用户手册，出现问题也有技术支持","tags":["产品"],"categories":["方法论"]},{"title":"项目概要设计说明书","path":"//project-overview-specification.html","content":"项目介绍xxx是一个什么样的项目，技术点、人力投入、工期 需求概述把客户的目标需求大致讲清楚 应用领域 运行环境 功能指标 性能指标 条件限制 技术可行性分析材料、结构、硬件、软件、测试角度分析 需要采购什么设备、走什么认证流程、用什么测试手段 系统架构 &#x2F; 总体设计软硬件系统组成结构 上位机 下位机 服务器 通信协议 功能模块对系统架构里边的模块逐一拆解、分析，列出系统框图 模块1 模块2 模块3 每个模块工作流程图 流程1 流程2 流程3 接口设计模块的通信接口进行定义 接口1 接口2 接口3 通信协议硬件接口 软件协议 测试前置依赖：需要什么人、什么设备、什么条件 性能、参数指标测试 黑盒、白盒 维护客户现场出现问题怎么解决，材料、结构、硬件、软件的职责范围","tags":["管理"],"categories":["方法论"]},{"title":"Ubuntu22.04搭建ROS2运行环境","path":"//ubuntu22.04-install-ros2.html","content":"区域语言设置设置区域语言为US 123456789sudo apt updatesudo apt install localessudo locale-gen en_US en_US.UTF-8sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8export LANG=en_US.UTF-8 必备软件组件如果已经安装，可以跳过这一步骤 1234567sudo apt updatesudo apt-get install -y libyaml-cpp-devsudo apt-get install -y libpcap-devsudo apt install -y curl gnupg lsb-release 更新远程仓库源更新/etc/hosts文件，防止raw.githubusercontent.com被墙，可以通过nslookup命令查看域名服务器地址 12345185.199.110.133\traw.githubusercontent.com185.199.110.133 user-images.githubusercontent.com185.199.110.133 avatars2.githubusercontent.com185.199.100.133 avatars1.githubusercontent.com20.205.243.166 github.com 如果已经添加过源，这一步也可以跳过 12345sudo curl -sSL http://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpgecho &quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(source /etc/os-release &amp;&amp; echo $UBUNTU_CODENAME) main&quot; | sudo tee /etc/apt/sources.list.d/ros2.list &gt; /dev/nullsudo apt update 安装humble桌面版和基础版二选一 12sudo apt install ros-humble-desktop # 桌面版sudo apt install ros-humble-ros-base\t# 基础版 安装软件包colcon和libbackward-ros都安装一下 12sudo apt-get install python3-colcon-common-extensionssudo apt-get install -y ros-humble-backward-ros 验证ROS2借用小乌龟来验证是否成功，humble版本如果没有预装turtlesim的话请事先安装 1sudo apt install ros-humble-turtlesim 运行turtlesim_node和turtle_teleop_key两个节点 123source /opt/ros/humble/setup.bashros2 run turtlesim turtlesim_noderos2 run turtlesim turtle_teleop_key 控制效果 完全卸载如果你不想用humble这个版本，请用以下命令卸载干净 1sudo apt-get autoremove --purge ros-humble-desktop","tags":["ROS2"],"categories":["操作系统"]},{"title":"解决csv文件导出时间戳精度丢失的问题","path":"//csv-file-lose-precision.html","content":"丢失精度以圆周率数据输出为例，如果直接通过ostream输出到文件，则会丢失精度 123ostream stream;double value = 3.1415926;stream &lt;&lt; value; 保留精度需要通过std::setprecision函数来指定浮点数的精度 123ostream stream;double value = 3.1415926;stream &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; value;","tags":["C++"],"categories":["程序设计"]},{"title":"Windows程序读取不了中文路径问题","path":"//windows-program-chinese-path-problem.html","content":"问题描述今天调试发现win32接口GetFileAttributesW居然不支持中文路径，于是寻找解决方案，找了半天，尝试用boost的fileystem库发现能解决问题，而且boost能跨平台！ 不支持中文win32接口获取文件属性，当传入参数带有中文字符时，它获取的属性就会异常 1DWORD GetFileAttributesW([in] LPCWSTR lpFileName); 支持中文boost判断是否为文件 123std::string realpath = &quot;D:\\\\新建文件夹\\\\a.txt&quot;;boost::filesystem::path p(realpath);boost::filesystem::is_regular_file(p); boost判断是否为文件夹 123std::string realpath = &quot;D:\\\\新建文件夹&quot;;boost::filesystem::path p(realpath);boost::filesystem::is_directory(p); 总结人生苦短，我用boost！","tags":["Windows"],"categories":["程序设计"]},{"title":"嵌入式代码优化技巧","path":"//embedded-code-optimization.html","content":"内存管理技巧1.C&#x2F;C++工程应尽量避免深拷贝，尽量用浅拷贝（指针或者引用），如果指针需要频繁拷贝，用智能指针是一种不错的选择 2.启用内存池管理线程的内存开销，事先在堆里边分配好，然后快速使用 避免复杂的浮点运算1.复杂的浮点运算尽量避免，有些芯片是不支持硬件双精度浮点数的，比如全志T3，实在是非用不可，可以用查表的方式加快速度 2.数据传输可以用整型数据压缩减少带宽，这个在can数据传输比较常见 空间换时间比如一个数据模型体积很大，加载起来很耗时，可以考虑把它编译到软件里边去，然后运行的时候提前加载到内存 算法复杂度优化1.时间复杂度，减少循环使用次数 2.空间复杂度的角度优化 并行框架openMP了解一下，在关键的代码段加上omp并行处理 字节对齐用好字节对齐功能可以优化cpu流水线的处理效率 内核态的利用可以把一些业务操作写进驱动，利用操作系统的调度优化，内核态和用户态哪一个更高效，这个是相对的，得看系统调用和库函数的颗粒度，可以值得尝试一下 线程调度尝试调整一些线程的优先级提高调度效率，另外Linux也允许绑核操作 防御性编程 申请一段buffer后总是习惯性的将其内容memset为0，当然这是针对plain类型的数据，防止在数据解析的时候解析到不合法的数据 总是习惯性的判断数组的边界 申请指针不应该悬空，应该给它一个值或者是nullptr，使用前判断它是否为空 巧用断言","tags":["调优"],"categories":["嵌入式"]},{"title":"软件版本那些事","path":"//software-version.html","content":"软件版本跟测试阶段或者软件的生命周期所处的阶段有关，一般有以下几个版本 alpha内测版本，仅限团队内部测试使用，不对外公开。大多数软件产品在向公众发布之前都要经过多个步骤。alpha版本是该系统的一部分，用于开发高效、准确和无缺陷的软件程序。这一阶段软件会频繁改动。 项目处于不稳定状态。可能有许多未修复的错误，包括安全问题。API可能会更改，恕不另行通知。安装新的alpha版本需要卸载项目，从而丢失所有数据。只针对那些想要提前预览项目的人。尚不适合共享发展。不适合生产现场使用。目标受众是希望参与项目测试、调试和开发的开发人员。 beta通过内部测试之后的版本，开放给外部渠道使用。Beta版本通常在外观、感觉和功能上与最终产品相当接近；在这一阶段变更还是会经常发生。 所有重要的数据丢失和安全漏洞得到解决。如果模块提供了一个API，它应该被认为是冻结的，这样那些使用API的人就可以开始升级他们的项目了。如果是项目的升级或更新，则应提供升级&#x2F;更新路径，并且现有用户应该能够在不丢失数据的情况下升级&#x2F;更新到新版本。所有文档都应该是最新的。目标受众是想要参与项目的测试、调试和开发的开发人员，以及与项目对接的其他项目的开发人员。通常不适用于生产站点，但如果站点管理员非常了解项目，并且知道如何处理任何遗留问题，则可以在某些生产站点上使用。 rcrelease candidate，beta版本迭代之后比较成熟的版本，按照惯例，每当程序的更新几乎准备就绪时，测试版本就会被赋予rc号。如果发现了需要修复的关键错误，则更新程序并以更高的rc号重新发布。当没有严重错误存在，或者没有发现额外的严重错误时，rc名称将被删除。 release正式提供给客户使用的版本 stablerelease版本中的稳定版本，一般比较少使用","tags":["版本"],"categories":["方法论"]},{"title":"程序员健康指南","path":"//programmer-health-guide.html","content":"前言前不久，IT界的大佬左耳朵耗子陈皓心梗逝世，享年仅47岁，真是天妒英才，据说他是一名工作狂…… 感慨好的身体是革命的本钱，年纪越大，就会发现编程并不是脑力活，其实更偏向体力活！长时间工作吃的是人的体力和精力，开会、写文档、编码、测试样样工作都需要有充沛和持续的精力投入；在中国这种996工作制遍地开花的国度，如果你没有铁一样的身体素质，你基本很难熬35岁这道坎，这也是为什么很多公司喜欢招小年轻的原因；并且，久坐在办公室容易引发很多疾病：眼疲劳、关节疼痛、头晕眼花、颈椎病……新闻经常能听到这样的剧本：某某大厂员工在加班的时候突然猝死，留下背负房贷的妻儿老小……说了这么多，想必大家已经知道拥有一个好身体对程序员来说是多么的重要，下面将从几个方面介绍一些程序员健康指南，希望能对广大程序员有所帮助 作息篇 早点睡 多睡点 睡好点 尽量午睡 饮食篇 少吃甜食 少盐 少油 多喝水 荤素搭配 运动篇 慢跑 &#x2F; 散步，Linus就是在家里买了一台跑步机，边跑步边编码 伸腿、弯腰 到户外去，city walk或者到公园散散心都可以 工作篇 番茄工作法，将一个任务分解一个个工作包，以一个工作包为单位执行 学会坦然，现实生活中技术问题往往不是最重要的问题，大多数问题也跟编程无关 向上管理，遇到问题学会及时反馈，而不是一个人扛着 提高工作效率，要做的事情排一个优先级 生活篇 多遵循内心的意愿 学会拒绝 有什么喜欢的事情要趁着年轻去追寻，尝试一些爱好，如学学钢琴、听听音乐会 张弛有道，切勿绷得像机械钟的发条一样紧 社交篇 尊重他人的想法 尊重自己的内心 语录《活着》 没有什么比时间更具有说服力了，因为时间无需通知我们就可以改变一切 人是为活着本身而活着，而不是为了活着之外的任何事物所活着 一个人命再大，要是自己想死，那就怎么也活不了 《百年孤独》 我们终究会死。所以我们的人生目标不该是长命百岁，而应该做点自己想做的","tags":["健康"],"categories":["学科"]},{"title":"gdb8.3交叉编译","path":"//gdb8.3-porting.html","content":"下载去gdb官网下载gdb8.3 1wget https://ftp.gnu.org/gnu/gdb/gdb-8.3.tar.xz 下载完成后解压xz文件 12tar xf gdb-8.3.tar.xzcd gdb-8.3 配置环境变量 1export PATH=$PATH:/home/topeet/rk3399/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin 编译gdb 12./configure --target=aarch64-linux-gnu --prefix=$PWD/buildmake -j8 编译gdbserver 123cd gdb./configure --target=aarch64-linux-gnu --host=aarch64-linux-gnu --prefix=$PWD/build CXXFLAGS=&#x27;-fPIC -static&#x27;make -j8 测试将gdbserver部署到开发板文件系统，并运行gdbserver 1gdbserver --multi :10000 demo 宿主机端运行aarch64-linux-gnu-gdb 1target remote 192.168.137.22:10000","tags":["gdb"],"categories":["嵌入式"]},{"title":"about","path":"/about/index.html","content":"hywing’s blog作者嵌入式全栈开发者，从事物联网、自动化、汽车电子开发工作 内容分享一些工作中的问题、想法，与技术、管理、产品相关的记录、思考、沉淀，希望对读者有帮助 原则 尽量简短 尽量少图片 尽量准确 免责这个是我的个人博客，如果对你有帮助是我莫大的荣幸，自行更改请恕不另行通知！"}]