[{"title":"开源软件使用指南","path":"//open-software-guide.html","content":"视频播放 VLC Media Player 图像编辑 GIMP 文本编辑器 VSCode nodepad++ 开源的IDE QtCreator 文档系统 MrDoc 开源云盘 openmediavault 项目管理 Overview - Redmine PingCode 缺陷管理 Bugzilla 办公套件 LibreOffice","tags":["开源"],"categories":["方法论"]},{"title":"RT-Thread拉新工程编译报错","path":"//rt-thread-new-project-compile-problem.html","content":"问题一拉新RT-Thread开源代码后发现编译出错，rt_vsnprintf库编译有问题 1.\\build\\keil\\Obj\\rt-thread.axf: Error: L6218E: Undefined symbol rt_vsnprintf (referred from kstdio.o). 打开menuconfig ：RT-Thread Kernel → klibc options → rt_vsnprintf options，开启以下选项 问题二rt_vsscanf库编译问题 1.\\build\\keil\\Obj\\rt-thread.axf: Error: L6218E: Undefined symbol rt_vsscanf (referred from kstdio.o). 打开menuconfig ：RT-Thread Kernel → klibc options → rt_vsscanf options，开启以下选项 总结这两个问题是因为RT-Thread改了rt_vsnprintf和rt_vsscanf两个库的链接方式：做成了开关的配置形式","tags":["RT-Thread"],"categories":["嵌入式"]},{"title":"cmake自定义软件信息","path":"//cmake-define-software-info.html","content":"版本号 1add_definitions(-DSOFTWARE_VERSION=&quot;1.0.2&quot;) 编译类型 1add_definitions(-DBUILD_TYPE=&quot;Debug&quot;) 作者信息 1add_definitions(-DAUTHOR=&quot;hywing&quot;) 公司 1add_definitions(-DCOMPANY=&quot;iotstuff&quot;) 编译生成时间 12string(TIMESTAMP CURRENT_TIME &quot;%Y-%m-%d %H:%M:%S&quot;)add_definitions(-DBUILD_DATE=&quot;$&#123;CURRENT_TIME&#125;&quot;) 以上信息在cmake中通过add_definitions关键字生成相应的宏定义，在代码中只要直接使用这些宏就可以了 12ui-&gt;version-&gt;setText(SOFTWARE_VERSION);ui-&gt;buildDate-&gt;setText(BUILD_DATE); 如果你在一个工程代码中点击找不到宏定义的出处，那么它大概率在工程文件中被定义了！","tags":["cmake"],"categories":["程序设计"]},{"title":"stm32移植LCD2002驱动","path":"//stm32-lcd2002-driver.html","content":"介绍LCD2002支持20X2个字符串显示，引脚功能和读写时序跟LCD1602都很像 LCD类型：字符点阵 点 阵 数：20×2 外形尺寸：116.0mm×37.0mm（长宽） 视域尺寸：83.0mm×18.6mm 点 距 离：0.05mm×0.05mm 点 大 小：0.65mm×0.6mm 控 制 器：SPLC780 玻璃类型：FSTN或STN 显示内容：20（例）×2（行） 背光类型：LED白光（白底黑字，蓝底白字） 数据传输：并口 工作电压：5V LCD2002的应用场景有： 物联网数据采集端显示：展示传感器数值 工业自动化：电机控制展示信息 嵌入式场景：智能家居终端设备 引脚LCD2002有16Pin引脚，每个引脚功能如下 管脚号 符号 功能 1 Vss 电源地（ GND） 2 Vdd 电源电压(+5V) 3 V0 LCD 驱动电压(可调) 4 RS 寄存器选择输入端，输入 MPU 选择模块内部寄存器类型信号：RS&#x3D;0，当 MPU 进行写模块操作，指向指令寄存器；当 MPU 进行读模块操作，指向地址计数器；RS&#x3D;1，无论 MPU 读操作还是写操作，均指向数据寄存器 5 R&#x2F;W 读写控制输入端，输入 MPU 选择读&#x2F;写模块操作信号：R&#x2F;W&#x3D;0 读操作； R&#x2F;W&#x3D;1 写操作 6 E 使能信号输入端，输入 MPU 读&#x2F;写模块操作使能信号：读操作时，高电平有效；写操作时，下降沿有效 7 DB0 数据输入&#x2F;输出口， MPU 与模块之间的数据传送通道 8 DB1 数据输入&#x2F;输出口， MPU 与模块之间的数据传送通道 9 DB2 数据输入&#x2F;输出口， MPU 与模块之间的数据传送通道 10 DB3 数据输入&#x2F;输出口， MPU 与模块之间的数据传送通道 11 DB4 数据输入&#x2F;输出口， MPU 与模块之间的数据传送通道 12 DB5 数据输入&#x2F;输出口， MPU 与模块之间的数据传送通道 13 DB6 数据输入&#x2F;输出口， MPU 与模块之间的数据传送通道 14 DB7 数据输入&#x2F;输出口， MPU 与模块之间的数据传送通道 15 A 背光的正端+5V 16 K 背光的负端 0V 原装的LCD并没有焊接排针，需要自己手动焊接 移植引脚定义，一般只需要用到以下13个Pin 12345678910111213#define LCD_RS_PIN GET_PIN(A, 4)#define LCD_RW_PIN GET_PIN(A, 5)#define LCD_E_PIN GET_PIN(A, 6)#define LCD_D0_PIN GET_PIN(A, 7)#define LCD_D1_PIN GET_PIN(B, 0)#define LCD_D2_PIN GET_PIN(B, 1)#define LCD_D3_PIN GET_PIN(B, 2)#define LCD_D4_PIN GET_PIN(B, 10)#define LCD_D5_PIN GET_PIN(B, 11)#define LCD_D6_PIN GET_PIN(B, 12)#define LCD_D7_PIN GET_PIN(B, 13)#define LCD_V0 GET_PIN(B, 4)#define LCD_BL GET_PIN(B, 5) 初始化LCD2002引脚 12345678910111213141516void LCD_GPIO_Init() &#123; rt_pin_mode(LCD_V0, PIN_MODE_OUTPUT); rt_pin_mode(LCD_BL, PIN_MODE_OUTPUT); rt_pin_mode(LCD_RS_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LCD_RW_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LCD_E_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LCD_D0_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LCD_D1_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LCD_D2_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LCD_D3_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LCD_D4_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LCD_D5_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LCD_D6_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LCD_D7_PIN, PIN_MODE_OUTPUT);&#125; 写数据 1234567891011121314151617void LCD_WriteData(uint8_t data) &#123; rt_pin_write(LCD_RS_PIN, PIN_HIGH); rt_pin_write(LCD_RW_PIN, PIN_LOW); rt_pin_write(LCD_E_PIN, PIN_LOW); rt_pin_write(LCD_D0_PIN, (data &amp; 0x01) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D1_PIN, (data &amp; 0x02) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D2_PIN, (data &amp; 0x04) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D3_PIN, (data &amp; 0x08) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D4_PIN, (data &amp; 0x10) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D5_PIN, (data &amp; 0x20) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D6_PIN, (data &amp; 0x40) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D7_PIN, (data &amp; 0x80) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_E_PIN, PIN_HIGH); rt_thread_mdelay(5); rt_pin_write(LCD_E_PIN, PIN_LOW); &#125; 写命令 1234567891011121314151617void LCD_WriteCommand(uint8_t command) &#123; rt_pin_write(LCD_RS_PIN, PIN_LOW); rt_pin_write(LCD_RW_PIN, PIN_LOW); rt_pin_write(LCD_E_PIN, PIN_LOW); rt_pin_write(LCD_D0_PIN, (command &amp; 0x01) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D1_PIN, (command &amp; 0x02) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D2_PIN, (command &amp; 0x04) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D3_PIN, (command &amp; 0x08) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D4_PIN, (command &amp; 0x10) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D5_PIN, (command &amp; 0x20) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D6_PIN, (command &amp; 0x40) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D7_PIN, (command &amp; 0x80) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_E_PIN, PIN_HIGH); rt_thread_mdelay(5); rt_pin_write(LCD_E_PIN, PIN_LOW); &#125; 设置光标位置 12345678void LCD_SetCursor(uint8_t col, uint8_t row) &#123; uint8_t address = col; if (row == 1) &#123; address += 0x40; &#125; LCD_WriteCommand(0x80 | address); &#125; 绘制字符，需要配合LCD_SetCursor接口使用 123456void LCD_Print(char* str) &#123; while (*str) &#123; LCD_WriteData(*str++); &#125;&#125; LCD初始化，设置清屏、光标位置自动累加等 12345678910111213void LCD_Init() &#123; rt_pin_write(LCD_V0, PIN_HIGH); rt_pin_write(LCD_BL, PIN_HIGH); rt_thread_mdelay(15); LCD_WriteCommand(0x38); rt_thread_mdelay(5); LCD_WriteCommand(0x0c); rt_thread_mdelay(5); LCD_WriteCommand(0x06); rt_thread_mdelay(5); LCD_WriteCommand(0x01); rt_thread_mdelay(5);&#125; 测试用例，在屏幕第一行显示Levitation字样 123456789101112131415161718192021222324252627282930static void lcd2002_entry(void* parameter) &#123;\tLCD_GPIO_Init(); LCD_Init();\tLCD_WriteCommand( 0x80 ); LCD_SetCursor(5, 0); LCD_Print(&quot;Levitation&quot;); while(1) &#123; rt_thread_mdelay(500); &#125;&#125;int main()&#123;\t// lcd2002 rt_thread_t lcd2002_thread = rt_thread_create(&quot;lcd2002&quot;, lcd2002_entry, RT_NULL, 512, 21, 20); if (lcd2002_thread != RT_NULL) &#123; rt_thread_startup(lcd2002_thread); &#125; while (1) &#123; rt_pin_write(LED0_PIN, PIN_HIGH); rt_thread_mdelay(10); rt_pin_write(LED0_PIN, PIN_LOW); rt_thread_mdelay(10); &#125; return RT_EOK;&#125; 显示效果 总结买的是5V供电的LCD2002，但它的数据引脚是可以兼容3.3V的GPIO的，详细可参考数据手册关于芯片引脚电气特性的说明 立创上面汉昇的LCD2002背光引脚BLK、BLA的说明是错误的","tags":["stm32","LCD2002"],"categories":["嵌入式"]},{"title":"下位机没有RTC模块如何做时间同步","path":"//lower-device-time-sync.html","content":"如题：开发环境下，如果stm32没有板载RTC模块，怎么跟上位机做时间同步呢？ 如果有以太网，可以考虑移植NTP协议，借用网络中比较可靠的时钟源作为时间参考 如果有串口，可以考虑使用GNSS模块，获取NMEA-0183卫星时间作为时间参考，GNSS也带有PPS做时间校准 如果跟上位机建立通信连接，可以采用上位机时刻+定期心跳机制获取一个大致的时间参考 如果跟PLC建立EtherCAT通信，也可以用PLC的时间做参考","tags":["下位机","RTC","时间同步"],"categories":["嵌入式"]},{"title":"msvc与g++编译器字符编码问题","path":"//msvc-g++-coder-problem.html","content":"介绍同一份代码，都是用utf-8保存的文件，用g++编译中文是不会乱码的，换成msvc2017编译就乱码了 解决在包含中文的源文件头部添加以下代码，设置字符编码为utf-8 123#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1600)# pragma execution_character_set(&quot;utf-8&quot;)#endif","tags":["msvc","g++","编译器","字符编码"],"categories":["程序设计"]},{"title":"信号和槽函数重载写法参考","path":"//qt-signal-slot-overload.html","content":"信号重载最常见的重载信号就是QComboBox::currentIndexChanged，它有int和const QString &amp;两种重载参数 12345678910111213connect(ui-&gt;algorithm, QOverload&lt;int&gt;::of(&amp;QComboBox::currentIndexChanged), this, [=](int index) &#123; if(index == 0) &#123; this-&gt;initTable(PID); &#125; else &#123; this-&gt;initTable(Model); &#125; emit this-&gt;changeAlgorithm(index);&#125;);connect(ui-&gt;algorithm, QOverload&lt;const QString &amp;&gt;::of(&amp;QComboBox::currentIndexChanged), this, [=](const QString &amp;text) &#123; qDebug() &lt;&lt; text;&#125;); 槽函数重载以传递自定义参数类型为例，自定义结构体需要注册成Qt的元数据类型 123456789101112131415#pragma pack (4)typedef struct &#123; ...&#125; TAlgorithmModel;#pragma pack ()Q_DECLARE_METATYPE(TAlgorithmModel *)#pragma pack (4)typedef struct &#123;\t...&#125; TAlgorithmPid;#pragma pack ()Q_DECLARE_METATYPE(TAlgorithmPid *) 发送方信号 123// 原始信号void NetworkManager::updateModel(const TAlgorithmModel *);void NetworkManager::updatePid(const TAlgorithmPid *); 接收方槽函数重载 123// 重载槽函数void OperatePage::onUpdateTable(const TAlgorithmModel *p);void OperatePage::onUpdateTable(const TAlgorithmPid *p); 信号和槽写法参考 12connect(NetworkManager::getInstance(), &amp;NetworkManager::updateModel, operate, QOverload&lt;const TAlgorithmModel *&gt;::of(&amp;OperatePage::onUpdateTable));connect(NetworkManager::getInstance(), &amp;NetworkManager::updatePid, operate, QOverload&lt;const TAlgorithmPid *&gt;::of(&amp;OperatePage::onUpdateTable));","tags":["Qt","信号","槽","重载"],"categories":["程序设计"]},{"title":"git仓库重定向","path":"//git-repository.html","content":"前言在开发过程，如果想把代码从某一个仓库转移到另外一个仓库，比如，你现在在gitee上面有一个zhd-desktop的仓库，后面你不想要了，你想把它放到GitHub上面，怎么办才能保留原来的提交信息和分支呢？ 解决命令行 在原来的仓库里边添加远端仓库链接 1git remote add upstream https://github.com/hywing/zhd-desktop.git 往upstream推送develop分支 1git push upstream develop -f tortoiseGit 先添加远程仓库 选择远程仓库后push","tags":["git","upstream"],"categories":["开发工具"]},{"title":"long数据类型跨平台问题","path":"//long-data-size.html","content":"示例代码以下代码用于打印long类型数据的大小 1234567#include &lt;iostream&gt;int main()&#123;\tstd::cout &lt;&lt; &quot;size of long : &quot; &lt;&lt; sizeof(long) &lt;&lt; std::endl;\treturn 0;&#125; WindowsQt5.12.9 MSVC2017 64bit编译器：long -&gt; 32位 LinuxQt5.12.9 g++9.4.0编译器：long -&gt; 64位 建议跨平台程序尽量采用跨平台库，如Boost 123456789101112131415161718192021222324252627282930313233343536373839namespace boost&#123; using ::int8_t; using ::int_least8_t; using ::int_fast8_t; using ::uint8_t; using ::uint_least8_t; using ::uint_fast8_t; using ::int16_t; using ::int_least16_t; using ::int_fast16_t; using ::uint16_t; using ::uint_least16_t; using ::uint_fast16_t; using ::int32_t; using ::int_least32_t; using ::int_fast32_t; using ::uint32_t; using ::uint_least32_t; using ::uint_fast32_t;# ifndef BOOST_NO_INT64_T using ::int64_t; using ::int_least64_t; using ::int_fast64_t; using ::uint64_t; using ::uint_least64_t; using ::uint_fast64_t;# endif using ::intmax_t; using ::uintmax_t;&#125; 或者stdint.h 1234567891011121314151617181920212223242526272829typedef signed char int8_t;typedef short int16_t;typedef int int32_t;typedef long long int64_t;typedef unsigned char uint8_t;typedef unsigned short uint16_t;typedef unsigned int uint32_t;typedef unsigned long long uint64_t;typedef signed char int_least8_t;typedef short int_least16_t;typedef int int_least32_t;typedef long long int_least64_t;typedef unsigned char uint_least8_t;typedef unsigned short uint_least16_t;typedef unsigned int uint_least32_t;typedef unsigned long long uint_least64_t;typedef signed char int_fast8_t;typedef int int_fast16_t;typedef int int_fast32_t;typedef long long int_fast64_t;typedef unsigned char uint_fast8_t;typedef unsigned int uint_fast16_t;typedef unsigned int uint_fast32_t;typedef unsigned long long uint_fast64_t;typedef long long intmax_t;typedef unsigned long long uintmax_t;","tags":["linux","Windows","long","跨平台"],"categories":["程序设计"]},{"title":"Windows平台git clone文件路径太长报错","path":"//git-clone-url-too-long.html","content":"问题描述在Windows下拉取一些比较大的开源项目经常会提示文件路径太长（filename too long），然后死活都不成功 解决办法1.配置git 1git config --system core.longpaths true 2.修改文件C:\\Program Files\\Git\\etc\\gitconfig（需要以管理员身份打开） 12345[core]\tautocrlf = true\tfscache = true\tsymlinks = false\tlongpaths = true longpaths = true表示允许路径字符串超过260 3.输入命令查看 1git config --system core.longpaths 显示结果为true表示已经成功设置","tags":["git","Windows"],"categories":["程序设计"]},{"title":"ros2 foxy订阅话题问题","path":"//ros2-foxy-subscribe-problem.html","content":"代码片段这部分代码在galactic版本编译是OK的，可在foxy下编译就出了问题 123456789101112131415161718192021222324252627TeleopPanel::TeleopPanel(QWidget* parent) : rviz_common::Panel(parent), playRate_(1.0)&#123; signalPub_ = nh_-&gt;create_publisher&lt;std_msgs::msg::Int16&gt;(&quot;/pixel/lv/run_signal&quot;, 5); beginPub_ = nh_-&gt;create_publisher&lt;std_msgs::msg::Float32&gt;(&quot;/pixel/lv/begin_signal&quot;, 5); ratePub_ = nh_-&gt;create_publisher&lt;std_msgs::msg::Float32&gt;(&quot;/pixel/lv/rate_signal&quot;, 5); currTimeSub_ = nh_-&gt;create_subscription&lt;std_msgs::msg::String&gt;(&quot;/pixel/lv/current_time&quot;, 10, std::bind(&amp;TeleopPanel::CurrTimeSub, this, std::placeholders::_1)); selectPtSub_ = nh_-&gt;create_subscription&lt;sensor_msgs::msg::PointCloud2&gt;(&quot;/rviz_selected_points&quot;, 10, std::bind(&amp;TeleopPanel::SelectPtSub, this, std::placeholders::_1)); std::thread t(&amp;TeleopPanel::StartSpin, this); t.detach(); SetPanelLayout();&#125;void TeleopPanel::CurrTimeSub(const std_msgs::msg::String&amp; msg)&#123; QString currTime = QString::fromStdString(msg.data); currentTimeEditor_-&gt;setText(currTime);&#125;void TeleopPanel::SelectPtSub(const sensor_msgs::msg::PointCloud2&amp; msg)&#123; const auto ptsNum = msg.width; QString ptsNumQStr = QString::fromStdString(std::to_string(ptsNum)); selectPtsEditor_-&gt;setText(ptsNumQStr);&#125; 出错部分两个create_subscription调用出错 12currTimeSub_ = nh_-&gt;create_subscription&lt;std_msgs::msg::String&gt;(&quot;/pixel/lv/current_time&quot;, 10, std::bind(&amp;TeleopPanel::CurrTimeSub, this, std::placeholders::_1));selectPtSub_ = nh_-&gt;create_subscription&lt;sensor_msgs::msg::PointCloud2&gt;(&quot;/rviz_selected_points&quot;, 10, std::bind(&amp;TeleopPanel::SelectPtSub, this, std::placeholders::_1)); create_subscription函数原型 1234567891011std::shared_ptr&lt;SubscriptionT&gt; create_subscription( const std::string &amp; topic_name, const rclcpp::QoS &amp; qos, CallbackT &amp;&amp; callback, const SubscriptionOptionsWithAllocator&lt;AllocatorT&gt; &amp; options = SubscriptionOptionsWithAllocator&lt;AllocatorT&gt;(), typename MessageMemoryStrategyT::SharedPtr msg_mem_strat = ( MessageMemoryStrategyT::create_default() ) ); 出错内容 下面是其中一部分报错内容 12345678910111213141516// 报错一play_panel.cpp:26: error: no match for ‘operator=’ (operand types are ‘rclcpp::Subscription&lt;sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt; &gt;::SharedPtr’ &#123;aka ‘std::shared_ptr&lt;rclcpp::Subscription&lt;sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt; &gt; &gt;’&#125; and ‘std::shared_ptr&lt;rclcpp::Subscription&lt;const sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt;&amp;, std::allocator&lt;void&gt;, rclcpp::message_memory_strategy::MessageMemoryStrategy&lt;const sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt;&amp;, std::allocator&lt;void&gt; &gt; &gt; &gt;’) 26 | selectPtSub_ = nh_-&gt;create_subscription&lt;sensor_msgs::msg::PointCloud2&gt;(&quot;/rviz_selected_points&quot;, 10, std::bind(&amp;TeleopPanel::SelectPtSub, this, std::placeholders::_1)); | ^// 报错二play_panel.cpp:26:25: error: no matching member function for call to &#x27;create_subscription&#x27;node_impl.hpp:91:7: note: candidate template ignored: substitution failure [with MessageT = sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt;, CallbackT = std::_Bind&lt;void (LidarViewRos2::RvizPlugin::TeleopPanel::*(LidarViewRos2::RvizPlugin::TeleopPanel *, std::_Placeholder&lt;1&gt;))(const sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt; &amp;)&gt;, AllocatorT = std::allocator&lt;void&gt;, CallbackMessageT = const sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt; &amp;, SubscriptionT = rclcpp::Subscription&lt;const sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt; &amp;, std::allocator&lt;void&gt;, rclcpp::message_memory_strategy::MessageMemoryStrategy&lt;const sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt; &amp;, std::allocator&lt;void&gt; &gt; &gt;, MessageMemoryStrategyT = rclcpp::message_memory_strategy::MessageMemoryStrategy&lt;const sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt; &amp;, std::allocator&lt;void&gt; &gt;]// 报错三/opt/ros/foxy/include/rclcpp/subscription_factory.hpp:97: error: no matching function for call to ‘rclcpp::AnySubscriptionCallback&lt;const sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt;&amp;, std::allocator&lt;void&gt; &gt;::set(std::_Bind&lt;void (LidarViewRos2::RvizPlugin::TeleopPanel::*(LidarViewRos2::RvizPlugin::TeleopPanel*, std::_Placeholder&lt;1&gt;))(const sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt;&amp;)&gt;)’ 97 | any_subscription_callback.set(std::forward&lt;CallbackT&gt;(callback)); | ^~~~~~~~~~~~~~~~~~~~~~~~~ // 报错四/usr/include/c++/9/ext/new_allocator.h:64: error: forming pointer to reference type ‘const sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt;&amp;’typedef const _Tp* const_pointer; 其实就是模板函数的原型不匹配导致的，CallbackT的模板参数需要传入指针类型才能正确解参数类型，传入引用类型是不对的 正确写法 只要把CurrTimeSub和SelectPtSub两个函数的原型修改一下（入参改成指针）就OK了 123456789101112void TeleopPanel::CurrTimeSub(const std_msgs::msg::String::SharedPtr msg)&#123; QString currTime = QString::fromStdString(msg-&gt;data); currentTimeEditor_-&gt;setText(currTime);&#125;void TeleopPanel::SelectPtSub(const sensor_msgs::msg::PointCloud2::SharedPtr msg)&#123; const auto ptsNum = msg-&gt;width; QString ptsNumQStr = QString::fromStdString(std::to_string(ptsNum)); selectPtsEditor_-&gt;setText(ptsNumQStr);&#125; 总结foxy和galactic及后续版本在create_subscription模板函数的实现有区别，移植的时候要注意兼容性，参考issue ros2 add arguments to callback - ROS Answers: Open Source Q&amp;A Forum","tags":["编译","ros2","foxy"],"categories":["程序设计"]},{"title":"各种编译模式的区别","path":"//complile-mode.html","content":"debug调试版本，带有完整的调试信息（函数、变量符号表、文件路径、行号），加载速度慢，体积大，比较适合在开发阶段使用 release发布版本，几乎没有调试信息，加载速度快（通常带有代码优化），体积小，一般在发布阶段使用 release with debug informationVisual Studio特有的编译模式，会带有一点点调试符号，但并不是所有函数行的断点都可以命中，而且调试信息也不完善，程序体积比release略大","tags":["编译"],"categories":["程序设计"]},{"title":"Windows应用发布时禁止cmd窗口弹出","path":"//windows-forbid-cmd.html","content":"解决很简单，就是在Release模式下告诉编译器：这是一个win32的app就行了 1234567if(CMAKE_BUILD_TYPE AND (CMAKE_BUILD_TYPE STREQUAL &quot;Release&quot;)) set(FLAG &quot;WIN32&quot;)else() set(FLAG &quot;&quot;)endif()add_executable(zhd-desktop $&#123;FLAG&#125; main.cpp)","tags":["上位机","Windows","cmake","cmd","release"],"categories":["程序设计"]},{"title":"C++ string与QString中文字符转换关系","path":"//cpp-string-to-qstring.html","content":"1.从QString到std::string12std::string oldString = &quot;你好，hello world&quot;;QString newString = QString::fromLocal8Bit(oldString.c_str()) 2.从std::string到QString12QString oldString = &quot;你好，hello world&quot;;std::string newString = std::string((const char *)oldString.toLocal8Bit().constData()); 3.从std::string到char *12345678910111213141516171819202122char *wchar2char(const wchar_t* source)&#123; char * data; int len= WideCharToMultiByte( CP_ACP ,0,source ,wcslen( source ), nullptr,0, nullptr ,nullptr); data= new char[len+1]; WideCharToMultiByte( CP_ACP ,0,source ,wcslen( source ),data,len, nullptr ,nullptr); data[len]= &#x27;\\0&#x27;; return data;&#125;const char *stringToChar(const std::string&amp; str)&#123; std::wstring wstr = L&quot;&quot;; int len = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), str.size(), nullptr, 0); wchar_t* wchar = new wchar_t[len + 1]; MultiByteToWideChar(CP_UTF8, 0, str.c_str(), str.size(), wchar, len); wchar[len] = &#x27;\\0&#x27;; wstr.append(wchar); const char *data = wchar2char(wchar); delete[] wchar; return data;&#125;","tags":["C++","string","QString","中文字符"],"categories":["程序设计"]},{"title":"n阶行列式求解","path":"//n-det-calculation.html","content":"前言笔者最近在学习线性代数，写了一个求解n阶行列式的程序，拿出来给大家分享借鉴一下。 实现用递归的方法求解n阶行列式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126/*\t1.名字：\tdeterminant.c 2.功能：\t求解n阶行列式值 3.编者：\tHeavenMo &lt;1621326181@qq.com&gt; 4.时间：\t2015-10-2 22:42 5.叙述：\t递归法实现n阶行列式的求解 6.申明：\tWin 8.1 pro / GCC 4.8.1编译器亲测通过 7.结构： a)main函数部分完成行列式的输入操作 b)det函数完成行列式的值的返回 c)det函数中，将原来的n阶行列式不断的递归分解， 如，n阶矩阵分解为n个(n-1)阶余子矩阵，(n-1)阶分解成(n-1)个(n-2)阶余子矩阵， ...，以此类推 d)递归至2阶时，计算2阶行列式的值，并返回给上一层，...， 以此类推*///有关头文件的包含，因为要用到动态内存的分配，所以包含stdlib.h# include &lt;stdio.h&gt;# include &lt;stdlib.h&gt;//定制数据类型，方便修改typedef int data_type;typedef unsigned int uint;//计算n阶行列式的函数声明data_type det(data_type *p, uint n);int main(void)&#123;\t//n为行列式的阶数，i，n，m为非负值，所以定义为uint\tuint i, n, m;\t//提示输入行列式的阶数\tprintf(&quot;请输入行列式的阶数: &quot;);\tscanf(&quot;%u&quot;, &amp;n);\tm = n * n;\t//程序的关键所在，将n阶行列式看成是一个长度是n*n的一维数组，m为数组的长度\tdata_type *p = (data_type *)calloc(m, sizeof(data_type));\tprintf(&quot;请输入行列式的元素值: &quot;);\tfor(i = 0; i &lt; m; i++)\t&#123; scanf(&quot;%d&quot;, p + i);\t&#125;\tprintf(&quot; 所求行列式的值 = %d &quot;, det(p, n)); //释放相应的内存\tfree(p);\treturn 0;&#125;//p指向长度为n*n的数组，n为行列式的阶数data_type det(data_type *p, uint n)&#123;\t//n = 1时的情况\tif(n == 1)\t&#123; return *p;\t&#125;\t//递归基准\tif(n == 2)\t&#123; return ((*p) * (*(p + 3)) - (*(p + 1)) * (*(p + 2)));\t&#125;\t//m1:当前行列式的元素个数，m2：分解后的行列式的元素个数\tuint i, j, k, m1, m2;\tm1 = n * n;\tm2 = (n - 1) * (n - 1); //为分配后的n个n-1阶的行列式分配内存的基址\tdata_type *p_list[n];\tfor(i = 0; i &lt; n; i++)\t&#123; p_list[i] = (data_type *)calloc(m2, sizeof(data_type));\t&#125;\t//关键一步，筛选出代数余子矩阵，i(0 - n-1)：原矩阵可以分解为n个n-1阶代数余子矩阵\tfor(i = 0; i &lt; n; i++)\t&#123; //j = n意为筛选元素要从第二行开始，k变量统计代数余子矩阵的元素个数 for(j = n, k = 0; j &lt; m1; j++) &#123; //考察原矩阵与余子矩阵的关系，构造余子矩阵 if(j % n != i) &#123; *(p_list[i] + k) = *(p + j); k++; &#125; &#125;\t&#125; //根据递推公式求和，sign为代数余子式的符号，与行数(其实是第一行)，列数有关\tint sign = -1;\tdata_type sum = 0;\tfor(i = 0; i &lt; n; i++)\t&#123; sign *= -1; //调用函数，通过对第一行的各元素与相应的代数余子矩阵的行列式值之积求和，实现递归求值 sum += sign * (*(p + i)) * det(p_list[i], n - 1);\t&#125; //返回函数值\treturn sum;&#125; 运行附上cmd运行结果：","tags":["n阶行列式","线性代数","算法"],"categories":["学科"]},{"title":"cmake生成应用程序logo","path":"//cmake-app-logo.html","content":"logo.ico去专门的ico图标网站下载，也可以通过普通的图片转换：png-to-ico resource.rc这个用于指定要到的图片文件 1IDI_ICON1 ICON &quot;logo.ico&quot; CMakeLists.txt在cmake文件里边加上rc文件 1add_executable($&#123;PROJECT_NAME&#125; main.cpp resource.rc)","tags":["上位机","cmake","logo"],"categories":["开发工具"]},{"title":"cmake之find_library问题","path":"//cmake-find-library.html","content":"附上工程源码库文件工程PS：这个工程用于导出库 CMakeLists.txt 1234567891011121314cmake_minimum_required(VERSION 3.5)project(demo LANGUAGES CXX)set(CMAKE_INCLUDE_CURRENT_DIR ON)set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED ON)add_library(demo SHARED demo.cpp demo.h)target_compile_definitions(demo PRIVATE DEMO_LIBRARY) demo.h 123456789101112#ifndef DEMO_H#define DEMO_Hclass Demo&#123;public: Demo(); void Print();&#125;;#endif // DEMO_H demo.cpp 1234567891011#include &quot;demo.h&quot;#include &lt;iostream&gt;Demo::Demo()&#123;&#125;void Demo::Print()&#123; std::cout &lt;&lt; &quot;this is a demo&quot; &lt;&lt; std::endl;&#125; 主程序工程PS：这个工程用于链接demo库 CMakeLists.txt 1234567891011121314cmake_minimum_required(VERSION 3.5)project(find-library LANGUAGES CXX)set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED ON)include_directories($&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/inc)find_library(LIB_DEMO demo $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/lib)add_executable($&#123;PROJECT_NAME&#125; main.cpp)target_link_libraries($&#123;PROJECT_NAME&#125; $&#123;LIB_DEMO&#125;) main.cpp 1234567891011#include &lt;iostream&gt;#include &quot;demo.h&quot;using namespace std;int main()&#123; Demo d; d.Print(); return 0;&#125; 问题情形首先这两个工程在Linux下使用没有问题的，find-library工程编译正常，可以正确链接demo库；但是在Windows平台就死活不行了，find-library工程CMakeLists.txt第10行老是报错提示demo库找不到 12LIB_DEMO linked by target &quot;find-library&quot; in directory E:/workspace/daily-project/cpp/find-library 但明明是把demo工程生成的库拷贝到find-library工程的lib目录下了，为啥就是死活会报错？Windows难道对库文件的格式有要求？ 解决办法尝试把demo工程的CMakeLists.txt第9行SHARED改成STATIC，重新编译demo，再把生成的静态库文件demo.lib拷贝到find-library工程的lib目录下，重新编译该工程却出乎意料的成功了！但参考官网find_library的用法却没有得到解析 总结下次写跨平台编译的代码的时候记得在cmake上面配置生成不同类型的库","tags":["Windows","cmake"],"categories":["开发工具"]},{"title":"cJson数据格式问题","path":"//cjson-file-format-problem.html","content":"问题描述Linux的换行符是 ，Windows的换行符是\\r ，在Linux系统下使用cJson库解析本地json文件没有问题，但如果把Windows的json文件拷贝到Linux下需要把\\r 给过滤掉，否则传入文件buffer就解析不出cJson对象！ 解决办法 一个简单的办法通过vim设置set ff=unix将文件改为Unix文件格式 通过c&#x2F;c++实现trim或者trimmed接口过滤掉首尾两端空白符","tags":["linux","Windows","cJson"],"categories":["程序设计"]},{"title":"QNX移植mongoose","path":"//qnx-port-mongoose.html","content":"移植方法MG_ARCH表示Unix架构，SSL可以开启，也可以不开启，需要链接m，c，socket几个库 12source ~/qnx700/qnxsdp-env.sh # 使用前先source一下工具链aarch64-unknown-nto-qnx7.0.0-gcc -D MG_ARCH=1 -D MG_ENABLE_SSL=1 main.c ../../mongoose.* -l../../ -lm -lc -lsocket -o example","tags":["服务器","QNX","mongoose","开源库"],"categories":["程序设计"]},{"title":"专业英语词汇","path":"//professional-english.html","content":"前言电子信息、电气工程、自动化、半导体、计算机专业英语词汇汇总，不定期更新 常用 Asynchronous：异步 synchronous：同步 notification：通知 blade：平面 shaft：轴 magnetic：磁场的 bearing：轴承 valve：阀 heat sink：散热片 separated：分离的 excitation amp：激励放大器 Axial：轴的，轴向的 Supervisor：管理员 front：前面的 rear：后面的 sheet metal：钣金 constraints：约束 Radial sensor：径向传感器 Axial sensor：轴向传感器 Magnetic bearing ：磁悬浮轴承 Thermal：热的 earth terminals：接地端子 Electromagnetic Interference，EMI：电磁干扰 reentrant：可重入的 simultaneously：同时 specifications：产品规格、约束 anticipate：预料 consequences：后果 hazards：危害 warranty：保证 herein：请进 Outlet：出口 series：产品系列 outer：外面的 bending：弯曲 obstacles：障碍 rack：架子 screw：螺钉 Levitation：悬浮 电子电气 circuit：电路 Impedance：阻抗 inductance：电感 resistor：电阻 capacitance：电容 thermistor：热敏电阻 braker Resistor：制动电阻 cable：线缆 Leakage current：漏电流 Fuse：保险丝 Insulation：绝缘 reflection：反射率 threshold：阈值 acquisition：采集 resistance：电阻 capacitance：电容 inductance：电感 diode：二极管 LED：light-emitting diode，发光二极管 Bipolar Junction Transistor：三极管 Field Effect Transistor：场效应管 beam：光线，波束 magnet：磁体 Radio Frequency：RF，射频，表示可以辐射到空间的电磁频率，频率范围从300kHz～300GHz之间 Metal-Oxide-Semiconductor Field-Effect Transistor：MOSFET，金氧半场效晶体管 interlock：联锁，为人身安全和设备安全设计的安全联锁装置 laser：激光 自动化 motor：电机 pump：泵 BEMF (back electromotive force）：反电动势 GPIO：General-Purpose Input&#x2F;Output，通用输入输出 pwm：Pulse Width Modulation，脉冲宽度调制效应 adc：analog-to-digital converter，模数转换器 dac：Digital to Analog Converter，数字模拟转换器 SCI：Serial Communications Interface，串行通信接口 can：Controller Area Network，近场通信协议 fan：风扇 braker：制动器、刹车 OPC UA：open platform communication unified architecture，开放平台统一架构 IPC：industrial PC，工控机 PLC：Programmable Logic Controller，可编程逻辑控制器 displacement：位移 malfunction：故障 PoE：power over ethernet，以太网供电技术 计算机 computer：计算机 design pattern：设计模式 data structure：数据结构 algorithm：算法 operating system：操作系统： compiler principle：编译原理 database：数据库 milliseconds：毫秒 loop back：回环，数据回环 protocol：协议 MQTT：Message Queuing Telemetry Transport 算法和数据结构 array：数组 linked list：链表 stack：栈 queue：队列 binary tree：二叉树 hash：哈希 graph：图 string：字符串 set：集合 map：映射 generic programming：泛型编程 sort：排序 图形学 pipeline：管线 shader：着色器 texture：纹理 VBO：Vertex Buffer Object，顶点缓冲对象 VAO：Vertex Array Object，顶点数组对象 EBO：Element Buffer Object，元素索引对象 viewport：视口 vector：向量 matrix：矩阵 NDC：Normalized Device Coordinates，标准化设备坐标 local space：局部空间 world space：世界空间 view space：观察空间 clip space：裁剪空间 screen space：屏幕空间 euler angles：欧拉角，偏航角、俯仰角、滚转角 yaw：偏航角 pitch：俯仰角 roll：滚转角 Phong Lighting Model：冯氏光照模型 Ambient Lighting：环境光 Diffuse Lighting：漫反射光 Specular Lighting：镜面光 Normal Vector：法向量 Material：材质 机器人 trajectory：轨迹 local path planning：局部路径规划 global path planning：全局路径规划 costmap：代价地图 acml：adaptive Monte Carlo localization，自适应蒙特卡洛定位 自动驾驶 RTK：Real-time kinematic，实时动态测量 longitude：经度 latitude：纬度 altitude：高程、海拔高度 GNSS：Global Navigation Satellite System，全球导航卫星系统 Antenna：天线 LiDAR：Light Detection And Ranging，激光雷达 camera：相机 IMU：Inertial Measurement Unit，惯性测量单元 accelerometer：加速度计，缩写accel gyroscope：陀螺仪，缩写gyro Magnetometer：磁力计，缩写mag 半导体 wafer：晶圆 PVD：物理气相沉积 CVD：化学气相沉积 etch：刻蚀 Ion implantation：离子注入 vacuum：真空 Miscellaneous：掺杂 butterfly valve：蝶阀 Pneumatic valves：气动阀 molecular pump：分子泵 Vacuum Gauge：真空规、真空计 flowmeter：流量计 Special Gas：特气 Gas cabinet：特气柜 Radio Frequency power supply：射频电源 Vacuum manipulator：真空机械手 Wafer alignment：晶圆对准 Reactor：反应炉","tags":["English","专业英语"],"categories":["学科"]},{"title":"cmake获取指定目录下的所有文件","path":"//cmake-recurse-files.html","content":"需求编写跨平台的工程时，因为项目比较大，文件很多，开发人员很多，不想一一列举add_executable里边的文件 解决用FILE宏获取某个指定目录下的同一类型的所有文件，用DIAGNOSTIC和SERIALIZE两个变量来分别存储所有符合条件的文件名，include_directories也可以自动包含目录下的所有头文件 12345FILE(GLOB_RECURSE DIAGNOSTIC $&#123;CMAKE_SOURCE_DIR&#125;/diagnostic/*.c)include_directories($&#123;CMAKE_SOURCE_DIR&#125;/diagnostic)FILE(GLOB_RECURSE SERIALIZE $&#123;CMAKE_SOURCE_DIR&#125;/serialize/*.c)include_directories($&#123;CMAKE_SOURCE_DIR&#125;/serialize) 再在add_executable里边添加DIAGNOSTIC和SERIALIZE两个变量，这样新增文件只要执行一下cmake就可以了 1234567add_executable(zhd-desktop main.c $&#123;DIAGNOSTIC&#125; $&#123;SERIALIZE&#125; logo.rc res.qrc)","tags":["cmake"],"categories":["开发工具"]},{"title":"与NXP的一点缘分","path":"//nxp-stuff.html","content":"介绍NXP是老牌的芯片巨头，做汽车电子的人尤为熟悉，比如它的LPC系列、S32K系列、imx系列；我的老东家周立功就是靠NXP的代理权发家致富的；去年接触（白嫖）NXP的MCU方案比较多，特别是FRDM这个开发板系列，给RT-Thread贡献了开源文档、教程以及多个PR 开发板MCXN947这个板子的资源比较丰富，最大亮点是集成了神经处理单元 MCXA153资源比947稍微少一些，没有CAN和ETH，是中规中矩的MCU MCXW71专为无线连接设计的板子 礼品参与NXP相关的活动，收到的一些礼物 机械键盘参加947的测评活动送的一份沉甸甸的礼物 发光鼠标垫这个可以发光，颜色会变化 充电宝这个是新年收到的礼物，20000mAh的充电宝","tags":["NXP","blog"],"categories":["嵌入式"]},{"title":"网络数据Hex格式转换","path":"//qt-string-to-hex.html","content":"前言Qt中TCP通信一般用QByteArray作为数据传输对象，使用Hex格式的情形要考虑一下变换，否则服务器和客户端的数据长度对不上 发送字符串本身就是hex格式，需要转成QByteArray格式进行传输 123QString hex = &quot;03000010560155aa010023000000d750&quot;;QByteArray data = QByteArray::fromHex(hex.toLatin1());m_socket-&gt;write(data); 接收QByteArray转为hex格式 12QString hex = m_socket-&gt;readAll().toHex();qDebug() &lt;&lt; hex;","tags":["Qt","hex"],"categories":["程序设计"]},{"title":"一个简单的Windows TCP服务器实现","path":"//winsock2-server.html","content":"包含头文件 12#include &lt;winsock2.h&gt;#include &lt;stdio.h&gt; 需要链接的库文件 1ws2_32.lib winsocket初始化 123456789WSADATA wsaData;SOCKET serverSocket, clientSocket;struct sockaddr_in serverAddr = &#123; 0x00 &#125;;struct sockaddr_in clientAddr = &#123; 0x00 &#125;;int clientAddrLen = sizeof(clientAddr);if (WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0) &#123; printf(&quot;WSAStartup failed. &quot;);&#125; 创建winsocket 1234if ((serverSocket = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET) &#123; printf(&quot;Socket failed. &quot;); WSACleanup();&#125; IP及端口号配置 123456789serverAddr.sin_family = AF_INET;serverAddr.sin_addr.s_addr = INADDR_ANY;serverAddr.sin_port = htons(9988);if (bind(serverSocket, (struct sockaddr*)&amp;serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) &#123; printf(&quot;Bind failed. &quot;) closesocket(serverSocket); WSACleanup();&#125; 监听客户端连接 12345if (listen(serverSocket, 5) == SOCKET_ERROR) &#123; printf(&quot;Listen failed. &quot;); closesocket(serverSocket); WSACleanup();&#125; 接受客户端连接 12345if ((clientSocket = accept(serverSocket, (struct sockaddr*)&amp;clientAddr, &amp;clientAddrLen)) == INVALID_SOCKET) &#123; printf(&quot;Accept failed. &quot;); closesocket(serverSocket); WSACleanup();&#125; 接收数据 1int bytesReceived = recv(clientSocket, (char*)(_sRxBuffer + _sRxLenght), BUFFER_SIZE, 0); 发送数据 1int txPacketlenght = send(socket, (const char*)_sTxBuffer, txPacketlenght, 0); 回收winsocket资源 123closesocket(clientSocket);closesocket(serverSocket);WSACleanup(); 检查连接断开情形 1234567891011int bytesReceived = recv(clientSocket, buffer, bufferSize, 0);if (bytesReceived == 0) &#123; printf(&quot;Client socket disconnected gracefully. &quot;);&#125; else if (bytesReceived == SOCKET_ERROR) &#123; int error = WSAGetLastError(); if (error == WSAECONNRESET) &#123; printf(&quot;Client socket disconnected unexpectedly. &quot;); &#125; else &#123; printf(&quot;Recv failed with error: %d &quot;, error); &#125;&#125;","tags":["服务器","Windows","tcp"],"categories":["程序设计"]},{"title":"Windows常用快捷键集合","path":"//windows-common-shortcuts.html","content":"介绍工欲善其事必先利其器，用对工具往往事半功倍 快捷键 打开运行对话框：win + R 打开Windows粘贴板：win + V 打开Home菜单：win + X 打开搜索对话框：win + S 截图：win + Shift + S 打开控制面板：win + I 在某个文件路径迅速打开cmd命令行：Ctrl + L，输入cmd即可 拓展屏幕配置：win + P 光标聚焦任务栏：win + T 光标聚焦状态栏：win + B 所有窗口最小化：win + M 锁屏：win + L Windows防火墙：win + R后输入filewall.cpl 运行任务栏的程序：win + 1，2，3，4对应从左到右的程序序号 打开Windows通知面板：win + A 唤醒画画及截屏功能：win + W","tags":["快捷键","Windows"],"categories":["开发工具"]},{"title":"Qt Enter和HoverEnter事件","path":"//qt-enter-hoverenter.html","content":"介绍做PC开发的过程中或多或少都会接触到鼠标的悬停事件，Qt中处理鼠标悬停有Enter和HoverEnter两种事件 相同点 QEvent::Enter对应QEnterEvent，描述的是鼠标进入控件坐标范围之内的行为，QEnterEvent可以抓取鼠标的位置 QEvent::HoverEnter对应QHoverEvent，控件开启Qt::WA_Hover属性可以达到Enter事件一样的效果，QHoverEvent同样可以抓取鼠标的位置 不同点QHoverEvent附带有QEvent::Paint重绘行为，QEnterEvent没有触发控件本身的重绘的能力，请按照具体的场景区别使用","tags":["Qt","鼠标事件"],"categories":["程序设计"]},{"title":"Qt TCP通信案例","path":"//qt-tcp-communication-example.html","content":"服务器使用前要在cmake工程文件里边添加network模块 123find_package(Qt5 COMPONENTS core network REQUIRED)target_link_libraries($&#123;PROJECT_NAME&#125; Qt5::Core Qt5::Network) TCP通信服务器的核心类是QTcpServer，头文件同名 1#include &lt;QTcpServer&gt; 使用也特别简单，先绑定IP地址和端口号，listen的返回结果如果是false则端口号有可能被占用，Windows上建议用netstat -aon | findstr &quot;9090&quot;事先看一下端口占用情况，Linux下则是用netstat -tlp | grep 9090 12QTcpServer server;bool ret = server.listen(QHostAddress(&quot;127.0.0.1&quot;), 9090); 编写newConnection信号对应的槽函数，服务器通过nextPendingConnection接口获取已建立的socket，然后对socket进行读写 1234567891011QObject::connect(&amp;server, &amp;QTcpServer::newConnection, [&amp;]() &#123; auto &amp;&amp;socket = server.nextPendingConnection(); auto timer = new QTimer(); QObject::connect(timer, &amp;QTimer::timeout, [&amp;, socket]() &#123; socket-&gt;write(QByteArray(&quot;hello world&quot;)); &#125;); timer-&gt;start(1000); QObject::connect(socket, &amp;QTcpSocket::readyRead, [&amp;, socket]() &#123; qDebug() &lt;&lt; &quot;Server : &quot; &lt;&lt; socket-&gt;readAll(); &#125;);&#125;); 客户端客户端同理，使用前也要在cmake工程文件里边添加network模块 123find_package(Qt5 COMPONENTS core network REQUIRED)target_link_libraries($&#123;PROJECT_NAME&#125; Qt5::Core Qt5::Network) 客户端使用QTcpSocket进行TCP通信 1#include &lt;QTcpSocket&gt; 调用connectToHost接口建立服务器通信连接 12QTcpSocket socket;socket.connectToHost(QHostAddress(&quot;127.0.0.1&quot;), 9090); 需要处理几个跟连接相关的信号：connected、disconnected、readyRead 12345678910111213// connected表示连接已建立QObject::connect(&amp;socket, &amp;QTcpSocket::connected, [&amp;]() &#123; timer-&gt;start(1000); qDebug() &lt;&lt; &quot;Client connected server&quot;;&#125;);// disconnected表示连接已断开QObject::connect(&amp;socket, &amp;QTcpSocket::disconnected, [&amp;]() &#123; qDebug() &lt;&lt; &quot;Client disconnected server&quot;;&#125;);// readyRead表示缓冲区有数据可读QObject::connect(&amp;socket, &amp;QTcpSocket::readyRead, [&amp;]() &#123; qDebug() &lt;&lt; &quot;Client : &quot; &lt;&lt; socket.readAll();&#125;); 基类QIODevice的读写接口 12345678910qint64 read(char *data, qint64 maxlen);QByteArray read(qint64 maxlen);QByteArray readAll();qint64 readLine(char *data, qint64 maxlen);QByteArray readLine(qint64 maxlen = 0);qint64 write(const char *data, qint64 len);qint64 write(const char *data);inline qint64 write(const QByteArray &amp;data)&#123; return write(data.constData(), data.size()); &#125; 结果 以上的服务器和客户端在互相给对方发hello world数据 QTcpServer那里巧妙抽象了QTcpSocket的操作方式，客户端和服务器都是对QTcpSocket读写","tags":["Qt","TCP","服务器","客户端"],"categories":["程序设计"]},{"title":"uboot剖析之命令行延时","path":"//uboot-bootdelay.html","content":"在configs/rk3506_defconfig文件中可以配置启动延时选项 1CONFIG_BOOTDELAY=3 common&#x2F;main.c –&gt; main_loop：bootdelay_process处理delay延时值解析，按键捕获由autoboot_command负责 123456789101112131415161718192021222324252627void main_loop(void)&#123; const char *s; bootstage_mark_name(BOOTSTAGE_ID_MAIN_LOOP, &quot;main_loop&quot;);#ifdef CONFIG_VERSION_VARIABLE env_set(&quot;ver&quot;, version_string); /* set version variable */#endif /* CONFIG_VERSION_VARIABLE */ cli_init(); run_preboot_environment_command();#if defined(CONFIG_UPDATE_TFTP) update_tftp(0UL, NULL, NULL);#endif /* CONFIG_UPDATE_TFTP */ s = bootdelay_process(); if (cli_process_fdt(&amp;s)) cli_secure_boot_cmd(s); autoboot_command(s); cli_loop(); panic(&quot;No CLI available&quot;);&#125; common&#x2F;autoboot.c –&gt; bootdelay_process：要么从环境变量bootdelay里边获取，要么就从CONFIG_BOOTDELAY里边获取，最后更新stored_bootdelay 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const char *bootdelay_process(void)&#123; char *s; int bootdelay;#ifdef CONFIG_BOOTCOUNT_LIMIT unsigned long bootcount = 0; unsigned long bootlimit = 0;#endif /* CONFIG_BOOTCOUNT_LIMIT */#ifdef CONFIG_BOOTCOUNT_LIMIT bootcount = bootcount_load(); bootcount++; bootcount_store(bootcount); env_set_ulong(&quot;bootcount&quot;, bootcount); bootlimit = env_get_ulong(&quot;bootlimit&quot;, 10, 0);#endif /* CONFIG_BOOTCOUNT_LIMIT */ s = env_get(&quot;bootdelay&quot;); bootdelay = s ? (int)simple_strtol(s, NULL, 10) : CONFIG_BOOTDELAY;#ifdef CONFIG_OF_CONTROL bootdelay = fdtdec_get_config_int(gd-&gt;fdt_blob, &quot;bootdelay&quot;, bootdelay);#endif debug(&quot;### main_loop entered: bootdelay=%d &quot;, bootdelay);#if defined(CONFIG_MENU_SHOW) bootdelay = menu_show(bootdelay);#endif bootretry_init_cmd_timeout();#ifdef CONFIG_POST if (gd-&gt;flags &amp; GD_FLG_POSTFAIL) &#123; s = env_get(&quot;failbootcmd&quot;); &#125; else#endif /* CONFIG_POST */#ifdef CONFIG_BOOTCOUNT_LIMIT if (bootlimit &amp;&amp; (bootcount &gt; bootlimit)) &#123; printf(&quot;Warning: Bootlimit (%u) exceeded. Using altbootcmd. &quot;, (unsigned)bootlimit); s = env_get(&quot;altbootcmd&quot;); &#125; else#endif /* CONFIG_BOOTCOUNT_LIMIT */ s = env_get(&quot;bootcmd&quot;); process_fdt_options(gd-&gt;fdt_blob); stored_bootdelay = bootdelay; return s;&#125; common&#x2F;autoboot.c –&gt; autoboot_command：在执行启动命令run_command_list前先检查stored_bootdelay值 12345678910111213141516171819202122232425void autoboot_command(const char *s)&#123; debug(&quot;### main_loop: bootcmd=\\&quot;%s\\&quot; &quot;, s ? s : &quot;&lt;UNDEFINED&gt;&quot;); if (stored_bootdelay != -1 &amp;&amp; s &amp;&amp; !abortboot(stored_bootdelay)) &#123;#if defined(CONFIG_AUTOBOOT_KEYED) &amp;&amp; !defined(CONFIG_AUTOBOOT_KEYED_CTRLC) int prev = disable_ctrlc(1); /* disable Control C checking */#endif run_command_list(s, -1, 0); autoboot_command_fail_handle();#if defined(CONFIG_AUTOBOOT_KEYED) &amp;&amp; !defined(CONFIG_AUTOBOOT_KEYED_CTRLC) disable_ctrlc(prev); /* restore Control C checking */#endif &#125;#ifdef CONFIG_MENUKEY if (menukey == CONFIG_MENUKEY) &#123; s = env_get(&quot;menucmd&quot;); if (s) run_command_list(s, -1, 0); &#125;#endif /* CONFIG_MENUKEY */&#125; common&#x2F;autoboot.c –&gt; abortboot：真正的功能实现在__abortboot 1234567891011121314static int abortboot(int bootdelay)&#123; int abort = 0; if (bootdelay &gt;= 0) abort = __abortboot(bootdelay);#ifdef CONFIG_SILENT_CONSOLE if (abort) gd-&gt;flags &amp;= ~GD_FLG_SILENT;#endif return abort;&#125; common&#x2F;autoboot.c –&gt; __abortboot：bootdelay延时计数 + 等待按键ctrl+c输入 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static int __abortboot(int bootdelay)&#123; int abort = 0; unsigned long ts;#ifdef CONFIG_MENUPROMPT printf(CONFIG_MENUPROMPT);#else printf(&quot;Hit key to stop autoboot(&#x27;CTRL+C&#x27;): %2d &quot;, bootdelay);#endif#ifdef CONFIG_ARCH_ROCKCHIP if (!IS_ENABLED(CONFIG_CONSOLE_DISABLE_CLI) &amp;&amp; ctrlc()) &#123; /* we press ctrl+c ? */#else /* * Check if key already pressed */ if (tstc()) &#123; /* we got a key press */#endif (void) getc(); /* consume input */ puts(&quot;\\b\\b\\b 0&quot;); abort = 1; /* don&#x27;t auto boot */ &#125; while ((bootdelay &gt; 0) &amp;&amp; (!abort)) &#123; --bootdelay; /* delay 1000 ms */ ts = get_timer(0); do &#123; if (ctrlc()) &#123; /* we got a ctrl+c key press */ abort = 1; /* don&#x27;t auto boot */ bootdelay = 0; /* no more delay */# ifdef CONFIG_MENUKEY menukey = 0x03; /* ctrl+c key code */# endif break; &#125; udelay(10000); &#125; while (!abort &amp;&amp; get_timer(ts) &lt; 1000); printf(&quot;\\b\\b\\b%2d &quot;, bootdelay); &#125; putc(&#x27; &#x27;); return abort;&#125; 如果不小心把启动延时设置为0，需要手动设置bootdelay的值才可以进入uboot配置菜单","tags":["串口","uboot","rk3506","控制台"],"categories":["嵌入式"]},{"title":"Qt按钮美化教程","path":"//qt-button-design.html","content":"前言Qt按钮美化主要有三种方式：QSS、属性和自绘 QPushButtonQSS字体大小 1font-size: 18px; 文字颜色 1color: white; 背景颜色 1background-color: rgb(10,88,163); 按钮边框 1border: 2px solid rgb(114,188,51); 文字对齐 1text-align: left; 左侧内边距 1padding-left: 10px; 文字加粗 1font-weight: bold; 边框的大小 1border-width: 4px; 边框的半径 1border-radius: 3px; 整合样式 123456789101112131415QPushButton &#123; font-size: 18px; /* 设置字体大小 */ color: white; /* 设置字体颜色 */ background-color: rgb(10,88,163); /* 设置背景颜色 */ border: 2px solid rgb(114,188,51); /* 设置边框 */ text-align: left; /* 文字左对齐 */ padding-left: 10px; /* 左侧内边距 */ font-weight: bold;&#125;QPushButton:pressed &#123; background-color: rgb(41,51,57); color: rgb(114,188,51); /* 设置字体颜色 */ border-width: 4px;&#125; 属性添加hover tooltip 修改text 焦点策略，一般默认StrongFocus 坐标和大小 自绘重写paintEvent虚函数，这个一般用的不多 12345678CPushButton::paintEvent(QPaintEvent *event)&#123; /* 这里增加自绘的代码：文字、图片等等 */ QPainter p(this); p.drawText(10, 10, &quot;Clicked me&quot;); p.drawPixmap(20, 10, QIcon(&quot;:/res/button.png&quot;)); QPushButton::paintEvent(event);&#125; 效果附上QSS+属性美化后的button效果（自己写的，你嫌丑我还嫌丑哩） QToolButton有时候需要定制图片跟文字同时显示的按钮（在触摸屏用的比较多），QToolButton是一个不错的选择 QSS添加底图 1qproperty-icon: url(:/resource/home.png) center; 底图大小设置 1qproperty-iconSize: 32px 32px; 聚焦时显示激活效果 1234QToolButton::focus&#123;\tbackground-image: url(:/resource/menu-active.png);&#125; 属性改变图片和文字的相对位置 在平板上面操作的话焦点策略改为ClickFocus 自绘QToolButton如无意外，不需要自绘 效果显示效果","tags":["Qt","button"],"categories":["程序设计"]},{"title":"Qt6串口数据协议解析","path":"//qt6-serial-protocol.html","content":"介绍绑定QSerialPort对象的readyRead信号时，从串口接收缓冲区读取的数据大概率不是一次就能接收完成的，有可能分成n次接收；这是一种什么情况呢，它有可能多次readyRead：1次，2次，3次，4次……这样子！如果不对数据的边界进行有效识别，就很难分别出哪些是我们要的数据 定长协议比如接收够15个字节才算接收完成，可以用QSerialPort::bytesAvailable这个接口进行组包，理论上给出头部标记就能识别有效的一帧数据：$ 10 0123456789 CS 1234567891011121314151617181920212223242526#define MAX_SIZE 15QByteArray buffer;int size = 0;auto callback = [&amp;]() &#123; auto &amp;&amp;data = this-&gt;readData(); if(data.startsWith(&quot;$&quot;)) &#123; size = m_serial-&gt;bytesAvailable(); buffer.clear(); buffer += data; if(size == MAX_SIZE) &#123; size = 0; emit this-&gt;sendOneFrame(buffer); &#125; &#125; else &#123; size += m_serial-&gt;bytesAvailable(); buffer += data; if(size == MAX_SIZE) &#123; size = 0; emit this-&gt;sendOneFrame(buffer); &#125; &#125;&#125;;connect(m_serial, &amp;QSerialPort::readyRead, this, callback); 不定长协议这个需要识别数据的边界（头部跟尾部）在哪里，比如用$头部，@做尾部，我们把分段的数据依次拼接起来 12345678910111213141516171819202122232425QByteArray buffer;auto callback = [&amp;]() &#123; qDebug() &lt;&lt; m_serial-&gt;bytesAvailable(); auto &amp;&amp;data = this-&gt;readData(); if(data.startsWith(&quot;$&quot;)) &#123; buffer.clear(); buffer += data; if(data.endsWith(&quot;@&quot;)) &#123; emit this-&gt;sendOneFrame(buffer); &#125; qDebug() &lt;&lt; &quot;1 : &quot; &lt;&lt; buffer; &#125; else &#123; if(!data.endsWith(&quot;@&quot;)) &#123; buffer += data; qDebug() &lt;&lt; &quot;2 : &quot; &lt;&lt; buffer; &#125; else &#123; buffer += data; qDebug() &lt;&lt; &quot;3 : &quot; &lt;&lt; buffer; emit this-&gt;sendOneFrame(buffer); &#125; &#125;&#125;;connect(m_serial, &amp;QSerialPort::readyRead, this, callback); 总结串口数据解析本质是一个文本处理的过程，如果接收端用C语言写，简单的协议还好，复杂的协议简直要命（请用高级语言）！","tags":["Qt","serial","串口"],"categories":["程序设计"]},{"title":"vim轻度使用","path":"//vim-usage.html","content":"安装 1sudo apt install vim 卸载 1sudo apt remove --purge vim 配置文件 1~/.vimrc 配置 开启行号：set nu 高亮行：set cul 高亮列：set cuc 高亮搜索关键字：set hls 绑定Esc快捷键：inoremap jj &lt;Esc&gt; tab大小配置：set ts&#x3D;4 使用 命令行模式按i、I、a、A可以进入编辑模式 编辑模式下按Esc进入命令行模式 在命令行模式用/关键字向下搜索，?关键字向上搜索 命令行模式用vs垂直分割窗口、sp水平分割窗口 在分割窗口之间移动：先按CTRL + W再按H、L 替换：s/替换前字符/替换后字符/g 命令行模式保存：w 命令行模式退出：q 命令行模式保存并退出：wq 命令行模式强制退出：q! 光标移动 上：k 下：j 左：h 右：l 快捷键 退出编辑器：CTRL + W + Q","tags":["linux","vim"],"categories":["开发工具"]},{"title":"最小git提交","path":"//mini-git-commit.html","content":"先从远程仓库拉新代码 1git fetch 合并分支改动 1git merge origin develop --no-ff 下载远程仓库的更新 1git pull 查看本地修改了哪些文件 1git status -s 添加文件到暂存区 1git add file1 file2 file3 写入提交日志 1git commit -m &quot;这是一段日志&quot; -a 提交到远程仓库 1git push -f origin main","tags":["git"],"categories":["开发工具"]},{"title":"MDK Keil5快捷键","path":"//mdk-keil5-shortcut.html","content":"常见快捷键合集 开始&#x2F;停止调试：CTRL + F5 运行：F5 单步进入：F11 单步跳出：CTRL + F11 单步：F10 执行到指定位置：CTRL + F10 检索：CTRL + F 插入或者移除断点：F9 移除所有断点：CTRL + Shift + F9 烧录程序：F8 编译当前文件：CTRL + F7 构建当前工程：F7 打开工程配置：Alt + F7 跳到指定行：CTRL + G 剪切当前行：CTRL + L 前进：CTRL + Shift + - 后退：CTRL + -","tags":["keil","快捷键"],"categories":["开发工具"]},{"title":"一个比较理想的嵌入式产品模型","path":"//ideal-embedded-product-model.html","content":"介绍示波器是一个比较典型、通用、明确的嵌入式产品案例，工作这么多年，很多产品业务模型或多或少都跟示波器的开发有点像！我敢说以下列举的软件、硬件、机械的部分在很多嵌入式产品中（不管是医疗、自动化还是汽车电子）普遍存在，所以我觉得自己经常在做示波器的类似物 软件嵌入式软件的复杂度大概在40-50w代码量左右 数据采集：电压、can、温度信号 数据可视化：主要是波形、报文的展示 文件存储：把数据文件录制下来，方便回读分析 HMI用户界面交互：按键、飞梭、旋钮、触摸屏 指令控制：SCPI指令控制设备，完成自动化测量功能 设备校准：一些标定校准的数据文件、抑制设备老化带来的参数漂移 设备驱动：按键板驱动、触摸屏驱动、usb驱动、pcie驱动、数据采集&#x2F;控制驱动 软件升级：自升级 + 外设升级 上位机上位机主要是解析波形文件、指令控制、校准维护、外设升级等功能 web设备调参、诊断使用、OTA升级 操作系统裸机、RTOS、Linux、Windows（配套上位机） 硬件硬件的组成按数字芯片分类有以下几个部分 fpgafpga主要负责前端数据的采集、预处理 armarm是嵌入式软件运行的载体 dsp集成波形处理的算法，这个是算法的载体 mcu按键板、采集卡里边的芯片、电源管理芯片 x64x64是终端软件运行的载体、软件升级工具 机械机械部件比较中规中矩，如探头、机箱外壳、显示屏部件、按键部件、采集卡的外壳 总结综上，示波器是一个终极的嵌入式产品案例，业务模型通常都具有相似性，只要深入了解一个，便可以举一反三","tags":["产品","嵌入式"],"categories":["方法论"]},{"title":"上位机和下位机的基本通信协议","path":"//upper-computer-lower-computer-communication-protocol.html","content":"介绍上位机和下位机的通信方式多种多样，一般有usart、can、usb、ethernet等，走什么通信方式视下位机的设备资源而定；以ethernet tcp通信为例，大部分情形下，下位机即嵌入式设备作为server端，PC端作为client端；嵌入式设备需要默认一个IP地址，比如192.168.137.22，还要有一个端口号，比如8738 帧格式帧格式的设计应包含四个部分：帧头 + 长度 + 数据段 + 校验 帧头：两个字节，例如固定为0xaa 0x55 长度：uint16，大端，整个包的长度，包含帧头、长度、数据段和校验四个部分的总长 度。单个包的最大长度为512 数据段：包荷载的内容，长度不固定 校验：两个字节，帧头、长度和数据段的CRC16计算值，当然也可以用异或校验 心跳包心跳包设计原则： 最好仅支持一个设备连接 客户端请求，服务器应答 约定一个心跳时间，如30秒进行一次心跳查询；还要一个超时时间，如300秒没有任何应答则视为连接已经断开 请求请求报文格式参考：协议码 + 消息类型 + 功能码 + 序号 + 功能数据 应答应答报文格式参考：协议码 + 消息类型 + 功能码 + 序号 + 错误码 + 功能数据 总结以上请求和应答设计范例其实是一种web服务的思想","tags":["通信协议","上位机","下位机"],"categories":["程序设计"]},{"title":"tar命令","path":"//tar-common-usage.html","content":"查看压缩包比如想看看rootfs.tar里边有什么东西，避免解压有坑 12tar -tf rootfs.tartar tf rootfs.tar.xz 解压默认全部解压，当然参数部分也可以带压缩包类型：J表示xz、j表示bz2、z表示gz 1tar xf demo.tar.xx tar创建默认tar包 1tar -cf archive.tar foo bar xzxz文件压缩 1tar cJf rootfs.tar.xz rootfs/ bz2bz2文件压缩 1tar cjf rootfs.tar.bz2 rootfs/ gzgz文件压缩 1tar czf rootfs.tar.gz rootfs/","tags":["linux","tar"],"categories":["开发工具"]},{"title":"编程中的同步和异步概念","path":"//program-synchronization-asynchronous.html","content":"普通理解同步，即同时进行、一起做，比如：一边开会，一边做笔记，这两件事就是同步进行的 异步，跟同步相反，做事的时间顺序不一致，比如：常见的电影声音和字幕不一致 编程概念同步一个函数如果在调用的时候随即能拿到结果并返回，这就是同步，比如：调用一个LedOn()函数，Led灯就会马上亮起来、函数退出；一般，单线程的环境应用比较多，因为只有一条时间线，干不了很多的活，这是比较好理解的 异步异步调用一般出现在多线程或者中断情景下，有一些事情需要分给不同的任务做，而你又无法准确把握别的任务什么时候完成（它可能不知道干嘛去了），你不想等它，所以只能设置一个回调接口callback来让它告知你，这跟现实世界很像，你打电话给外卖小哥，外卖小哥说他没有空在送别的外卖，让你留个电话号码，等出单或者到了再告诉你，而你又可以不用一直等这个外卖了（忙别的事情），明显你和外卖小哥是活在不同时间线的，双方都很自由；大部分事件处理都是异步调用来的，像按键中断，只有按键值输入的时候你才需要做按键事件处理；还有倍福ADS接口：客户端注册一个回调函数，当事件发生时，ADS库会自动调用该函数，当目标变量（如PLC中的某个变量）的值发生变化时，ADS服务器会主动通知客户端 总结 编程其实是对现实生活的抽象 业务模型也具有普适性，不管物联网、自动化、还是汽车电子","tags":["反思","同步","异步"],"categories":["程序设计"]},{"title":"vscode支持ros2程序debug","path":"//vscode-ros2-debug.html","content":"安装下载 1wget https://az764295.vo.msecnd.net/stable/1a5daa3a0231a0fbba4f14db7ec463cf99d7768e/code_1.84.2-1699528352_amd64.deb 安装 1sudo dpkg -i code_1.84.2-1699528352_amd64.deb 打开 1code . 插件在打开ros2工程前需要安装几个插件 CMake CMake Tools Python Ros XML Tools 配置c_cpp_properties.json这个文件用于配置编译条件，我这里用的是foxy版本的ros2，其他版本可以参考着改 1234567891011121314151617&#123; &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Linux&quot;, &quot;includePath&quot;: [ &quot;$&#123;workspaceFolder&#125;/**&quot;, &quot;/opt/ros/foxy/include/**&quot; ], &quot;defines&quot;: [], &quot;compilerPath&quot;: &quot;/usr/bin/gcc&quot;, &quot;cStandard&quot;: &quot;c99&quot;, &quot;cppStandard&quot;: &quot;c++14&quot;, &quot;intelliSenseMode&quot;: &quot;clang-x64&quot; &#125; ], &quot;version&quot;: 4&#125; launch.json这个文件用于启动ros2 package，target选项用于配置package运行脚本，一般用相对位置比较合适 123456789101112131415&#123; // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;ROS: Launch&quot;, &quot;type&quot;: &quot;ros&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;target&quot;: &quot;./install/aglidar_sdk/share/aglidar_sdk/launch/start.py&quot; &#125; ]&#125; settings.jsonvscode的基本配置，关联一些cpp的库、其它文件类型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&#123; &quot;editor.tabSize&quot;: 8, &quot;editor.rulers&quot;: [ 100 ], &quot;files.associations&quot;: &#123; &quot;*.repos&quot;: &quot;yaml&quot;, &quot;*.world&quot;: &quot;xml&quot;, &quot;*.xacro&quot;: &quot;xml&quot;, &quot;chrono&quot;: &quot;cpp&quot;, &quot;cctype&quot;: &quot;cpp&quot;, &quot;clocale&quot;: &quot;cpp&quot;, &quot;cmath&quot;: &quot;cpp&quot;, &quot;csignal&quot;: &quot;cpp&quot;, &quot;cstdarg&quot;: &quot;cpp&quot;, &quot;cstddef&quot;: &quot;cpp&quot;, &quot;cstdio&quot;: &quot;cpp&quot;, &quot;cstdlib&quot;: &quot;cpp&quot;, &quot;cstring&quot;: &quot;cpp&quot;, &quot;ctime&quot;: &quot;cpp&quot;, &quot;cwchar&quot;: &quot;cpp&quot;, &quot;cwctype&quot;: &quot;cpp&quot;, &quot;any&quot;: &quot;cpp&quot;, &quot;array&quot;: &quot;cpp&quot;, &quot;atomic&quot;: &quot;cpp&quot;, &quot;strstream&quot;: &quot;cpp&quot;, &quot;bit&quot;: &quot;cpp&quot;, &quot;*.tcc&quot;: &quot;cpp&quot;, &quot;bitset&quot;: &quot;cpp&quot;, &quot;codecvt&quot;: &quot;cpp&quot;, &quot;complex&quot;: &quot;cpp&quot;, &quot;condition_variable&quot;: &quot;cpp&quot;, &quot;cstdint&quot;: &quot;cpp&quot;, &quot;deque&quot;: &quot;cpp&quot;, &quot;forward_list&quot;: &quot;cpp&quot;, &quot;list&quot;: &quot;cpp&quot;, &quot;map&quot;: &quot;cpp&quot;, &quot;set&quot;: &quot;cpp&quot;, &quot;unordered_map&quot;: &quot;cpp&quot;, &quot;vector&quot;: &quot;cpp&quot;, &quot;exception&quot;: &quot;cpp&quot;, &quot;algorithm&quot;: &quot;cpp&quot;, &quot;functional&quot;: &quot;cpp&quot;, &quot;iterator&quot;: &quot;cpp&quot;, &quot;memory&quot;: &quot;cpp&quot;, &quot;memory_resource&quot;: &quot;cpp&quot;, &quot;numeric&quot;: &quot;cpp&quot;, &quot;optional&quot;: &quot;cpp&quot;, &quot;random&quot;: &quot;cpp&quot;, &quot;ratio&quot;: &quot;cpp&quot;, &quot;string&quot;: &quot;cpp&quot;, &quot;string_view&quot;: &quot;cpp&quot;, &quot;system_error&quot;: &quot;cpp&quot;, &quot;tuple&quot;: &quot;cpp&quot;, &quot;type_traits&quot;: &quot;cpp&quot;, &quot;utility&quot;: &quot;cpp&quot;, &quot;fstream&quot;: &quot;cpp&quot;, &quot;future&quot;: &quot;cpp&quot;, &quot;initializer_list&quot;: &quot;cpp&quot;, &quot;iomanip&quot;: &quot;cpp&quot;, &quot;iosfwd&quot;: &quot;cpp&quot;, &quot;iostream&quot;: &quot;cpp&quot;, &quot;istream&quot;: &quot;cpp&quot;, &quot;limits&quot;: &quot;cpp&quot;, &quot;mutex&quot;: &quot;cpp&quot;, &quot;new&quot;: &quot;cpp&quot;, &quot;ostream&quot;: &quot;cpp&quot;, &quot;shared_mutex&quot;: &quot;cpp&quot;, &quot;sstream&quot;: &quot;cpp&quot;, &quot;stdexcept&quot;: &quot;cpp&quot;, &quot;streambuf&quot;: &quot;cpp&quot;, &quot;thread&quot;: &quot;cpp&quot;, &quot;cfenv&quot;: &quot;cpp&quot;, &quot;cinttypes&quot;: &quot;cpp&quot;, &quot;typeindex&quot;: &quot;cpp&quot;, &quot;typeinfo&quot;: &quot;cpp&quot;, &quot;valarray&quot;: &quot;cpp&quot;, &quot;variant&quot;: &quot;cpp&quot; &#125;, // Autocomplete from ros python packages &quot;python.autoComplete.extraPaths&quot;: [ &quot;/opt/ros/foxy/lib/python3.8/site-packages/&quot; ], // Environment file lets vscode find python files within workspace &quot;python.envFile&quot;: &quot;$&#123;workspaceFolder&#125;/.env&quot;, // Use the system installed version of autopep8 &quot;python.formatting.autopep8Path&quot;: &quot;/usr/bin/autopep8&quot;, &quot;python.formatting.autopep8Args&quot;: [ &quot;--max-line-length=100&quot; ], &quot;C_Cpp.default.intelliSenseMode&quot;: &quot;clang-x64&quot;, &quot;C_Cpp.formatting&quot;: &quot;Disabled&quot;, &quot;uncrustify.useReplaceOption&quot;: true, &quot;uncrustify.configPath.linux&quot;: &quot;/opt/ros/foxy/lib/python3.8/site-packages/ament_uncrustify/configuration/ament_code_style.cfg&quot;, &quot;cSpell.words&quot;: [ &quot;RTPS&quot;, &quot;athackst&quot;, &quot;autopep&quot;, &quot;cmake&quot;, &quot;cppcheck&quot;, &quot;cpplint&quot;, &quot;deque&quot;, &quot;devcontainer&quot;, &quot;ints&quot;, &quot;noqa&quot;, &quot;pytest&quot;, &quot;rclcpp&quot;, &quot;rclpy&quot;, &quot;repos&quot;, &quot;rosdistro&quot;, &quot;rosidl&quot;, &quot;uncrustify&quot;, &quot;xmllint&quot; ], &quot;search.exclude&quot;: &#123; &quot;**/node_modules&quot;: true, &quot;**/bower_components&quot;: true, &quot;**/*.code-search&quot;: true, &quot;**/build&quot;: true, &quot;**/install&quot;: true, &quot;**/log&quot;: true &#125;, &quot;python.analysis.extraPaths&quot;: [ &quot;/opt/ros/foxy/lib/python3.8/site-packages/&quot; ], &quot;cSpell.allowCompoundWords&quot;: true, &quot;cSpell.ignorePaths&quot;: [ &quot;**/package-lock.json&quot;, &quot;**/node_modules/**&quot;, &quot;**/vscode-extension/**&quot;, &quot;**/.git/objects/**&quot;, &quot;.vscode&quot;, &quot;.vscode-insiders&quot;, &quot;.devcontainer/devcontainer.json&quot; ], &quot;ros.distro&quot;: &quot;foxy&quot;, &quot;cmake.sourceDirectory&quot;: &quot;/home/asensing/workspace/Asensing_LiDAR_ROS/aglidar_sdk&quot;&#125; tasks.json编译任务配置，debug需求的可以改成debug编译类型 123456789101112131415161718&#123; // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ &#123; &quot;label&quot;: &quot;build&quot;, &quot;detail&quot;: &quot;Build workspace (default)&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;colcon build --cmake-args &#x27;-DCMAKE_BUILD_TYPE=Debug&#x27; -Wall -Wextra -Wpendantic&quot;, &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true &#125;, &quot;problemMatcher&quot;: &quot;$gcc&quot; &#125; ]&#125; 调试调试快捷键列表，基本就是Visual Studio那一套 序号 功能 按键 1 单步 F10 2 单步进入 F11 3 单步跳出 Shift + F11 4 恢复 F5 5 暂停 F5 6 停止 Shift + F5 7 重新运行 Ctrl + Shift + F5 8 运行task编译工程 Ctrl + Shift + B 9 切换断点 F9 10 前进 Ctrl + Shift + - 11 后退 Ctrl + Alt + - 12 运行 Ctrl + Shift + D 调试界面效果","tags":["ROS2","vscode","debug"],"categories":["开发工具"]},{"title":"QMainWindow子窗口独立全屏","path":"//qmainwindow-subwindow-fullscreen.html","content":"事件过滤器QMainWindow的子类对象的构造函数中安装事件过滤器 1centralWidget()-&gt;installEventFilter(this); 信号和槽由QAction触发进入全屏 123456connect(this-&gt;Internals-&gt;actionFull_Screen, &amp;QAction::triggered, this, [=](bool flag) &#123; auto widget = centralWidget(); m_windowFlags = widget-&gt;windowFlags(); widget-&gt;setWindowFlag(Qt::Window); widget-&gt;showFullScreen();&#125;); 退出全屏重写QMainWindow子类对象的eventFilter虚函数，在里边添加以下代码 12345678910if(obj == centralWidget() &amp;&amp; ev-&gt;type() == QEvent::KeyPress) &#123; auto keyEvent = static_cast&lt;QKeyEvent *&gt;(ev); if(keyEvent-&gt;key() == Qt::Key_Escape) &#123; auto widget = centralWidget(); widget-&gt;setWindowFlags(m_windowFlags); widget-&gt;showNormal(); this-&gt;Internals-&gt;actionFull_Screen-&gt;setChecked(false); return true; &#125;&#125;","tags":["Qt","QMainWindow","全屏"],"categories":["嵌入式"]},{"title":"Qt工程远程调试","path":"//qt-project-remote-debug.html","content":"准备1）需要准备一些工具（交叉编译） ssh：openssh或者dropbear，开发板端部署sshd、宿主机端部署ssh sftp：一般跟ssh配套的，这个也放开发板端 arm-gdb：放在宿主机端 gdbserver：放在开发板端 2）在QtCreator添加Remote Device，保证ssh连接上 3）在Build &amp; Run里边配置Kits Device Sysroot Compiler Debugger Qt version cmakeQtCreatorDeployment.txt写法参考 12远程绝对路径宿主文件路径:远程相对路径 实践：添加开发板所需要的文件到&#x2F;mnt目录 123/mnt//home/uisrc/project/lidarConfig_A_MEMS.json:data/home/uisrc/project/LDR0011A0_APP/demoApp:bin qmakeqmake pro文件写法：local.path表示本地路径，target.path表示远程路径，通过addFiles的属性赋值添加要部署的目录或文件 123456local.path = $$OUT_PWDlocal.path ~= s/builds.*/target.path = /rootaddFiles.path = $$target.pathaddFiles.files += file1addFiles.files += file2 实践：部署app放到&#x2F;root目录下 1234local.path = $$OUT_PWDlocal.path ~= s/builds.*/target.path = /rootINSTALLS += target 运行配置以下是工程配置参考","tags":["Qt","远程调试"],"categories":["嵌入式"]},{"title":"增量和存量市场","path":"//incremental-stock-market.html","content":"前言作为一名技术人，要对产品的市场动态时刻保持敏感，了解产品的昨天、今天、明天，才能有的放矢；不懂产品的程序员不是好程序员，我去过的公司，大部分也是程序员主导产品的研发流程，一部分人要承担项目前期的需求挖掘、客户拜访、可行性调研、产品文档编写、技术支持、产品运营等工作，可见市场敏感度对技术人来说很重要 增量市场定义 市场存在大量的需求，产品的潜力未有被充分挖掘，各种因素如政治、经济、疫情等导致需求的爆发，各方有百花齐放的趋势，巨头还没有出现，人称蓝海 特点 产品还没有充分被定义，存在着各种各样的发展方向和技术路线 需求量比较大，有引领时代潮流的趋势，堪称风口 时效性，产品也有它的生命周期，不会永远保持旺盛的产品力 与地缘政治、经济因素、社会动态强烈相关 识别 激光雷达：2022年激光雷达是增量市场，但2024年不是 半导体设备：如光刻机、CVD、PVD、Etch设备等 机器人：医护机器人、工业机器人等 核磁共振设备 存量市场定义 产品已经被定义、被市场接纳，行业的巨头有形成垄断的趋势，价格已经被打下来，利润空间很少了，称为红海，一般不建议加入存量市场 特点 需求已经明确，供应链稳定 行业垄断，头部竞争者占据优势地位（资本、技术、市场、人才） 利润空间不大 识别 2022年激光雷达是增量市场，但2024年不是，如今的汽车也不再是增量市场 2024年的新能源汽车是存量市场，价格战越演越烈，特斯拉、比亚迪等巨头体量优势特别明显，新势力则是赔本赚吆喝 公民教育，随着人口出生率下降，受教育的需求没有以前那么旺盛，教育市场已趋于饱和","tags":["产品","市场"],"categories":["方法论"]},{"title":"汽车零部件研发的各个阶段","path":"//auto-parts-stage.html","content":"A样原型机开发阶段，问题较多且功能有限，以功能原理验证为主，一般是人工制造为主，比如拼模块组装，简易打板或者直接购买demo板 B样积累了一定的解决问题的经验，基本结构已经成型（产品参数），也有了成型的PCB板，软硬件处于不断的磨合阶段，此阶段硬件、软件的改动比较频繁，产品研发的主要阶段，持续时间比较长，还是人工制造为主 C样已经能够在生产线小批量生产，快速部署，还需要进行各项测试，可以借助一些自动化软件、设备辅助生产，提高生产效率 D样已经能够批量交付用户使用，可用于相关部门的检查、认证，此时也有完整的用户手册，出现问题也有技术支持","tags":["产品","汽车电子"],"categories":["方法论"]},{"title":"项目概要设计说明书","path":"//project-overview-specification.html","content":"项目介绍xxx是一个什么样的项目，技术点、人力投入、工期 需求概述把客户的目标需求大致讲清楚 应用领域 运行环境 功能指标 性能指标 条件限制 技术可行性分析材料、结构、硬件、软件、测试角度分析 需要采购什么设备、走什么认证流程、用什么测试手段 系统架构 &#x2F; 总体设计软硬件系统组成结构 上位机 下位机 服务器 通信协议 功能模块对系统架构里边的模块逐一拆解、分析，列出系统框图 模块1 模块2 模块3 每个模块工作流程图 流程1 流程2 流程3 接口设计模块的通信接口进行定义 接口1 接口2 接口3 通信协议硬件接口 软件协议 测试前置依赖：需要什么人、什么设备、什么条件 性能、参数指标测试 黑盒、白盒 维护客户现场出现问题怎么解决，材料、结构、硬件、软件的职责范围","tags":["管理","项目","说明书"],"categories":["方法论"]},{"title":"Ubuntu22.04搭建ROS2运行环境","path":"//ubuntu22.04-install-ros2.html","content":"区域语言设置设置区域语言为US 123456789sudo apt updatesudo apt install localessudo locale-gen en_US en_US.UTF-8sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8export LANG=en_US.UTF-8 必备软件组件如果已经安装，可以跳过这一步骤 1234567sudo apt updatesudo apt-get install -y libyaml-cpp-devsudo apt-get install -y libpcap-devsudo apt install -y curl gnupg lsb-release 更新远程仓库源更新/etc/hosts文件，防止raw.githubusercontent.com被墙，可以通过nslookup命令查看域名服务器地址 12345185.199.110.133\traw.githubusercontent.com185.199.110.133 user-images.githubusercontent.com185.199.110.133 avatars2.githubusercontent.com185.199.100.133 avatars1.githubusercontent.com20.205.243.166 github.com 如果已经添加过源，这一步也可以跳过 12345sudo curl -sSL http://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpgecho &quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(source /etc/os-release &amp;&amp; echo $UBUNTU_CODENAME) main&quot; | sudo tee /etc/apt/sources.list.d/ros2.list &gt; /dev/nullsudo apt update 安装humble桌面版和基础版二选一 12sudo apt install ros-humble-desktop # 桌面版sudo apt install ros-humble-ros-base\t# 基础版 安装软件包colcon和libbackward-ros都安装一下 12sudo apt-get install python3-colcon-common-extensionssudo apt-get install -y ros-humble-backward-ros 验证ROS2借用小乌龟来验证是否成功，humble版本如果没有预装turtlesim的话请事先安装 1sudo apt install ros-humble-turtlesim 运行turtlesim_node和turtle_teleop_key两个节点 123source /opt/ros/humble/setup.bashros2 run turtlesim turtlesim_noderos2 run turtlesim turtle_teleop_key 控制效果 完全卸载如果你不想用humble这个版本，请用以下命令卸载干净 1sudo apt-get autoremove --purge ros-humble-desktop","tags":["ROS2","ubuntu22.04"],"categories":["操作系统"]},{"title":"解决csv文件导出时间戳精度丢失的问题","path":"//csv-file-lose-precision.html","content":"丢失精度以圆周率数据输出为例，如果直接通过ostream输出到文件，则会丢失精度 123ostream stream;double value = 3.1415926;stream &lt;&lt; value; 保留精度需要通过std::setprecision函数来指定浮点数的精度 123ostream stream;double value = 3.1415926;stream &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; value;","tags":["C++","csv"],"categories":["程序设计"]},{"title":"Windows程序读取不了中文路径问题","path":"//windows-program-chinese-path-problem.html","content":"问题描述今天调试发现win32接口GetFileAttributesW居然不支持中文路径，于是寻找解决方案，找了半天，尝试用boost的fileystem库发现能解决问题，而且boost能跨平台！ 不支持中文win32接口获取文件属性，当传入参数带有中文字符时，它获取的属性就会异常 1DWORD GetFileAttributesW([in] LPCWSTR lpFileName); 支持中文boost判断是否为文件 123std::string realpath = &quot;D:\\\\新建文件夹\\\\a.txt&quot;;boost::filesystem::path p(realpath);boost::filesystem::is_regular_file(p); boost判断是否为文件夹 123std::string realpath = &quot;D:\\\\新建文件夹&quot;;boost::filesystem::path p(realpath);boost::filesystem::is_directory(p); 总结人生苦短，我用boost！","tags":["Windows","win32","中文路径"],"categories":["程序设计"]},{"title":"嵌入式代码优化技巧","path":"//embedded-code-optimization.html","content":"内存管理技巧1.C&#x2F;C++工程应尽量避免深拷贝，尽量用浅拷贝（指针或者引用），如果指针需要频繁拷贝，用智能指针是一种不错的选择 2.启用内存池管理线程的内存开销，事先在堆里边分配好，然后快速使用 避免复杂的浮点运算1.复杂的浮点运算尽量避免，有些芯片是不支持硬件双精度浮点数的，比如全志T3，实在是非用不可，可以用查表的方式加快速度 2.数据传输可以用整型数据压缩减少带宽，这个在can数据传输比较常见 空间换时间比如一个数据模型体积很大，加载起来很耗时，可以考虑把它编译到软件里边去，然后运行的时候提前加载到内存 算法复杂度优化1.时间复杂度，减少循环使用次数 2.空间复杂度的角度优化 并行框架openMP了解一下，在关键的代码段加上omp并行处理 字节对齐用好字节对齐功能可以优化cpu流水线的处理效率 内核态的利用可以把一些业务操作写进驱动，利用操作系统的调度优化，内核态和用户态哪一个更高效，这个是相对的，得看系统调用和库函数的颗粒度，可以值得尝试一下 线程调度尝试调整一些线程的优先级提高调度效率，另外Linux也允许绑核操作 防御性编程 申请一段buffer后总是习惯性的将其内容memset为0，当然这是针对plain类型的数据，防止在数据解析的时候解析到不合法的数据 总是习惯性的判断数组的边界 申请指针不应该悬空，应该给它一个值或者是nullptr，使用前判断它是否为空 巧用断言","tags":["调优","优化"],"categories":["嵌入式"]},{"title":"软件版本那些事","path":"//software-version.html","content":"软件版本跟测试阶段或者软件的生命周期所处的阶段有关，一般有以下几个版本 alpha内测版本，仅限团队内部测试使用，不对外公开。大多数软件产品在向公众发布之前都要经过多个步骤。alpha版本是该系统的一部分，用于开发高效、准确和无缺陷的软件程序。这一阶段软件会频繁改动。 项目处于不稳定状态。可能有许多未修复的错误，包括安全问题。API可能会更改，恕不另行通知。安装新的alpha版本需要卸载项目，从而丢失所有数据。只针对那些想要提前预览项目的人。尚不适合共享发展。不适合生产现场使用。目标受众是希望参与项目测试、调试和开发的开发人员。 beta通过内部测试之后的版本，开放给外部渠道使用。Beta版本通常在外观、感觉和功能上与最终产品相当接近；在这一阶段变更还是会经常发生。 所有重要的数据丢失和安全漏洞得到解决。如果模块提供了一个API，它应该被认为是冻结的，这样那些使用API的人就可以开始升级他们的项目了。如果是项目的升级或更新，则应提供升级&#x2F;更新路径，并且现有用户应该能够在不丢失数据的情况下升级&#x2F;更新到新版本。所有文档都应该是最新的。目标受众是想要参与项目的测试、调试和开发的开发人员，以及与项目对接的其他项目的开发人员。通常不适用于生产站点，但如果站点管理员非常了解项目，并且知道如何处理任何遗留问题，则可以在某些生产站点上使用。 rcrelease candidate，beta版本迭代之后比较成熟的版本，按照惯例，每当程序的更新几乎准备就绪时，测试版本就会被赋予rc号。如果发现了需要修复的关键错误，则更新程序并以更高的rc号重新发布。当没有严重错误存在，或者没有发现额外的严重错误时，rc名称将被删除。 release正式提供给客户使用的版本 stablerelease版本中的稳定版本，一般比较少使用","tags":["版本"],"categories":["方法论"]},{"title":"程序员健康指南","path":"//programmer-health-guide.html","content":"前言前不久，IT界的大佬左耳朵耗子陈皓心梗逝世，享年仅47岁，真是天妒英才，据说他是一名工作狂…… 感慨好的身体是革命的本钱，年纪越大，就会发现编程并不是脑力活，其实更偏向体力活！长时间工作吃的是人的体力和精力，开会、写文档、编码、测试样样工作都需要有充沛和持续的精力投入；在中国这种996工作制遍地开花的国度，如果你没有铁一样的身体素质，你基本很难熬35岁这道坎，这也是为什么很多公司喜欢招小年轻的原因；并且，久坐在办公室容易引发很多疾病：眼疲劳、关节疼痛、头晕眼花、颈椎病……新闻经常能听到这样的剧本：某某大厂员工在加班的时候突然猝死，留下背负房贷的妻儿老小……说了这么多，想必大家已经知道拥有一个好身体对程序员来说是多么的重要，下面将从几个方面介绍一些程序员健康指南，希望能对广大程序员有所帮助 作息篇 早点睡 多睡点 睡好点 尽量午睡 饮食篇 少吃甜食 少盐 少油 多喝水 荤素搭配 运动篇 慢跑 &#x2F; 散步，Linus就是在家里买了一台跑步机，边跑步边编码 伸腿、弯腰 到户外去，city walk或者到公园散散心都可以 工作篇 番茄工作法，将一个任务分解一个个工作包，以一个工作包为单位执行 学会坦然，现实生活中技术问题往往不是最重要的问题，大多数问题也跟编程无关 向上管理，遇到问题学会及时反馈，而不是一个人扛着 提高工作效率，要做的事情排一个优先级 生活篇 多遵循内心的意愿 学会拒绝 有什么喜欢的事情要趁着年轻去追寻，尝试一些爱好，如学学钢琴、听听音乐会 张弛有道，切勿绷得像机械钟的发条一样紧 社交篇 尊重他人的想法 尊重自己的内心 语录《活着》 没有什么比时间更具有说服力了，因为时间无需通知我们就可以改变一切 人是为活着本身而活着，而不是为了活着之外的任何事物所活着 一个人命再大，要是自己想死，那就怎么也活不了 《百年孤独》 我们终究会死。所以我们的人生目标不该是长命百岁，而应该做点自己想做的","tags":["健康","职业"],"categories":["学科"]},{"title":"gdb8.3交叉编译","path":"//gdb8.3-porting.html","content":"下载去gdb官网下载gdb8.3 1wget https://ftp.gnu.org/gnu/gdb/gdb-8.3.tar.xz 下载完成后解压xz文件 12tar xf gdb-8.3.tar.xzcd gdb-8.3 配置环境变量 1export PATH=$PATH:/home/topeet/rk3399/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin 编译gdb 12./configure --target=aarch64-linux-gnu --prefix=$PWD/buildmake -j8 编译gdbserver 123cd gdb./configure --target=aarch64-linux-gnu --host=aarch64-linux-gnu --prefix=$PWD/build CXXFLAGS=&#x27;-fPIC -static&#x27;make -j8 测试将gdbserver部署到开发板文件系统，并运行gdbserver 1gdbserver --multi :10000 demo 宿主机端运行aarch64-linux-gnu-gdb 1target remote 192.168.137.22:10000","tags":["gdb","交叉编译"],"categories":["嵌入式"]},{"title":"about","path":"/about/index.html","content":"hywing’s blog作者嵌入式全栈开发者，从事物联网、自动化、汽车电子开发工作 内容分享一些工作中的问题、想法，与技术、管理、产品相关的记录、思考、沉淀，希望对读者有帮助 原则 尽量简短 尽量少图片 尽量准确 免责这个是我的个人博客，如果对你有帮助是我莫大的荣幸，自行更改请恕不另行通知！"}]