[{"title":"自动化调参工具：VOFA+使用教程","path":"//automation-tool-vofa-plus.html","content":"介绍VOFA+是一个精致的数据可视化上位机软件，支持多个数据接口（串口、网口）、自定义数据引擎和定制数据可视化控件，是一个不可多得的自动化调参软件（示波器类似物），个人觉得它将串口调参的功能发挥到了极致 前端数据引擎和数据接口参数配置：选择FireWater引擎，数据接口选串口，串口配置115200 8N1 通道数据展示：通道开关+名称+颜色+小数点位置 可以控制缓冲区里边可视化数据点数：点击红色原点进行波形放大、缩小 文本展示区，可以实时展示接收+发送内容 控件可以点击左侧的控件栏，左键选中控件并拖到波形展示区域 主窗口支持多个Tab分页，可以将不同的数据分类展示，支持分类的重命名 绑定数据通道绑定X轴已经Y轴，只要在控件右键弹出菜单就可以配置X轴、Y轴，其它控件同理 指定上位机的时间戳为X轴，当然你可以用数据通道指定的X轴（不用上位机的时间戳） 以FireWater数据引擎+串口数据接口为例：使用指定格式输出数据：”%f,%f,%f,%f ”，只要往printf输出格式化数据就行，以下嵌入式代码用于生成自定义的正弦波数据，printf的参数配置需要和上位机的串口配置一致 123456789101112131415161718192021222324252627282930313233// 打印表头printf(&quot;Angle,Sin(x),Cos(x),Sin(x)*Cos(x),Cos(x)*Cos(x)\\r &quot;);// 生成三角函数数据float angle = 0.0f; // 角度(度)float angleRad; // 角度(弧度)float sinVal, cosVal; // sin(x)和cos(x)值float sinCosVal, cosSquareVal; // sin(x)*cos(x)和cos(x)*cos(x)值for(;;) &#123; // 每15度输出一次数据 while(angle &lt;= 360.0f) &#123; // 转换为弧度 angleRad = angle * 0.01745329f; // 0.01745329 = π/180 // 计算三角函数值 sinVal = sin(angleRad); cosVal = cos(angleRad); sinCosVal = sinVal * cosVal; cosSquareVal = cosVal * cosVal; // 使用指定格式输出数据：&quot;%f,%f,%f,%f &quot; printf(&quot;%f,%f,%f,%f\\r &quot;, sinVal, cosVal, sinCosVal, cosSquareVal); // 角度增加15度 angle += 15.0f; // 延时，避免输出太快 DEVICE_DELAY_US(500); // 延时100ms &#125; angle = 0;&#125; 波形实时展示效果 总结理论上也能支持CAN接口，要是支持CAN就完美了","tags":["自动化","调参工具","VOFA+"],"categories":["开发工具"]},{"title":"LAUNCHXL-F28379D链接文件功能详解","path":"//launchxl-f28379d-link-script.html","content":"CMD文件主要是有FLASH和RAM两种下载模式：FLASH是把程序烧录到FLASH中运行，RAM模式则是把程序烧录到RAM里边运行，以TMS320F28379D为例，它支持2837xD_FLASH_lnk_cpu1.cmd和2837xD_RAM_lnk_cpu1.cmd两种下载调试模式，下载模式可以在对应工程的Properties -&gt; General -&gt; Linker command file里边指定 FLASHFLASH模式主要包括MEMORY和SECTIONS两个字段；至于内存块怎么用，SECTIONS会告诉你 123456789MEMORY&#123;&#125;SECTIONS&#123;&#125; 一般MEMORY会分成两个PAGE：PAGE0和PAGE1，PAGE0存放program代码（FLASH），PAGE1存放data代码（RAM）；每个PAGE包含若干个内存块，每个内存块的字段名、起始地址和大小空间会在MEMORY里边给出，原则上合起来的空间不能超过物理内存空间大小 12345678910111213141516171819202122232425262728MEMORY&#123;PAGE 0 : /* 程序存储区(Flash) */ BEGIN : origin = 0x080000, length = 0x000002 FLASHA : origin = 0x080002, length = 0x001FFE /* 方案一：合并FLASHB/C/D为一个更大的区域（已应用） */ FLASHBCD : origin = 0x082000, length = 0x006000 /* 24KB (合并B+C+D) */ /* 方案二：分别保留各区（如需用方案二，注释上面的FLASHBCD，取消下面三行的注释） FLASHB : origin = 0x082000, length = 0x002000 FLASHC : origin = 0x084000, length = 0x002000 FLASHD : origin = 0x086000, length = 0x002000 */ FLASHE : origin = 0x088000, length = 0x008000 FLASHF : origin = 0x090000, length = 0x008000 RESET : origin = 0x3FFFC0, length = 0x000002PAGE 1 : /* 数据存储区(RAM) */ RAMM0 : origin = 0x000123, length = 0x0002DD RAMM1 : origin = 0x000400, length = 0x0003F8 RAMLS0 : origin = 0x008000, length = 0x000800 RAMLS5 : origin = 0x00A800, length = 0x000800 RAMGS0 : origin = 0x00C000, length = 0x001000 RAMGS1 : origin = 0x00D000, length = 0x001000 CPU1TOCPU2RAM : origin = 0x03FC00, length = 0x000400&#125; 至于内存块怎么用，SECTIONS会告诉你，SECTIONS会把MEMORY里边定义的内存块安排得明明白白，以下代码跟ARM里边的link script差不多，我们可以看到下边代码段（eabi、text、const）主要是存放在FLASH空间，数据段（bss、func、stack、data）主要是存放RAM空间 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960SECTIONS&#123; /*--- 启动代码段 ---*/ codestart : &gt; BEGIN, PAGE = 0 .reset : &gt; RESET, PAGE = 0, TYPE = DSECT /*--- EABI段 ---*/ .cinit : &gt; FLASHA, PAGE = 0, ALIGN(8) /* 方案一：使用更大的合并区（已应用） */ .text : &gt; FLASHBCD, PAGE = 0, ALIGN(8) /* 方案二：分配到多个区（如需用方案二，注释上面的.text行，取消下面这行的注释） .text : &gt;&gt; FLASHB | FLASHC | FLASHD, PAGE = 0, ALIGN(8) */ .const : &gt; FLASHF, PAGE = 0, ALIGN(8) .init_array : &gt; FLASHA, PAGE = 0, ALIGN(8) .bss : &gt; RAMLS5, PAGE = 1, ALIGN(8) .sysmem : &gt; RAMGS1, PAGE = 1, ALIGN(8) /*--- RAM函数段 ---*/ .TI.ramfunc : &#123; *(.TI.ramfunc) *(.ramfunc) &#125; LOAD = FLASHE, PAGE = 0 /* 将FLASHD改为FLASHE，避免冲突 */ RUN = RAMLS0, PAGE = 1 LOAD_START(RamfuncsLoadStart), LOAD_END(RamfuncsLoadEnd), LOAD_SIZE(RamfuncsLoadSize), RUN_START(RamfuncsRunStart), RUN_SIZE(RamfuncsRunSize), RUN_END(RamfuncsRunEnd), ALIGN(8) /*--- 数据段 ---*/ .stack : &gt; RAMGS0, PAGE = 1 /* 改为更大的内存区 */ .data : &gt; RAMGS0, PAGE = 1 .cio : &gt; RAMLS5, PAGE = 1 /*--- COFF兼容段 ---*/ .pinit : &gt; FLASHA, PAGE = 0, ALIGN(8) .ebss : &gt; RAMLS5, PAGE = 1 .econst : &gt; FLASHA, PAGE = 0, ALIGN(8) .esysmem : &gt; RAMGS1, PAGE = 1 /*--- IPC通信段 ---*/ GROUP : &gt; CPU1TOCPU2RAM, PAGE = 1 &#123; PUTBUFFER PUTWRITEIDX GETREADIDX &#125; /*--- 明确指定ramgs0/ramgs1段，消除警告 ---*/ ramgs0 : &gt; RAMGS0, PAGE = 1 ramgs1 : &gt; RAMGS1, PAGE = 1&#125; link script里边每个字段的功能 段名称 内存位置 页面 说明 codestart BEGIN PAGE &#x3D; 0 代码起始部分，位于Flash初始地址，包含程序入口点 .reset RESET PAGE &#x3D; 0 复位向量段，TYPE &#x3D; DSECT表示只是描述性的，不占用实际空间 .cinit FLASHA PAGE &#x3D; 0 C语言全局变量初始化表，ALIGN(8)表示按8字节对齐 .text FLASHBCD PAGE &#x3D; 0 主要代码段，放在合并的大Flash区域(24KB)以容纳更多代码 .const FLASHF PAGE &#x3D; 0 常量数据段，存放在Flash中的只读数据 .init_array FLASHA PAGE &#x3D; 0 用于C++全局对象构造函数的表 .bss RAMLS5 PAGE &#x3D; 1 未初始化的全局和静态变量段，位于RAM中 .sysmem RAMGS1 PAGE &#x3D; 1 动态内存分配的堆区域，用于malloc()等函数 .TI.ramfunc FLASHE→RAMLS0 PAGE &#x3D; 0→1 RAM函数段，特殊处理：在Flash中存储但运行时复制到RAM中执行 .stack RAMGS0 PAGE &#x3D; 1 系统堆栈段，已移至更大的内存区域RAMGS0 .data RAMGS0 PAGE &#x3D; 1 已初始化的全局和静态变量段 .cio RAMLS5 PAGE &#x3D; 1 C标准I&#x2F;O缓冲区 .pinit FLASHA PAGE &#x3D; 0 用于C++全局对象初始化的表(旧格式) .ebss RAMLS5 PAGE &#x3D; 1 扩展的.bss段，COFF格式兼容性 .econst FLASHA PAGE &#x3D; 0 扩展的常量段，COFF格式兼容性，存放在Flash中 .esysmem RAMGS1 PAGE &#x3D; 1 扩展的系统内存段，COFF格式兼容性 GROUP (CPU1TOCPU2RAM) CPU1TOCPU2RAM PAGE &#x3D; 1 CPU1到CPU2的通信缓冲区，包含多个子段 ramgs0&#x2F;ramgs1 RAMGS0&#x2F;RAMGS1 PAGE &#x3D; 1 明确指定这些内存区域的段名，以消除链接警告 RAMRAM模式主要包括MEMORY和SECTIONS两个字段，这个跟FLASH模式是一样的，但不同的是： 123456789MEMORY&#123;&#125;SECTIONS&#123;&#125; 一般MEMORY会分成两个PAGE：PAGE0和PAGE1，PAGE0存放program代码（RAM），PAGE1存放data代码（RAM），可以看到为了优化调试运行速度，所有的应用及数据都放在RAM运行了 1234567891011121314151617181920212223242526272829303132333435363738394041424344MEMORY&#123;PAGE 0 : BEGIN : origin = 0x000000, length = 0x000002 RAMM0 : origin = 0x000123, length = 0x0002DD RAMD0 : origin = 0x00B000, length = 0x000800 RAMLS0 : origin = 0x008000, length = 0x000800 RAMLS1 : origin = 0x008800, length = 0x000800 RAMLS2 : origin = 0x009000, length = 0x000800 RAMLS3 : origin = 0x009800, length = 0x000800 RAMLS4 : origin = 0x00A000, length = 0x000800 RESET : origin = 0x3FFFC0, length = 0x000002PAGE 1 : BOOT_RSVD : origin = 0x000002, length = 0x000121 RAMM1 : origin = 0x000400, length = 0x0003F8 RAMD1 : origin = 0x00B800, length = 0x000800 RAMLS0 : origin = 0x008000, length = 0x000800 RAMLS5 : origin = 0x00A800, length = 0x000800 RAMGS0 : origin = 0x00C000, length = 0x001000 RAMGS1 : origin = 0x00D000, length = 0x001000 RAMGS2 : origin = 0x00E000, length = 0x001000 /* 合并RAMGS3~5为一个大区 */ RAMGS3_5 : origin = 0x00F000, length = 0x003000 /* 注释掉原有的RAMGS3~5 RAMGS3 : origin = 0x00F000, length = 0x001000 RAMGS4 : origin = 0x010000, length = 0x001000 RAMGS5 : origin = 0x011000, length = 0x001000 */ RAMGS6 : origin = 0x012000, length = 0x001000 RAMGS7 : origin = 0x013000, length = 0x001000 RAMGS8 : origin = 0x014000, length = 0x001000 RAMGS9 : origin = 0x015000, length = 0x001000 RAMGS10 : origin = 0x016000, length = 0x001000 RAMGS11 : origin = 0x017000, length = 0x001000 RAMGS12 : origin = 0x018000, length = 0x001000 RAMGS13 : origin = 0x019000, length = 0x001000 RAMGS14 : origin = 0x01A000, length = 0x001000 RAMGS15 : origin = 0x01B000, length = 0x000FF8 CPU2TOCPU1RAM : origin = 0x03F800, length = 0x000400 CPU1TOCPU2RAM : origin = 0x03FC00, length = 0x000400 CANA_MSG_RAM : origin = 0x049000, length = 0x000800 CANB_MSG_RAM : origin = 0x04B000, length = 0x000800&#125; 我们可以看到下边代码段（eabi、text、const）以及数据段（bss、func、stack、data）全都存RAM空间 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647SECTIONS&#123; codestart : &gt; BEGIN, PAGE = 0 .reset : &gt; RESET, PAGE = 0, TYPE = DSECT /* 让.text段放入合并后的大区 */ .text : &gt; RAMGS3_5, PAGE = 1 .cinit : &gt; RAMM0, PAGE = 0 .switch : &gt; RAMM0, PAGE = 0 .bss : &gt; RAMLS5, PAGE = 1, ALIGN(8) .init_array : &gt; RAMM0, PAGE = 0 .const : &gt; RAMLS5, PAGE = 1 .data : &gt; RAMLS5, PAGE = 1 .sysmem : &gt; RAMLS5, PAGE = 1 .TI.ramfunc : &gt; RAMLS0, PAGE = 1, ALIGN(8) .stack : &gt; RAMM1, PAGE = 1, ALIGN(8) .pinit : &gt; RAMM0, PAGE = 0 .ebss : &gt; RAMLS5, PAGE = 1 .econst : &gt; RAMLS5, PAGE = 1 .esysmem : &gt; RAMLS5, PAGE = 1 Filter_RegsFile : &gt; RAMGS0, PAGE = 1 ramgs0 : &gt; RAMGS0, PAGE = 1 ramgs1 : &gt; RAMGS1, PAGE = 1 /* SDFM例程段移到后面未用的RAM区 */ Filter1_RegsFile : &gt; RAMGS6, PAGE = 1, fill=0x1111 Filter2_RegsFile : &gt; RAMGS7, PAGE = 1, fill=0x2222 Filter3_RegsFile : &gt; RAMGS8, PAGE = 1, fill=0x3333 Filter4_RegsFile : &gt; RAMGS9, PAGE = 1, fill=0x4444 Difference_RegsFile : &gt; RAMGS10, PAGE = 1, fill=0x3333 GROUP : &gt; CPU1TOCPU2RAM, PAGE = 1 &#123; PUTBUFFER PUTWRITEIDX GETREADIDX &#125; GROUP : &gt; CPU2TOCPU1RAM, PAGE = 1 &#123; GETBUFFER : TYPE = DSECT GETWRITEIDX : TYPE = DSECT PUTREADIDX : TYPE = DSECT &#125;&#125; 每个SECTIONS字段功能详解 段名称 内存位置 页面 说明 codestart BEGIN PAGE &#x3D; 0 代码起始部分，通常包含程序入口点和初始化代码 .reset RESET PAGE &#x3D; 0 复位向量段，用于处理CPU复位后的跳转地址，TYPE &#x3D; DSECT表示只是描述性的，不占用实际空间 .text RAMGS3_5 PAGE &#x3D; 1 主要代码段，包含程序的执行代码，放在合并的大内存区域中以容纳更多代码 .cinit RAMM0 PAGE &#x3D; 0 C语言全局变量初始化表段，用于存储全局变量的初始值 .switch RAMM0 PAGE &#x3D; 0 用于C语言switch语句的跳转表 .bss RAMLS5 PAGE &#x3D; 1 未初始化的全局和静态变量段，ALIGN(8)表示按8字节对齐 .init_array RAMM0 PAGE &#x3D; 0 用于C++全局对象构造函数的表 .const RAMLS5 PAGE &#x3D; 1 常量数据段，存放程序中的常量值 .data RAMLS5 PAGE &#x3D; 1 已初始化的全局和静态变量段 .sysmem RAMLS5 PAGE &#x3D; 1 动态内存分配的堆区域，用于malloc()等函数 .TI.ramfunc RAMLS0 PAGE &#x3D; 1 RAM函数段，存放需要在RAM中执行的高性能函数 .stack RAMM1 PAGE &#x3D; 1 系统堆栈段，用于函数调用和局部变量 .pinit RAMM0 PAGE &#x3D; 0 用于C++全局对象初始化的表(旧格式) .ebss RAMLS5 PAGE &#x3D; 1 扩展的.bss段，COFF格式兼容性 .econst RAMLS5 PAGE &#x3D; 1 扩展的常量段，COFF格式兼容性 .esysmem RAMLS5 PAGE &#x3D; 1 扩展的系统内存段，COFF格式兼容性 Filter_RegsFile RAMGS0 PAGE &#x3D; 1 滤波器寄存器文件，用于数字滤波器的配置数据 ramgs0&#x2F;ramgs1 RAMGS0&#x2F;RAMGS1 PAGE &#x3D; 1 明确指定这些内存区域的段名，以便在代码中直接引用 Filter1_RegsFile等 RAMGS6-10 PAGE &#x3D; 1 SDFM(Sigma-Delta滤波器模块)例程数据区，fill值用于特定的初始化模式 GROUP (CPU1TOCPU2RAM) CPU1TOCPU2RAM PAGE &#x3D; 1 CPU1到CPU2的通信缓冲区，包含多个子段用于数据传输和同步 GROUP (CPU2TOCPU1RAM) CPU2TOCPU1RAM PAGE &#x3D; 1 CPU2到CPU1的通信缓冲区，TYPE &#x3D; DSECT表示这些段在CPU1中只是描述性的","tags":["DSP","LAUNCHXL-F28379D","链接脚本"],"categories":["程序设计"]},{"title":"LAUNCHXL-F28379D自定义数据格式打印","path":"//launchxl-f28379d-custom-printf.html","content":"前言调试设备时往往需要有一个高效简单的printf函数帮助追踪错误日志、运行状态，DSP开发也不例外 介绍自带printf如果是按照stm32的方式通过自定义fputc来实现的话，它是可以打印字符串的，但是一旦自定义数值格式输出就报错（Interrupt_illegalOperationHandler） 123456789#include &lt;stdio.h&gt;#include &quot;driverlib/sci.h&quot;int fputc(int c, register FILE *stream)&#123; SCI_writeCharBlockingNonFIFO(SCIA_BASE, (uint16_t)c); while(SCI_getTxFIFOStatus(SCIA_BASE) != SCI_FIFO_TX0); return c;&#125; 配置SCI使用sysconfig配置SCIA串口引脚、参数，SCIA对应的是板子分配的默认串口：RXD和TXD分别对应GPIO43、GPIO42 自定义printf自定义打印函数实现，分别实现dsp_putchar、dsp_puts、print_int、print_float、dsp_printf几个函数 dsp_putchar通过SCI发送单个字符，和标准库putchar对应 1234void dsp_putchar(char c) &#123; SCI_writeCharBlockingNonFIFO(SCIA_BASE, (uint16_t)c); while(SCI_getTxFIFOStatus(SCIA_BASE) != SCI_FIFO_TX0);&#125; dsp_puts通过SCI发送字符串，和标准库puts对应 12345void dsp_puts(const char *str) &#123; while(*str) &#123; dsp_putchar(*str++); &#125;&#125; print_int将整数转换为字符并输出 123456789101112131415161718192021222324252627282930313233void print_int(int32_t num) &#123; char buffer[12]; // 足够保存32位整数 int i = 0; int is_negative = 0; // 特殊处理0 if(num == 0) &#123; dsp_putchar(&#x27;0&#x27;); return; &#125; // 处理负数 if(num &lt; 0) &#123; is_negative = 1; num = -num; &#125; // 转换整数到字符 while(num &gt; 0) &#123; buffer[i++] = &#x27;0&#x27; + (num % 10); num /= 10; &#125; // 如果是负数，添加负号 if(is_negative) &#123; dsp_putchar(&#x27;-&#x27;); &#125; // 反向输出字符 while(i &gt; 0) &#123; dsp_putchar(buffer[--i]); &#125;&#125; print_float将浮点数转换为字符并输出（带2位小数） 123456789101112131415161718192021222324void print_float(float num, int decimal_places) &#123; // 处理负数 if(num &lt; 0) &#123; dsp_putchar(&#x27;-&#x27;); num = -num; &#125; // 提取整数部分 int32_t integer_part = (int32_t)num; print_int(integer_part); // 小数点 dsp_putchar(&#x27;.&#x27;); // 处理小数部分 float fractional_part = num - integer_part; int i; for(i = 0; i &lt; decimal_places; i++) &#123; fractional_part *= 10; int digit = (int)fractional_part; dsp_putchar(&#x27;0&#x27; + digit); fractional_part -= digit; &#125;&#125; dsp_printf简单的格式化打印函数 - 支持 %d, %f, %s, %c 123456789101112131415161718192021222324252627282930313233343536373839404142434445void dsp_printf(const char *format, ...) &#123; va_list args; va_start(args, format); while(*format) &#123; // 处理格式化标记 if(*format == &#x27;%&#x27;) &#123; format++; // 根据格式化类型处理参数 switch(*format) &#123; case &#x27;d&#x27;: case &#x27;i&#x27;: // 整数 print_int(va_arg(args, int)); break; case &#x27;f&#x27;: // 浮点数 print_float(va_arg(args, double), 2); // 默认2位小数 break; case &#x27;s&#x27;: // 字符串 dsp_puts(va_arg(args, char*)); break; case &#x27;c&#x27;: // 字符 dsp_putchar(va_arg(args, int)); // 注意：char参数被提升为int break; case &#x27;%&#x27;: // 百分号 dsp_putchar(&#x27;%&#x27;); break; default: // 未知格式 dsp_putchar(&#x27;%&#x27;); dsp_putchar(*format); &#125; &#125; else &#123; // 普通字符直接输出 dsp_putchar(*format); &#125; format++; &#125; va_end(args);&#125; 格式化数据测试用例：用dsp_printf生成sin(x), cos(x), sin(x)*cos(x), cos(x)*cos(x)波形，%f表示浮点数、%d表示整形数据，%s表示字符串 123456789101112131415161718192021222324252627282930313233// 打印表头dsp_printf(&quot;Angle,Sin(x),Cos(x),Sin(x)*Cos(x),Cos(x)*Cos(x)\\r &quot;);// 生成三角函数数据float angle = 0.0f; // 角度(度)float angleRad; // 角度(弧度)float sinVal, cosVal; // sin(x)和cos(x)值float sinCosVal, cosSquareVal; // sin(x)*cos(x)和cos(x)*cos(x)值for(;;) &#123; // 每15度输出一次数据 while(angle &lt;= 360.0f) &#123; // 转换为弧度 angleRad = angle * 0.01745329f; // 0.01745329 = π/180 // 计算三角函数值 sinVal = sin(angleRad); cosVal = cos(angleRad); sinCosVal = sinVal * cosVal; cosSquareVal = cosVal * cosVal; // 使用指定格式输出数据：&quot;%f,%f,%f,%f &quot; dsp_printf(&quot;%f,%f,%f,%f\\r &quot;, sinVal, cosVal, sinCosVal, cosSquareVal); // 角度增加15度 angle += 15.0f; // 延时，避免输出太快 DEVICE_DELAY_US(10000); // 延时100ms &#125; angle = 0;&#125; 数据可视化使用vofa+工具显示FireWater的自定义格式的串口数据流 总结自定义dsp_printf更加高效，更加自由，依赖体积更小，无需关心stack大小限制","tags":["DSP","LAUNCHXL-F28379D","printf"],"categories":["程序设计"]},{"title":"Linux系统CAN通信开发指南","path":"//linux-can-usage.html","content":"介绍Linux自带socket CAN驱动，可以使用VCAN功能来模拟CAN数据的收发，这个在原型开发阶段非常有用，拿一台笔记本直接调试CAN设备 使用虚拟CAN加载vcan.ko，这个驱动是操作系统自带的，位置参考：&#x2F;usr&#x2F;lib&#x2F;modules&#x2F;5.15.0-131-generic&#x2F;kernel&#x2F;drivers&#x2F;net&#x2F;can 1sudo modprobe vcan 如果你的Linux操作系统没有vcan驱动，请下载kernel编译一个，VCAN驱动模块配置如下： 添加vcan设备：vcan0 12sudo ip link add dev vcan0 type vcansudo ip link set up vcan0 vcan卡连接、关闭 12ifconfig vcan0 upifconfig vcan0 down 发送随机数据用于开发、调试、测试 12345# 用cansend发送8个字节数据格式while true; do cansend vcan0 123#1122334455667788; sleep 1; done;# 发送随机数while true; do cansend vcan0 $(printf &quot;%X#%02X%02X%02X%02X%02X%02X%02X%02X&quot; $((RANDOM%0x800)) $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256))); sleep 1; done; 接收数据 1candump vcan0 can数据发送和接收情况统计 1ip -details -statistics link show vcan0 数据分析：可以用wireshark工具抓取can帧 真实CAN真实的CAN需要MCU端有CAN接口（内部集成，引脚有RXD、TXD）、匹配的CAN收发器（CANH、CANL）、与之匹配的终端电阻（高速CAN为120Ω），常见的CAN收发器有： TJA1043 MCP2515 &#x2F; MCP2551 SN65HVD230 启用can设备：使用前先设置波特率，高速CAN为500k 12sudo ip link set can0 type can bitrate 500000sudo ip link set up can0 本地测试直接设置数据回环模式，如果不需要记得关掉，否则数据出不去也进不来！ 1234# 开启本地回环模式sudo ip link set can0 type can loopback on# 关闭本地回环模式sudo ip link set can0 type can loopback off 编码Linux C++实现CAN数据收发、状态检测、独立线程处理 can_bus_interface.hCanWorker负责处理socket CAN连接状态和数据的收发，CanBusInterface则作为一个单例管理CAN通信（开辟线程） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#ifndef CANBUSINTERFACE_H#define CANBUSINTERFACE_H#include &lt;QObject&gt;#include &lt;QSocketNotifier&gt;#include &lt;QThread&gt;#include &lt;QDebug&gt;#include &lt;linux/can.h&gt;#include &lt;string&gt;class CanWorker : public QObject&#123; Q_OBJECTpublic: explicit CanWorker(int socket, QObject *parent = nullptr); ~CanWorker();signals: void frameReceived(const struct can_frame &amp;frame); void errorOccurred(const QString &amp;errorString);private slots: void onSocketActivated(int socket);private: int m_socket; QSocketNotifier *m_notifier;&#125;;class CanBusInterface : public QObject&#123; Q_OBJECTpublic: static CanBusInterface *getInstance();protected: explicit CanBusInterface(QObject *parent = nullptr); ~CanBusInterface();public: bool open(const std::string &amp;interfaceName); void close(); bool isOpen() const; bool sendFrame(const struct can_frame &amp;frame);signals: void frameReceived(const struct can_frame &amp;frame); void errorOccurred(const QString &amp;errorString);private: int m_socket; bool m_isOpen; QThread *m_workerThread; CanWorker *m_worker;&#125;;#endif // CANBUSINTERFACE_H can_bus_interface.cppCanWorker和CanBusInterface的实现部分，socketCAN的配置：socket(PF_CAN, SOCK_RAW, CAN_RAW) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include &quot;can_bus_interface.h&quot;#include &lt;QDebug&gt;#include &lt;QSocketNotifier&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;net/if.h&gt;#include &lt;unistd.h&gt;// CanWorker 实现CanWorker::CanWorker(int socket, QObject *parent) : QObject(parent), m_socket(socket), m_notifier(nullptr)&#123; // 创建socket通知器 m_notifier = new QSocketNotifier(m_socket, QSocketNotifier::Read, this); connect(m_notifier, &amp;QSocketNotifier::activated, this, &amp;CanWorker::onSocketActivated); qRegisterMetaType&lt;can_frame&gt;(&quot;can_frame&quot;);&#125;CanWorker::~CanWorker()&#123; if (m_notifier) &#123; m_notifier-&gt;setEnabled(false); delete m_notifier; &#125;&#125;void CanWorker::onSocketActivated(int socket)&#123; Q_UNUSED(socket); struct can_frame frame; int bytesRead = read(m_socket, &amp;frame, sizeof(frame)); if (bytesRead == sizeof(frame)) &#123; emit frameReceived(frame); &#125; else if (bytesRead &lt; 0) &#123; emit errorOccurred(&quot;Failed to read CAN frame&quot;); &#125;&#125;// CanBusInterface 实现CanBusInterface *CanBusInterface::getInstance()&#123; static CanBusInterface instance; return &amp;instance;&#125;CanBusInterface::CanBusInterface(QObject *parent) : QObject(parent), m_socket(-1), m_isOpen(false), m_workerThread(nullptr), m_worker(nullptr)&#123;&#125;CanBusInterface::~CanBusInterface()&#123; close();&#125;bool CanBusInterface::open(const std::string &amp;interfaceName)&#123; if (m_isOpen) &#123; qWarning() &lt;&lt; &quot;CAN interface is already open&quot;; return true; &#125; // 创建socket m_socket = socket(PF_CAN, SOCK_RAW, CAN_RAW); if (m_socket &lt; 0) &#123; emit errorOccurred(&quot;Failed to create socket&quot;); return false; &#125; // 获取接口索引 struct ifreq ifr; strncpy(ifr.ifr_name, interfaceName.c_str(), IFNAMSIZ - 1); ifr.ifr_name[IFNAMSIZ - 1] = &#x27;\\0&#x27;; if (ioctl(m_socket, SIOCGIFINDEX, &amp;ifr) &lt; 0) &#123; emit errorOccurred(&quot;Failed to get interface index&quot;); ::close(m_socket); m_socket = -1; return false; &#125; // 绑定socket到CAN接口 struct sockaddr_can addr; addr.can_family = AF_CAN; addr.can_ifindex = ifr.ifr_ifindex; if (bind(m_socket, (struct sockaddr *)&amp;addr, sizeof(addr)) &lt; 0) &#123; emit errorOccurred(&quot;Failed to bind socket to interface&quot;); ::close(m_socket); m_socket = -1; return false; &#125; // 创建并启动工作线程 m_workerThread = new QThread(); m_worker = new CanWorker(m_socket); m_worker-&gt;moveToThread(m_workerThread); // 连接信号槽 connect(m_workerThread, &amp;QThread::finished, m_worker, &amp;CanWorker::deleteLater); connect(m_workerThread, &amp;QThread::finished, m_workerThread, &amp;QThread::deleteLater); connect(m_worker, &amp;CanWorker::frameReceived, this, &amp;CanBusInterface::frameReceived); connect(m_worker, &amp;CanWorker::errorOccurred, this, &amp;CanBusInterface::errorOccurred); m_workerThread-&gt;start(); m_isOpen = true; return true;&#125;void CanBusInterface::close()&#123; if (!m_isOpen) return; m_isOpen = false; if (m_workerThread) &#123; m_workerThread-&gt;quit(); m_workerThread-&gt;wait(); m_workerThread = nullptr; m_worker = nullptr; &#125; if (m_socket &gt;= 0) &#123; ::close(m_socket); m_socket = -1; &#125;&#125;bool CanBusInterface::isOpen() const&#123; return m_isOpen;&#125;bool CanBusInterface::sendFrame(const struct can_frame &amp;frame)&#123; if (!m_isOpen) &#123; emit errorOccurred(&quot;CAN interface is not open&quot;); return false; &#125; int bytesWritten = write(m_socket, &amp;frame, sizeof(frame)); if (bytesWritten != sizeof(frame)) &#123; emit errorOccurred(&quot;Failed to write CAN frame&quot;); return false; &#125; return true;&#125; 注意点1：这里需要把can_frame类型注册为Qt能够识别的元数据类型 1qRegisterMetaType&lt;can_frame&gt;(&quot;can_frame&quot;); 注意点2：只有独立的QObject才能使用moveToThread 12345m_workerThread = new QThread();m_worker = new CanWorker(m_socket);m_worker-&gt;moveToThread(m_workerThread);m_workerThread-&gt;start();","tags":["linux","CAN"],"categories":["程序设计"]},{"title":"QtCreator16.0.1设计页面无法打开","path":"//qtcreator-designer-page-problem.html","content":"介绍刚刚安装好的Qt6.8.3，打开Qt Creator 16.0.1发现无法使用设计UI或者QML文件的功能，左侧栏的按钮完全是置灰不可用的状态 解决点击菜单栏 -&gt; 帮助 -&gt; 关于插件，搜索Qt Quick，勾选Qt Quick Designer重启即可，但看样子后面是不太会支持下去了 设计功能重新正常使用：QML编辑和预览","tags":["QtCreator","Qt6"],"categories":["程序设计"]},{"title":"一个简单的QML工程参考示例","path":"//simple-qml-project.html","content":"介绍在RK3588触摸屏上使用QML开发手持设备应用 CMakeQML工程需要包含C、C++、QML、QRC、UI等文件，参考配置如下 1234567891011121314151617181920212223242526272829303132333435363738394041cmake_minimum_required(VERSION 3.5)project(demo LANGUAGES CXX)set(CMAKE_INCLUDE_CURRENT_DIR ON)set(CMAKE_AUTOUIC ON)set(CMAKE_AUTOMOC ON)set(CMAKE_AUTORCC ON)set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED ON)find_package(Qt5 COMPONENTS Core Quick REQUIRED)include_directories($&#123;CMAKE_SOURCE_DIR&#125;)set(SRC_DIR $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;)file(GLOB_RECURSE SRC &quot;$&#123;SRC_DIR&#125;/*.cpp&quot; &quot;$&#123;SRC_DIR&#125;/*.cxx&quot; &quot;$&#123;SRC_DIR&#125;/*.cc&quot; &quot;$&#123;SRC_DIR&#125;/*.c&quot;)file(GLOB_RECURSE HEADERS &quot;$&#123;SRC_DIR&#125;/*.h&quot; &quot;$&#123;SRC_DIR&#125;/*.hpp&quot; &quot;$&#123;SRC_DIR&#125;/*.hxx&quot;)file(GLOB_RECURSE RES &quot;$&#123;SRC_DIR&#125;/*.ui&quot; &quot;$&#123;SRC_DIR&#125;/*.qrc&quot;)add_executable($&#123;PROJECT_NAME&#125; $&#123;SRC&#125; $&#123;HEADERS&#125; $&#123;RES&#125;)target_compile_definitions($&#123;PROJECT_NAME&#125; PRIVATE $&lt;$&lt;OR:$&lt;CONFIG:Debug&gt;,$&lt;CONFIG:RelWithDebInfo&gt;&gt;:QT_QML_DEBUG&gt;)target_link_libraries($&#123;PROJECT_NAME&#125; PRIVATE Qt5::Core Qt5::Quick) 代码main.cpp，与普通的Qt5应用不同的是：运行的主体变成了main.QML，cpp文件只是提供了一个应用入口，通常的做法也是将QML放到qrc里边来提高运行效率 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;QGuiApplication&gt;#include &lt;QQmlApplicationEngine&gt;#include &lt;QQuickWindow&gt;#include &lt;QQmlContext&gt;class MainViewObject : public QObject &#123; Q_OBJECT Q_PROPERTY(QString text READ getText WRITE setText NOTIFY textChanged)public: explicit MainViewObject(QObject *parent = nullptr) : QObject(parent) &#123; &#125; ~MainViewObject() &#123; &#125;protected: QString getText() &#123; return m_text; &#125; void setText(const QString &amp;text) &#123; m_text = text; &#125;signals: void textChanged();private: QString m_text = &quot;hello world&quot;;&#125;;int main(int argc, char *argv[]) &#123; QGuiApplication app(argc, argv); QQmlApplicationEngine engine; MainViewObject main; engine.rootContext()-&gt;setContextProperty(&quot;mainObject&quot;, &amp;main); engine.load(QUrl(QStringLiteral(&quot;qrc:/QML/MainView.QML&quot;))); QObject *rootObject = engine.rootObjects().first(); QQuickWindow *window = qobject_cast&lt;QQuickWindow*&gt;(rootObject); if (window) &#123; window-&gt;show(); &#125; return app.exec();&#125;#include &quot;main.moc&quot; MainView.qml，类js脚本文件，可以看到跟C++编译定义式不一样的是：QML这里很多对象或控件（Window、Label、Image、Rectangle、Row、Timer）都变成了声明式，根据对象的属性直接配置就好，对象之间的联动可以通过信号和槽来实现 1234567891011121314151617181920212223242526import QtQuick 2.12import QtQuick.Controls 2.12import QtQuick.Window 2.12Window &#123; id: mainWindow width: 1280 height: 720 visible: true flags: Qt.Window | Qt.FramelessWindowHint color: &quot;white&quot; Label &#123; id: textLabel font &#123; pixelSize: 36 &#125; text: mainObject.text color: &quot;black&quot; anchors.centerIn: parent width: parent.width * 0.8 horizontalAlignment: Text.AlignHCenter verticalAlignment: Text.AlignVCenter &#125;&#125; 对象交互属性访问C++ -&gt; QML：通过context property传递或者qmlRegisterType方式 第一种方式，C++端注册mainObject对象，可以在QML直接使用C++对象属性 1234QQmlApplicationEngine engine;MainViewObject main;engine.rootContext()-&gt;setContextProperty(&quot;mainObject&quot;, &amp;main);engine.load(QUrl(QStringLiteral(&quot;qrc:/QML/MainView.QML&quot;))); 比如想要在Label对象里边使用mainObject对象的属性，都不需要有显式的import声明 123Label &#123;\ttext: mainObject.text&#125; 另一种方式是，注册QML对象的方式，这种方式可以提供成员函数调用 1234567891011121314151617181920class QmlObject : public QObject &#123; Q_OBJECTpublic: explicit QmlObject(QObject *parent = nullptr) : QObject(parent) &#123; &#125; ~QmlObject() &#123; &#125; Q_INVOKABLE QString getName() &#123; return m_text; &#125;private: QString m_text = &quot;hello world&quot;;&#125;;qmlRegisterType&lt;QmlObject&gt;(&quot;QmlObject&quot;, 1, 0, &quot;QmlObject&quot;); QML对象可以通过上面的对象名称访问成员函数或者属性，不过跟前一种不同的是，这里需要显式调用import 123456789101112131415import QmlObject 1.0Window &#123; id: mainWindow width: 1280 height: 720 visible: true flags: Qt.Window | Qt.FramelessWindowHint color: &quot;white&quot; property int demo: 1314 Component.onCompleted: &#123; console.log(&quot;name : &quot;, QmlObject.getName()) &#125;&#125; QML -&gt; C++ 可以在QML侧定义property或者指定对象的objectName 12345678910111213import QtQuick 2.12import QtQuick.Controls 2.12import QtQuick.Window 2.12Window &#123; property int demo: 1314 Label &#123; id: customLabel text: mainObject.text objectName: &quot;myLabel&quot; &#125;&#125; C++侧访问QML对象属性和子对象 12345QObject *rootObject = engine.rootObjects().first();qDebug() &lt;&lt; &quot;demo : &quot; &lt;&lt; rootObject-&gt;property(&quot;demo&quot;).toInt();auto label = rootObject-&gt;findChild&lt;QObject *&gt;(&quot;myLabel&quot;);label-&gt;setProperty(&quot;text&quot;, &quot;nice to meet you!&quot;); 信号和槽C++侧定义updateText信号 1234567891011121314151617181920212223242526272829303132// 对象定义class MainViewObject : public QObject &#123; Q_OBJECT Q_PROPERTY(QString text READ getText WRITE setText NOTIFY textChanged)public: explicit MainViewObject(QObject *parent = nullptr) : QObject(parent) &#123; &#125; ~MainViewObject() &#123; &#125;protected: QString getText() &#123; return m_text; &#125; void setText(const QString &amp;text) &#123; m_text = text; &#125;signals: void textChanged(); void updateText(const QString &amp;text);private: QString m_text = &quot;hello world&quot;;&#125;;// C++端发出信号emit main.updateText(&quot;hywing&quot;); QML侧捕获updateText信号，需要在Connections里边定义槽函数 12345678910111213141516171819Label &#123; id: textLabel objectName: &quot;myLabel&quot; font &#123; pixelSize: 36 &#125; Connections &#123; target: mainObject function onUpdateText(text) &#123; textLabel.text = text; console.log(text) &#125; &#125; Component.onCompleted: &#123; console.log(&quot;this is myLabel&quot;)\t&#125;&#125; 也可以这样给一个对象绑定一个匿名槽函数，textChanged这个信号必须在MainViewObject里边提供 123456Component.onCompleted: &#123; console.log(&quot;this is myLabel&quot;) mainObject.textChanged.connect( function() &#123; console.log(&quot;signal emitted!&quot;) &#125;)&#125; 调试QML的远程调试需要绑定端口号来使用，实际开发往往都是用console打log，就像web html那样；因此我觉得，它做界面就够了，不要把复杂的业务逻辑打包在脚本文件里边 总结 QML库的水太深，容易奔溃（有时候是编译不报错，运行时报错，有些版本库命名也没有统一），做QML开发需要关注不同Qt5版本的兼容性问题，目前用2.12在Qt5.12.9和Qt5.15.8运行都没有问题 封装继承不好实现，因为如果是简单的UI可以用QML尝试，复杂要继承的话还是走C++吧 业务逻辑也不推荐放QML端，一个脚本解析引擎的效率要打上问号","tags":["Qt5","QML","触摸屏","车载"],"categories":["嵌入式"]},{"title":"RK3588移植GPSD","path":"//rk3588-port-gpsd.html","content":"介绍在Ubuntu20.04上交叉编译gpsd-3.25，目标系统为rk3588 Linux，目标编译工具链为aarch64-buildroot-linux-gnu 移植rk3588编译工具链配置 1234source /opt/rk3588/rk3588-aarch64-buildroot-linux-gnu/environment-setupexport TOOLCHAIN_PATH=/opt/rk3588/rk3588-aarch64-buildroot-linux-gnuexport SYSROOT=$TOOLCHAIN_PATH/aarch64-buildroot-linux-gnu/sysrootexport PATH=$TOOLCHAIN_PATH/bin:$PATH GPSD使用scons工具构建，Ubuntu20.04上安装scons 1sudo apt install scons scons工具大致用法 123456# 清理scons -c# 编译（可带参数）scons # 安装scons install GPSD交叉编译配置 1scons target=aarch64-buildroot-linux-gnu sysroot=$SYSROOT prefix=$PWD/build gpsd_user=nobody gpsd_group=nogroup install_root=$PWD/build qt=no python=no dbus=no chrpath=no strip=yes ncurses=no 使用scons install命令安装到指定目录，然后部署到rk3588开发板上去（adb或者scp） 运行部署至开发板的&#x2F;userdata&#x2F;admin目录，实际上只要bin、sbin、lib三个目录就够了，然后配置环境变量 12export PATH=/userdata/admin/build/bin:/userdata/admin/build/sbin:$PATHexport LD_LIBRARY_PATH=/userdata/admin/build/lib:$LD_LIBRARY_PATH 找到GNSS的串口节点，可以用cat命令，我这里的节点是ttyS1 1cat /dev/ttyS1 生成配置文件：&#x2F;etc&#x2F;gpsd.conf 123456[gpsd]listen = &quot;0.0.0.0&quot;port = &quot;2947&quot;device = &quot;/dev/ttyS1&quot;speed = &quot;9600&quot;nowake = &quot;true&quot; 运行gpsd应用 1/userdata/admin/build/sbin/gpsd -n -G -F /etc/gpsd.conf 测试可以用gpsd命令打印当前的定位数据：gpsd -N -n -D5 &#x2F;dev&#x2F;ttyS1 进阶把gpsd做成一个自启动的service 123456789[Unit]Description=gpsd.service[Service]ExecStart=/usr/bin/bash /userdata/admin/autorun.sh#Restart=always[Install]WantedBy=sysinit.target","tags":["linux","rk3588","gpsd"],"categories":["嵌入式"]},{"title":"stm32f103rct6开发板无法调试问题","path":"//stm32f103rct6-board-cannot-debug.html","content":"介绍STM32CubeMX配置及生成工程，发现用Keil5编译、下载后居然无法在线调试！ 可以明确的是：编译和下载没有问题，但启动仿真之后就会报错 回头看ST-Link V2调试器已经掉了，直觉是这个板子已经变砖了…… 救砖Debug选项栏配置Connect方式为：under Reset 按住开发板RESET按键，点击Download按钮，程序又能正常烧录了，但还是依旧无法仿真的 但按住RESET键，发现ST-Link V2调试器是能重新识别的 分析ST-Link V2调试器应该没有问题，大概率是通信出了问题，比如：SWD的GPIO配置不对，仔细看SWDIO和SWCLK两个口的状态都是黄的，应该没有正常工作 解决点击System Core -&gt; SYS，配置Debug项为：Serial Wire，重新生成工程代码编译烧录即可解决问题 stm32f103rct6的SYS配置跟stm32g030c8t6的有点不大一样","tags":["debug","stm32","stm32f103rct6","swd"],"categories":["嵌入式"]},{"title":"汽车电子专业英语合集","path":"//automotive-electronics-english.html","content":"前言汽车电子领域专业英语词汇汇总，不定期更新 词汇芯片类 VCU：Vehicle Control Unit，整车控制器 ECU：Electronic Control Unit，电子控制单元 AUTOSAR：Automotive Open System ARchitecture，开放的汽车电子系统软件架构标准 Domain Controller：域控制器 Power Train Domain：动力域 Chassis Domain：底盘域 Body Domain：车身域 ADAS Domain：智能驾驶域 HMI Domain：智能座舱域 Automotive Domain：自动驾驶域 ADAS：Advanced Driver Assistance Systems，高阶辅助驾驶系统 车灯类 前照明灯：Front position lamp 后照明灯：Rear position lamp 左照明灯：Left-side marker lamp 右照明灯：Right-side marker lamp 驾驶室顶灯：Cab interior lamp 左转向灯：Left turn signal lamp 右转向灯：Right turn signal lamp 示廊灯：Clearance lamp 前近光灯：Low beam headlamp 前远光灯：High beam headlamp 前雾灯：Front fog lamp 信号报警灯：Warning signal lamp 旋转报警灯：Rotating beacon light 刹车灯：Stop lamp 后牌照灯：License plate lamp 喇叭：Horn 发动机类 发动机转速：engine speed 机油压力：engine oil pressure 水温：water temperature 负载率：load rate 机油温度：engine oil temperature 瞬时油耗：instantaneous fuel consumption 增压温度：boost temperature 发动机总油耗：total fuel consumption 发动机总时间：engine total hours 离合器滑差：clutch slip 传感器类 刹车踏板：brake pedal 油门踏板：accelerator pedal 履带涨紧压力：track tension pressure 吸回油压力发讯器：suction oil pressure sensor 发动机电子阻塞：Engine Electronic Limp Mode 转向角度传感器：Steering Angle Sensor 驾驶室暖风：Cab Heater 发动机循环水加热：Engine Coolant Heating 故障 可疑参数编号：suspect parameter number，SPN 故障模式标识：failure mode identifier，FMI 故障发生次数：occurence count，OC","tags":["专业英语","汽车电子"],"categories":["学科"]},{"title":"对QDialog的一点思考","path":"//qdialog-usage.html","content":"总结以下经验来自嵌入式触摸屏调试 show和exec两个函数的样式不一致，特别是show的样式容易被父控件污染，模态属性下样式比较独立 尽量避免使用static成员变量，如果你想使用把QDialog对象当作局部变量来使用 和输入法有冲突，需要改变窗体属性来唤起输入法界面 巧用reject和accept，什么都不知道就close","tags":["Qt","QDialog"],"categories":["程序设计"]},{"title":"Qt EGLFS按钮边框残影问题","path":"//qt-eglfs-button-frame-shadow.html","content":"介绍嵌入式Qt EGLFS由于没有窗口系统，很多控件的样式或者行为都跟PC、甚至是嵌入式的wayland-egl、linuxfb不大一样，比如QPushButton聚焦的时候它会带一个虚线框，而其它平台是不会的，qtvirtualkeyboard输入法插件也用起来怪怪的…… 解决统一控件的默认样式即可，比如Fusion，Fusion 是 Qt 提供的一个跨平台 widget 样式，它不依赖于任何特定操作系统的原生外观，而是提供了一套 Qt 自绘的统一界面风格 1qputenv(&quot;QT_STYLE_OVERRIDE&quot;, &quot;Fusion&quot;); 另外触摸屏上的QPushButton尽量用pressed属性，不论是样式表还是信号绑定，clicked有时候会没有反应！（点击了按钮明明样式变了，就是不会触发槽函数，不知道是不是EGLFS的问题）","tags":["Qt","宏定义"],"categories":["嵌入式"]},{"title":"跨平台宏定义","path":"//crossplatform-macros.html","content":"介绍由于业务的需要，经常在不同的操作系统平台编写代码，各个系统平台（编译器）下的接口总有差异，越往底层走差异越大，比如摄像头，在Windows下它可以是一个通用的camera，但是在Linux下你得写V4L2视频采集的驱动。怎么办，你只能用一些条件编译的方法把不同操作系统的个性化处理隔离开，这就需要使用跨平台的宏定义了 编译器相关__aarch64__ ：特指aarch64编译器，如RK3588、XILINX ZU3EG平台 __linux__ ：Linux操作系统，arm或者x64均适用 _WIN64：编写x64应用时的宏定义，表示是64位的MSVC编译器 _WIN32：编写x32应用时的宏定义，表示是32位的MSVC编译器 WIN32：这个是Windows平台的gcc内置的宏定义 QT相关Q_OS_WIN：表示当前系统为Windows Q_OS_WIN32：表示当前开发程序为win32应用 Q_OS_WIN64：表示当前开发程序为win64应用 Q_OS_WINDOWS：表示当前系统为Windows Q_OS_LINUX：表示当前系统为Linux，这个宏好像没有什么用，识别不了Ubuntu20.04系统 Q_OS_MAC：表示当前系统为mac Q_OS_FREEBSD：表示当前系统为FreeBSD Q_OS_ANDROID：表示当前系统为Android 参考 gcc查看编译器内置宏定义：gcc -dM -E - &lt;&#x2F;dev&#x2F;null qt内置宏定义","tags":["跨平台","宏定义"],"categories":["程序设计"]},{"title":"Linux环境下使用ADB命令做嵌入式开发","path":"//adb-command-usage.html","content":"介绍adb一般是给Android开发用的，但是换个思路也能做嵌入式Linux开发 安装以Ubuntu20.04为例 1sudo apt install android-tools-adb android-tools-fastboot 安装成功可以查看adb版本号 命令查看adb设备 登录shell 上传文件到设备指定目录 拉取设备上的文件到本地指定目录 端口转发：转发22端口用于QtCreator远程调试 然后配置Devices参数，记得多转发几个端口：10000-10005，Host name处填写localhost 移除所有ADB端口转发 进阶利用udev机制在ADB驱动装载之后执行自定义脚本：sudo vim /etc/udev/rules.d/99-adb-forward.rules 123ACTION==&quot;add&quot;, SUBSYSTEM==&quot;usb&quot;, ENV&#123;PRODUCT&#125;==&quot;2717/ff08/*&quot;, \\ RUN+=&quot;/bin/bash -c &#x27;echo UDEV_CALLED &gt;&gt; /tmp/udev_test.log &amp;&amp; \\ /bin/su asensing -c \\&quot;/usr/local/bin/adb_forward.sh\\&quot;&#x27;&quot; 其中，ENV&#123;PRODUCT&#125;参数可以通过sudo udevadm monitor --property命令查看到 adb_forward.sh脚本写法参考 1234567891011121314151617181920212223242526272829303132333435363738#!/bin/bashexport PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binLOG_FILE=&quot;/tmp/adb_forward.log&quot;exec &gt;&gt; &quot;$LOG_FILE&quot; 2&gt;&amp;1echo &quot;=== $(date) ===&quot;echo &quot;UDEV ENV:&quot;printenv | grep -E &#x27;ACTION|DEVPATH|PRODUCT|INTERFACE&#x27; &gt;&gt; &quot;$LOG_FILE&quot;# 等待设备初始化sleep 3# 检测adb命令ADB_CMD=$(which adb)if [ -z &quot;$ADB_CMD&quot; ]; then echo &quot;ERROR: adb not found!&quot; &gt;&gt; &quot;$LOG_FILE&quot; exit 1fi# 启动adb服务echo &quot;Starting ADB server...&quot;$ADB_CMD start-server# 等待设备就绪# 执行端口转发echo &quot;Executing: adb forward tcp:8022 tcp:22&quot; &gt;&gt; &quot;$LOG_FILE&quot;$ADB_CMD forward tcp:8022 tcp:22if [ $? -eq 0 ]; then echo &quot;SUCCESS: Port forwarding established&quot; &gt;&gt; &quot;$LOG_FILE&quot;else echo &quot;ERROR: Port forwarding failed&quot; &gt;&gt; &quot;$LOG_FILE&quot; $ADB_CMD devices -l &gt;&gt; &quot;$LOG_FILE&quot; exit 3fi 这样你的Linux设备一旦连接到虚拟机，Ubuntu就可以默认开启adb端口转发了 日志监控 12touch /tmp/adb_forward.logtail -f /tmp/adb_forward.log 总结生命在于折腾！没有网口的情形下可以用ADB转发模拟网络通信，这样gdbserver、ssh、smb、nfs、tftp等网络服务就可以使用了","tags":["linux","adb"],"categories":["嵌入式"]},{"title":"ch32v307vct6样片申请","path":"//ch32v307vct6-sample-request.html","content":"沁恒微电子官网的介绍 南京沁恒微电子股份有限公司专注于连接技术和微处理器内核研究，是一家基于自研专业接口IP、微处理器内核IP构建芯片的集成电路设计企业。公司致力于为客户提供万物互联、上下互通的芯片及解决方案，主要产品包括USB&#x2F;蓝牙&#x2F;以太网接口芯片和连接型&#x2F;互联型&#x2F;无线型MCU，产品侧重于连接、联网和控制 CH32V307 CH32V305&#x2F;7系列是基于32位RISC-V设计的互联型微控制器，配备了硬件堆栈区、快速中断入口，在标准RISC-V基础上大大提高了中断响应速度。加入单精度浮点指令集，扩充堆栈区，具有更高的运算性能。扩展串口UART数量到8组，电机定时器到4组。提供USB2.0高速接口（480Mbps）并内置了PHY收发器，以太网MAC升级到千兆并集成了10M-PHY模块 申请流程打开沁恒微电子官网 点击服务支持，选择样品索取 填写相关信息 不久就会有技术支持人员过来电话联系你，加微信，告知快递信息，隔个两三天快递就会送到 官方给的资料包里边有各种各样的外设demo（支持各式各样的国产RTOS）、原理图、芯片datasheet，还超级nice的提供了PCB工程！ 快递开箱美照 沁恒还非常贴心的多给了两块芯片 万物基于点灯，第一时间点灯，必须的！ 感慨自中美贸易战打响以来，国内的mcu芯片产业如同以后春笋一般蓬勃发展，对于嵌入式工程师来说是一件非常值得高兴的事情！毕竟选择多了很多，不再让别人卡脖子，RISC-V这种开源指令集最有可能让我们实现弯道超车，希望国人不要放弃机会！","tags":["沁恒","样片","ch32v307vct6"],"categories":["嵌入式"]},{"title":"自定义数据类型支持qDebug输出","path":"//qdebug-custom-data.html","content":"前言写Qt程序的时候，发现自定义数据数据对象就不能用qDebug直接输出了，每次都要写一大串的字符参数列表来打印log，有没有什么办法可以直接打印对象呢？很简单，写个友元函数就OK了 实现以结构体类型为例，需要实现&lt;&lt;运算符重载 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct Point&#123; float x; float y; float z; int id; int intensity; int imageX; int imageY; Point() &#123; this-&gt;x = qQNaN(); this-&gt;y = qQNaN(); this-&gt;z = qQNaN(); this-&gt;id = qQNaN(); this-&gt;intensity = qQNaN(); this-&gt;imageX = qQNaN(); this-&gt;imageY = qQNaN(); &#125; Point(const Point &amp;point) &#123; this-&gt;x = point.x; this-&gt;y = point.y; this-&gt;z = point.z; this-&gt;id = point.id; this-&gt;intensity = point.intensity; this-&gt;imageX = point.imageX; this-&gt;imageY = point.imageY; &#125; Point &amp;operator =(const Point &amp;point) &#123; this-&gt;x = point.x; this-&gt;y = point.y; this-&gt;z = point.z; this-&gt;id = point.id; this-&gt;intensity = point.intensity; this-&gt;imageX = point.imageX; this-&gt;imageY = point.imageY; return *this; &#125; friend QDebug operator&lt;&lt;(QDebug dbg, const Point &amp;point) &#123; dbg &lt;&lt; point.id &lt;&lt; &quot; : (&quot; &lt;&lt; point.x &lt;&lt; &quot;,&quot; &lt;&lt; point.y &lt;&lt; &quot;,&quot; &lt;&lt; point.z &lt;&lt; &quot;)&quot; &lt;&lt; &quot; intensity : &quot; &lt;&lt; point.intensity; return dbg; &#125;&#125;; 然后自定义的数据可以直接用qDebug打印了 1qDebug() &lt;&lt; Point();","tags":["Qt","qDebug"],"categories":["程序设计"]},{"title":"github无法提交代码问题","path":"//github-cannot-push.html","content":"问题描述提交代码到个人仓库的时候发现报错，认证失败 12345Username for &#x27;https://github.com&#x27;: hywingPassword for &#x27;https://hywing@github.com&#x27;: remote: Support for password authentication was removed on August 13, 2021.remote: Please see https://docs.github.com/en/get-started/getting-started-with-git/about-remote-repositories#cloning-with-https-urls for information on currently recommended modes of authentication.fatal: Authentication failed for &#x27;https://github.com/hywing/rt-thread.git/&#x27; 解决办法在GitHub页面点击右上角个人logo，选择Settings进入Settings页面 在Settings页面拉到最下方点击Developer Settings 在Developer Settings页面依次点击Personal access tokens，Token (classic)，Generate new token，Generate new token (classic) 填写口令信息，点击Generate token，点击你所需要的访问权限，然后拷贝口令 然后你需要通用的url格式来验证你对远程仓库的控制权限 1https://刚刚拷贝的口令@github.com/你的用户名/你的仓库名称.git 将生成的口令拷贝，作为 git clone仓库的前缀，我的口令是随意填写的，这里要填你自己的token口令 1git clone https://aaa_bbbKoJyB0oJbuQYjJOILugksoT9VB93TTTTT@github.com/hywing/rt-thread.git 如果已有仓库可以通过set url的方式更新token 1git remote set-url origin https://aaa_bbbKoJyB0oJbuQYjJOILugksoT9VB93TTTTT@github.com/hywing/rt-thread.git 这样，你就可以顺利对远程仓库进行操作了","tags":["GitHub"],"categories":["开发工具"]},{"title":"Qt在子控件上绘图","path":"//qt-subcontrol-painting.html","content":"前言有时候，我们并不想派生一个类（可能是因为懒，毕竟要写cpp和h文件，还要重写它的paintEvent虚函数），可是父控件的paintEvent并不是你想用就能用的，因为它只属于父控件；那有没有一种办法，可以在父控件的类里边实现子控件的绘图呢？ 介绍我们需要对Qt的事件机制比较熟悉，比如paintEvent，它本质是一个QEvent::paint的事件；如果在事件队列里边拦截了QEvent::paint，再进行QPainter绘图，这个和paintEvent是一样的效果！ 举例这里的ui-&gt;dashboard1是一个QLabel，我们打算侦听它的事件 1ui-&gt;dashboard1-&gt;installEventFilter(this); 重写父控件的eventFilter事件，侦听QEvent::Paint事件 1234567bool MainWidget::eventFilter(QObject *obj, QEvent *evt)&#123; if(obj == ui-&gt;dashboard1 &amp;&amp; evt-&gt;type() == QEvent::Paint) &#123; this-&gt;drawArc(ui-&gt;dashboard1); &#125; return QFrame::eventFilter(obj, evt);&#125; 子控件绘图：这里可以加入自定义的效果 123456789void MainWidget::drawArc(QWidget *widget)&#123; QPainter painter(widget); painter.setRenderHint(QPainter::Antialiasing, true); QPointF center(204, 204); painter.setPen(Qt::NoPen); painter.setBrush(Qt::red); painter.drawEllipse(center, 3, 3);&#125;","tags":["Qt","绘图"],"categories":["程序设计"]},{"title":"FRDM-MCXW71开发指南","path":"//frdm-mcxw71-tutorial.html","content":"前言我从NXP官网申请了FRDM-MCXW71开发板，这个是专门为无线连接设计的MCU方案 介绍MCXW71是NXP推出的一款低功耗、高安全系数、面向无线连接的MCU，它的最大主频有96MHz，内核为Cortex-M33，片上集成1MB flash和128KB SRAM；FRDM-MCXW71是一款紧凑且可扩展的开发板，可让您快速基于MCX W71无线MCU开展原型设计。它可以轻松地评估MCX W71对BLE、Zigbee、Thread和Matter的多协议无线支持。该板包括一个板载MCU-Link调试器、便于访问MCU I&#x2F;O的行业标准头、一个加速度传感器、一个光传感器和一个外接SPI闪存。 开发环境 安装VSCode，我这里安装的版本是1.96.4 打开VSCode Extensions，安装MCUPRESSO插件 安装Cortex-Debug插件 安装CMake插件 另外PC也要安装CMake 下载一个Ninja arm-gcc-toolchain，我这里安装的是10.2021.10版本 NXP SDK Repository导入，这个要从GitHub上面拉取，拉取时间比较长 安装LinkServer工具 我安装的是1.6.133版本，VSCode自动能够识别 下载sdk包：SDK_2_16_100_FRDM-MCXW71.zip，在MCUXPRESSO VSCode面板导入 搭建demo工程 编译hello_world工程失败 1d:/software/arm-gc~1/102021~1.10/bin/../lib/gcc/arm-none-eabi/10.3.1/../../../../arm-none-eabi/bin/ld.exe: cannot find -lcr_newlib_nohost 需要把armgcc\\debug\\build.ninja文件的部分代码注释掉 1-lcr_newlib_nohost 然后按F5进入调试模式，这样就可以进行开发板的开发工作了 RT-Thread工程Dist包请用RT-Thread Env工具导出支持cmake的dist包 1scons --dist dist工程示例：所有RT-Thread源码被打包至rt-thread目录，并且被CMakeList.txt索引 VSCode配置以下配置文件用于激活VSCode MCUPRESSO工程 .vscode\\c_cpp_properties.json 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#123; &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;rt-thread&quot;, &quot;defines&quot;: [ &quot;CPU_MCXW716CMFPA&quot;, &quot;DEBUG&quot;, &quot;RT_USING_LIBC&quot;, &quot;RT_USING_NEWLIBC&quot;, &quot;_POSIX_C_SOURCE=1&quot;, &quot;_REENT_SMALL&quot;, &quot;__RTTHREAD__&quot; ], &quot;intelliSenseMode&quot;: &quot;gcc-arm&quot;, &quot;compilerPath&quot;: &quot;C:/env-windows/tools/gnu_gcc/arm_gcc/mingw/bin/arm-none-eabi-gcc&quot;, &quot;cStandard&quot;: &quot;c99&quot;, &quot;cppStandard&quot;: &quot;c++11&quot;, &quot;compileCommands&quot;: [ &quot;build/compile_commands.json&quot; ], &quot;includePath&quot;: [ &quot;applications&quot;, &quot;rt-thread\\\\components\\\\libc\\\\compilers\\\\common\\\\include&quot;, &quot;rt-thread\\\\components\\\\libc\\\\compilers\\ ewlib&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\include&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\phy&quot;, &quot;board&quot;, &quot;board\\\\MCUX_Config\\\\board&quot;, &quot;Libraries\\\\drivers&quot;, &quot;Libraries\\\\drivers\\\\config&quot;, &quot;rt-thread\\\\components\\\\finsh&quot;, &quot;.&quot;, &quot;rt-thread\\\\include&quot;, &quot;rt-thread\\\\libcpu\\\\arm\\\\common&quot;, &quot;rt-thread\\\\libcpu\\\\arm\\\\cortex-m33&quot;, &quot;Libraries\\\\CMSIS\\\\Core\\\\Include&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\drivers&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\drivers\\\\romapi\\\\flash&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\drivers\\\\romapi\\\\mem_interface&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\drivers\\\\romapi\\ boot&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\drivers\\\\romapi\\\\runbootloader&quot;, &quot;rt-thread\\\\components\\\\libc\\\\posix\\\\io\\\\epoll&quot;, &quot;rt-thread\\\\components\\\\libc\\\\posix\\\\io\\\\eventfd&quot;, &quot;rt-thread\\\\components\\\\libc\\\\posix\\\\io\\\\poll&quot;, &quot;rt-thread\\\\components\\\\libc\\\\posix\\\\ipc&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\smp_call&quot;, &quot;rt-thread\\\\components\\\\utilities\\\\ulog&quot; ] &#125; ], &quot;version&quot;: 4&#125; .vscode\\launch.json 1234567891011121314151617181920212223242526&#123; &quot;configurations&quot;: [ &#123; &quot;type&quot;: &quot;mcuxpresso-debug&quot;, &quot;name&quot;: &quot;Debug project configuration&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;, &quot;executable&quot;: &quot;&quot;, &quot;stopAtSymbol&quot;: &quot;main&quot;, &quot;probeSerialNumber&quot;: &quot;2NL4XDTOIMBQA&quot;, &quot;isAttach&quot;: false, &quot;probeType&quot;: &quot;&quot;, &quot;skipBuildBeforeDebug&quot;: false, &quot;skipPreFlashActions&quot;: false, &quot;gdbInitCommands&quot;: [ &quot;set remotetimeout 600&quot;, &quot;set debug-file-directory&quot;, &quot;set non-stop off&quot; ], &quot;showDevDebugOutput&quot;: &quot;none&quot; &#125; ]&#125; .vscode\\mcuxpresso-tools.json 12345678910111213141516&#123; &quot;version&quot;: &quot;24.9&quot;, &quot;toolchainPath&quot;: &quot;d:/software/arm-gcc-toolchain/10 2021.10&quot;, &quot;linkedProjects&quot;: [], &quot;trustZoneType&quot;: &quot;none&quot;, &quot;multicoreType&quot;: &quot;none&quot;, &quot;debug&quot;: &#123; &quot;linkserver&quot;: &#123; &quot;device&quot;: &quot;MCXW716CxxxA:FRDM-MCXW71&quot;, &quot;core&quot;: &quot;primary&quot; &#125;, &quot;pemicro&quot;: &#123;&#125;, &quot;segger&quot;: &#123;&#125; &#125;, &quot;projectType&quot;: &quot;cmake-freestanding&quot;&#125; .vscode\\project.json 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146&#123; &quot;RT-Thread&quot;: &quot;D:\\\\project\\\\rt-thread&quot;, &quot;Groups&quot;: [ &#123; &quot;name&quot;: &quot;Applications&quot;, &quot;path&quot;: &quot;applications&quot;, &quot;files&quot;: [ &quot;applications\\\\main.c&quot;, &quot;applications\\\\SConscript&quot; ] &#125;, &#123; &quot;name&quot;: &quot;Compiler&quot;, &quot;path&quot;: &quot;rt-thread\\\\components\\\\libc\\\\compilers\\\\common&quot;, &quot;files&quot;: [ &quot;rt-thread\\\\components\\\\libc\\\\compilers\\\\common\\\\cctype.c&quot;, &quot;rt-thread\\\\components\\\\libc\\\\compilers\\\\common\\\\cstdlib.c&quot;, &quot;rt-thread\\\\components\\\\libc\\\\compilers\\\\common\\\\cstring.c&quot;, &quot;rt-thread\\\\components\\\\libc\\\\compilers\\\\common\\\\ctime.c&quot;, &quot;rt-thread\\\\components\\\\libc\\\\compilers\\\\common\\\\cunistd.c&quot;, &quot;rt-thread\\\\components\\\\libc\\\\compilers\\\\common\\\\cwchar.c&quot;, &quot;rt-thread\\\\components\\\\libc\\\\compilers\\ ewlib\\\\syscalls.c&quot;, &quot;rt-thread\\\\components\\\\libc\\\\compilers\\\\common\\\\SConscript&quot; ] &#125;, &#123; &quot;name&quot;: &quot;DeviceDrivers&quot;, &quot;path&quot;: &quot;rt-thread\\\\components\\\\drivers\\\\core&quot;, &quot;files&quot;: [ &quot;rt-thread\\\\components\\\\drivers\\\\core\\\\device.c&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\hwtimer\\\\hwtimer.c&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\ipc\\\\completion_comm.c&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\ipc\\\\completion_up.c&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\ipc\\\\condvar.c&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\ipc\\\\dataqueue.c&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\ipc\\\\pipe.c&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\ipc\\\\ringblk_buf.c&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\ipc\\\\ringbuffer.c&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\ipc\\\\waitqueue.c&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\ipc\\\\workqueue.c&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\pin\\\\dev_pin.c&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\serial\\\\dev_serial.c&quot;, &quot;rt-thread\\\\components\\\\drivers\\\\core\\\\SConscript&quot; ] &#125;, &#123; &quot;name&quot;: &quot;Drivers&quot;, &quot;path&quot;: &quot;board&quot;, &quot;files&quot;: [ &quot;board\\\\MCUX_Config\\\\board\\\\clock_config.c&quot;, &quot;board\\\\MCUX_Config\\\\board\\\\pin_mux.c&quot;, &quot;board\\\\board.c&quot;, &quot;Libraries\\\\drivers\\\\drv_pin.c&quot;, &quot;Libraries\\\\drivers\\\\drv_uart.c&quot;, &quot;board\\\\SConscript&quot; ] &#125;, &#123; &quot;name&quot;: &quot;Finsh&quot;, &quot;path&quot;: &quot;rt-thread\\\\components\\\\finsh&quot;, &quot;files&quot;: [ &quot;rt-thread\\\\components\\\\finsh\\\\msh_parse.c&quot;, &quot;rt-thread\\\\components\\\\finsh\\\\shell.c&quot;, &quot;rt-thread\\\\components\\\\finsh\\\\msh.c&quot;, &quot;rt-thread\\\\components\\\\finsh\\\\cmd.c&quot;, &quot;rt-thread\\\\components\\\\finsh\\\\SConscript&quot; ] &#125;, &#123; &quot;name&quot;: &quot;Kernel&quot;, &quot;path&quot;: &quot;.&quot;, &quot;files&quot;: [ &quot;rt-thread\\\\src\\\\clock.c&quot;, &quot;rt-thread\\\\src\\\\components.c&quot;, &quot;rt-thread\\\\src\\\\cpu_up.c&quot;, &quot;rt-thread\\\\src\\\\defunct.c&quot;, &quot;rt-thread\\\\src\\\\idle.c&quot;, &quot;rt-thread\\\\src\\\\ipc.c&quot;, &quot;rt-thread\\\\src\\\\irq.c&quot;, &quot;rt-thread\\\\src\\\\kservice.c&quot;, &quot;rt-thread\\\\src\\\\mem.c&quot;, &quot;rt-thread\\\\src\\\\mempool.c&quot;, &quot;rt-thread\\\\src\\\\object.c&quot;, &quot;rt-thread\\\\src\\\\scheduler_comm.c&quot;, &quot;rt-thread\\\\src\\\\scheduler_up.c&quot;, &quot;rt-thread\\\\src\\\\thread.c&quot;, &quot;rt-thread\\\\src\\\\timer.c&quot;, &quot;.\\\\SConscript&quot; ] &#125;, &#123; &quot;name&quot;: &quot;klibc&quot;, &quot;path&quot;: &quot;rt-thread\\\\src\\\\klibc&quot;, &quot;files&quot;: [ &quot;rt-thread\\\\src\\\\klibc\\\\rt_vsnprintf_tiny.c&quot;, &quot;rt-thread\\\\src\\\\klibc\\\\kerrno.c&quot;, &quot;rt-thread\\\\src\\\\klibc\\\\rt_vsscanf.c&quot;, &quot;rt-thread\\\\src\\\\klibc\\\\kstring.c&quot;, &quot;rt-thread\\\\src\\\\klibc\\\\kstdio.c&quot;, &quot;rt-thread\\\\src\\\\klibc\\\\SConscript&quot; ] &#125;, &#123; &quot;name&quot;: &quot;libcpu&quot;, &quot;path&quot;: &quot;rt-thread\\\\libcpu\\\\arm\\\\common&quot;, &quot;files&quot;: [ &quot;rt-thread\\\\libcpu\\\\arm\\\\common\\\\atomic_arm.c&quot;, &quot;rt-thread\\\\libcpu\\\\arm\\\\common\\\\div0.c&quot;, &quot;rt-thread\\\\libcpu\\\\arm\\\\common\\\\showmem.c&quot;, &quot;rt-thread\\\\libcpu\\\\arm\\\\cortex-m33\\\\context_gcc.S&quot;, &quot;rt-thread\\\\libcpu\\\\arm\\\\cortex-m33\\\\cpuport.c&quot;, &quot;rt-thread\\\\libcpu\\\\arm\\\\cortex-m33\\\\syscall_gcc.S&quot;, &quot;rt-thread\\\\libcpu\\\\arm\\\\cortex-m33\\\\trustzone.c&quot;, &quot;rt-thread\\\\libcpu\\\\arm\\\\common\\\\SConscript&quot; ] &#125;, &#123; &quot;name&quot;: &quot;Libraries&quot;, &quot;path&quot;: &quot;Libraries\\\\MCXW71&quot;, &quot;files&quot;: [ &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\drivers\\\\fsl_edma.c&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\drivers\\\\fsl_cmc.c&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\system_MCXW716C.c&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\drivers\\\\fsl_common_arm.c&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\drivers\\\\fsl_crc.c&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\drivers\\\\fsl_spc.c&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\drivers\\\\fsl_clock.c&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\drivers\\\\fsl_ccm32k.c&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\gcc\\\\startup_MCXW716C.S&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\drivers\\\\fsl_lpuart.c&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\drivers\\\\fsl_gpio.c&quot;, &quot;Libraries\\\\MCXW71\\\\MCXW71\\\\drivers\\\\fsl_common.c&quot;, &quot;Libraries\\\\MCXW71\\\\SConscript&quot; ] &#125;, &#123; &quot;name&quot;: &quot;Utilities&quot;, &quot;path&quot;: &quot;rt-thread\\\\components\\\\utilities\\\\ulog&quot;, &quot;files&quot;: [ &quot;rt-thread\\\\components\\\\utilities\\\\ulog\\\\backend\\\\console_be.c&quot;, &quot;rt-thread\\\\components\\\\utilities\\\\ulog\\\\ulog.c&quot;, &quot;rt-thread\\\\components\\\\utilities\\\\ulog\\\\SConscript&quot; ] &#125; ]&#125; .vscode\\settings.json 12345678&#123; &quot;cmake.configureOnOpen&quot;: false, &quot;C_Cpp.errorSquiggles&quot;: &quot;disabled&quot;, &quot;C_Cpp.default.configurationProvider&quot;: &quot;ms-vscode.cmake-tools&quot;, &quot;cmake.useCMakePresets&quot;: &quot;always&quot;, &quot;cmake.buildTask&quot;: true, &quot;cmake.sourceDirectory&quot;: &quot;$&#123;workspaceFolder&#125;&quot;&#125; .vscode\\tasks.json 123456789101112131415161718192021222324252627282930313233343536373839404142&#123; &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ &#123; &quot;type&quot;: &quot;cmake&quot;, &quot;label&quot;: &quot;CMake: build&quot;, &quot;command&quot;: &quot;build&quot;, &quot;preset&quot;: &quot;debug&quot;, &quot;targets&quot;: [ &quot;all&quot; ], &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true &#125;, &quot;problemMatcher&quot;: [ &quot;$gcc&quot; ], &quot;detail&quot;: &quot;CMake template build task&quot; &#125;, &#123; &quot;type&quot;: &quot;cmake&quot;, &quot;label&quot;: &quot;CMake: clean&quot;, &quot;command&quot;: &quot;clean&quot;, &quot;preset&quot;: &quot;debug&quot;, &quot;problemMatcher&quot;: [ &quot;$gcc&quot; ], &quot;detail&quot;: &quot;CMake template clean task&quot; &#125;, &#123; &quot;type&quot;: &quot;cmake&quot;, &quot;label&quot;: &quot;CMake: configure&quot;, &quot;command&quot;: &quot;configure&quot;, &quot;preset&quot;: &quot;debug&quot;, &quot;problemMatcher&quot;: [ &quot;$gcc&quot; ], &quot;detail&quot;: &quot;CMake template configure task&quot; &#125; ]&#125; CMakePresets.json 123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123; &quot;version&quot;: 7, &quot;cmakeMinimumRequired&quot;: &#123; &quot;major&quot;: 3 &#125;, &quot;configurePresets&quot;: [ &#123; &quot;name&quot;: &quot;debug&quot;, &quot;displayName&quot;: &quot;debug&quot;, &quot;generator&quot;: &quot;Ninja&quot;, &quot;toolchainFile&quot;: &quot;D:/repository/core/tools/cmake_toolchain_files/armgcc.cmake&quot;, &quot;cacheVariables&quot;: &#123; &quot;CMAKE_BUILD_TYPE&quot;: &quot;debug&quot;, &quot;GNinja&quot;: &quot;D:/software/ninja.exe&quot; &#125;, &quot;inherits&quot;: &quot;debug-env&quot; &#125;, &#123; &quot;name&quot;: &quot;release&quot;, &quot;displayName&quot;: &quot;release&quot;, &quot;generator&quot;: &quot;Ninja&quot;, &quot;toolchainFile&quot;: &quot;D:/repository/core/tools/cmake_toolchain_files/armgcc.cmake&quot;, &quot;cacheVariables&quot;: &#123; &quot;CMAKE_BUILD_TYPE&quot;: &quot;release&quot;, &quot;GNinja&quot;: &quot;D:/software/ninja.exe&quot; &#125;, &quot;inherits&quot;: &quot;release-env&quot; &#125; ], &quot;buildPresets&quot;: [ &#123; &quot;name&quot;: &quot;debug&quot;, &quot;displayName&quot;: &quot;debug&quot;, &quot;configurePreset&quot;: &quot;debug&quot; &#125;, &#123; &quot;name&quot;: &quot;release&quot;, &quot;displayName&quot;: &quot;release&quot;, &quot;configurePreset&quot;: &quot;release&quot; &#125; ], &quot;include&quot;: [ &quot;mcux_include.json&quot; ]&#125; mcux_include.json 123456789101112131415161718192021222324252627282930313233&#123; &quot;version&quot;: 7, &quot;cmakeMinimumRequired&quot;: &#123; &quot;major&quot;: 3 &#125;, &quot;configurePresets&quot;: [ &#123; &quot;name&quot;: &quot;debug-env&quot;, &quot;displayName&quot;: &quot;debug-env&quot;, &quot;hidden&quot;: true, &quot;environment&quot;: &#123; &quot;ARMGCC_DIR&quot;: &quot;d:/software/arm-gcc-toolchain/10 2021.10&quot;, &quot;SdkRootDirPath&quot;: &quot;&quot;, &quot;POSTPROCESS_UTILITY&quot;: &quot;&quot;, &quot;MCUX_VENV_PATH&quot;: &quot;&quot;, &quot;PATH&quot;: &quot;$env&#123;MCUX_VENV_PATH&#125;;$penv&#123;PATH&#125;&quot; &#125; &#125;, &#123; &quot;name&quot;: &quot;release-env&quot;, &quot;displayName&quot;: &quot;release-env&quot;, &quot;hidden&quot;: true, &quot;environment&quot;: &#123; &quot;ARMGCC_DIR&quot;: &quot;d:/software/arm-gcc-toolchain/10 2021.10&quot;, &quot;SdkRootDirPath&quot;: &quot;&quot;, &quot;POSTPROCESS_UTILITY&quot;: &quot;&quot;, &quot;MCUX_VENV_PATH&quot;: &quot;&quot;, &quot;PATH&quot;: &quot;$env&#123;MCUX_VENV_PATH&#125;;$penv&#123;PATH&#125;&quot; &#125; &#125; ], &quot;buildPresets&quot;: []&#125; 后续文章会介绍怎么移植RT-Thread","tags":["NXP","MCXW71","MCU"],"categories":["嵌入式"]},{"title":"STM32G030移植RT-Thread","path":"//stm32g030-port-rtt.html","content":"移植流程移植前需要安装Keil.STM32G0xx_DFP.1.2.0.pack组件，大致的移植过程： CubeMX配置 RT-Thread组件配置 工程模板配置 参考例程配置：拷贝仓库原有的stm32g070-st-nucleo工程，然后另起一个名字，目录结构如下 完整的RT-Thread BSP需要考虑的改动点： 文档：把两个README文档改一下，改成stm32g030相关的说明 芯片：board目录下是跟stm32g030相关的CubeMX配置、链接脚本、板级初始化文件 MDK5：template工程是命令scons --target=mdk5生成工程的模板 系统：.config文件保存RT-Thread系统的基本组件配置，rtconfig.h与之关联 CubeMX配置时钟配置在Caegories栏点击System Core一栏，然后选择RCC，实际上HSE和LSE也可以不用配置，因为stm32已经集成了晶振，在GPIO资源紧张时可以不配置 这里选择不配置时钟，Clock Configuration配置如下： 系统滴答点击SYS项，配置如下图所示 串口配置在Connectivity栏点击USART1项，配置PB6、PB7两个GPIO，设置波特率等串口参数 工程配置Project Manager配置项参考 Code Generator配置，最后点击右上角GENERATE CODE 组件配置先说结论，一个成功移植了GPIO和USART的系统工程大致是这样的： Kconfig 123456789101112131415161718192021222324252627mainmenu &quot;RT-Thread Configuration&quot;BSP_DIR := .RTT_DIR := ../../..PKGS_DIR := packagesconfig SOC_STM32G030RB bool select SOC_SERIES_STM32G0 select RT_USING_COMPONENTS_INIT select RT_USING_USER_MAIN default yconfig BOARD_STM32G030_TINY_BOARD bool select BOARD_SERIES_STM32_NUCLEO_64 default ysource &quot;$(RTT_DIR)/Kconfig&quot;osource &quot;$PKGS_DIR/Kconfig&quot;rsource &quot;../libraries/Kconfig&quot;if !RT_USING_NANOrsource &quot;board/Kconfig&quot;endif board&#x2F;Kconfig 1234567891011121314151617181920212223242526272829303132333435363738menu &quot;Hardware Drivers Config&quot;menu &quot;Onboard Peripheral Drivers&quot;endmenumenu &quot;On-chip Peripheral Drivers&quot; config BSP_USING_GPIO bool &quot;Enable GPIO&quot; select RT_USING_PIN default y menuconfig BSP_USING_UART bool &quot;Enable UART1&quot; default y select RT_USING_SERIAL if BSP_USING_UART config BSP_STM32_UART_V1_TX_TIMEOUT int &quot;UART TX timeout&quot; default 2000 depends on RT_USING_SERIAL_V1 config BSP_USING_UART1 bool &quot;Enable UART1&quot; default y endif source &quot;$(BSP_DIR)/../libraries/HAL_Drivers/drivers/Kconfig&quot;endmenumenu &quot;Board extended module Drivers&quot;endmenuendmenu board&#x2F;SConscript 1234567891011121314151617181920212223242526272829import osimport rtconfigfrom building import *Import(&#x27;SDK_LIB&#x27;)cwd = GetCurrentDir()# add general driverssrc = Split(&#x27;&#x27;&#x27;board.cCubeMX_Config/Src/stm32g0xx_hal_msp.c&#x27;&#x27;&#x27;)path = [cwd]path += [cwd + &#x27;/CubeMX_Config/Inc&#x27;]startup_path_prefix = SDK_LIBif rtconfig.PLATFORM in [&#x27;gcc&#x27;]: src += [startup_path_prefix + &#x27;/STM32G0xx_HAL/CMSIS/Device/ST/STM32G0xx/Source/Templates/gcc/startup_stm32g030xx.s&#x27;]elif rtconfig.PLATFORM in [&#x27;armcc&#x27;, &#x27;armclang&#x27;]: src += [startup_path_prefix + &#x27;/STM32G0xx_HAL/CMSIS/Device/ST/STM32G0xx/Source/Templates/arm/startup_stm32g030xx.s&#x27;]elif rtconfig.PLATFORM in [&#x27;iccarm&#x27;]: src += [startup_path_prefix + &#x27;/STM32G0xx_HAL/CMSIS/Device/ST/STM32G0xx/Source/Templates/iar/startup_stm32g030xx.s&#x27;]CPPDEFINES = [&#x27;STM32G030xx&#x27;]group = DefineGroup(&#x27;Drivers&#x27;, src, depend = [&#x27;&#x27;], CPPPATH = path, CPPDEFINES = CPPDEFINES)Return(&#x27;group&#x27;) board&#x2F;board.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* * Copyright (c) 2006-2025 RT-Thread Development Team * * SPDX-License-Identifier: Apache-2.0 * * Change Logs: * Date Author Notes * 2018-11-5 SummerGift first version */#ifndef __BOARD_H__#define __BOARD_H__#include &lt;rtthread.h&gt;#include &lt;stm32g0xx.h&gt;#include &quot;drv_common.h&quot;#include &quot;drv_gpio.h&quot;#ifdef __cplusplusextern &quot;C&quot; &#123;#endif#define STM32_FLASH_START_ADRESS ((uint32_t)0x08000000)#define STM32_FLASH_SIZE (64 * 1024)#define STM32_FLASH_END_ADDRESS ((uint32_t)(STM32_FLASH_START_ADRESS + STM32_FLASH_SIZE))/* Internal SRAM memory size[Kbytes] &lt;8-64&gt;, Default: 64*/#define STM32_SRAM_SIZE 8#define STM32_SRAM_END (0x20000000 + STM32_SRAM_SIZE * 1024)#if defined(__ARMCC_VERSION)extern int Image$$RW_IRAM1$$ZI$$Limit;#define HEAP_BEGIN ((void *)&amp;Image$$RW_IRAM1$$ZI$$Limit)#elif __ICCARM__#pragma section=&quot;CSTACK&quot;#define HEAP_BEGIN (__segment_end(&quot;CSTACK&quot;))#elseextern int __bss_end;#define HEAP_BEGIN ((void *)&amp;__bss_end)#endif#define HEAP_END STM32_SRAM_ENDvoid SystemClock_Config(void);#ifdef __cplusplus&#125;#endif#endif /* __BOARD_H__ */ board&#x2F;board.c 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* * Copyright (c) 2006-2025 RT-Thread Development Team * * SPDX-License-Identifier: Apache-2.0 * * Change Logs: * Date Author Notes * 2018-12-21 zylx first version */#include &quot;board.h&quot;void SystemClock_Config(void)&#123; RCC_OscInitTypeDef RCC_OscInitStruct = &#123;0&#125;; RCC_ClkInitTypeDef RCC_ClkInitStruct = &#123;0&#125;; /** Configure the main internal regulator output voltage */ HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1); /** Initializes the RCC Oscillators according to the specified parameters * in the RCC_OscInitTypeDef structure. */ RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSIDiv = RCC_HSI_DIV1; RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE; if (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK) &#123; Error_Handler(); &#125; /** Initializes the CPU, AHB and APB buses clocks */ RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK |RCC_CLOCKTYPE_PCLK1; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; if (HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK) &#123; Error_Handler(); &#125;&#125; board&#x2F;linker_scipts&#x2F;link.icf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/* * linker script for STM32F10x with GNU ld *//* Program Entry, set to mark it as &quot;used&quot; and avoid gc */MEMORY&#123; ROM (rx) : ORIGIN = 0x08000000, LENGTH = 64k /* 64KB flash */ RAM (rw) : ORIGIN = 0x20000000, LENGTH = 8k /* 8K sram */&#125;ENTRY(Reset_Handler)_system_stack_size = 0x400;SECTIONS&#123; .text : &#123; . = ALIGN(4); _stext = .; KEEP(*(.isr_vector)) /* Startup code */ . = ALIGN(4); *(.text) /* remaining code */ *(.text.*) /* remaining code */ *(.rodata) /* read-only data (constants) */ *(.rodata*) *(.glue_7) *(.glue_7t) *(.gnu.linkonce.t*) /* section information for finsh shell */ . = ALIGN(4); __fsymtab_start = .; KEEP(*(FSymTab)) __fsymtab_end = .; . = ALIGN(4); __vsymtab_start = .; KEEP(*(VSymTab)) __vsymtab_end = .; /* section information for initial. */ . = ALIGN(4); __rt_init_start = .; KEEP(*(SORT(.rti_fn*))) __rt_init_end = .; . = ALIGN(4); PROVIDE(__ctors_start__ = .); KEEP (*(SORT(.init_array.*))) KEEP (*(.init_array)) PROVIDE(__ctors_end__ = .); . = ALIGN(4); _etext = .; &#125; &gt; ROM = 0 /* .ARM.exidx is sorted, so has to go in its own output section. */ __exidx_start = .; .ARM.exidx : &#123; *(.ARM.exidx* .gnu.linkonce.armexidx.*) /* This is used by the startup in order to initialize the .data secion */ _sidata = .; &#125; &gt; ROM __exidx_end = .; /* .data section which is used for initialized data */ .data : AT (_sidata) &#123; . = ALIGN(4); /* This is used by the startup in order to initialize the .data secion */ _sdata = . ; *(.data) *(.data.*) *(.gnu.linkonce.d*) PROVIDE(__dtors_start__ = .); KEEP(*(SORT(.dtors.*))) KEEP(*(.dtors)) PROVIDE(__dtors_end__ = .); . = ALIGN(4); /* This is used by the startup in order to initialize the .data secion */ _edata = . ; &#125; &gt;RAM .stack : &#123; . = ALIGN(4); _sstack = .; . = . + _system_stack_size; . = ALIGN(4); _estack = .; &#125; &gt;RAM __bss_start = .; .bss : &#123; . = ALIGN(4); /* This is used by the startup in order to initialize the .bss secion */ _sbss = .; *(.bss) *(.bss.*) *(COMMON) . = ALIGN(4); /* This is used by the startup in order to initialize the .bss secion */ _ebss = . ; *(.bss.init) &#125; &gt; RAM __bss_end = .; _end = .; /* Stabs debugging sections. */ .stab 0 : &#123; *(.stab) &#125; .stabstr 0 : &#123; *(.stabstr) &#125; .stab.excl 0 : &#123; *(.stab.excl) &#125; .stab.exclstr 0 : &#123; *(.stab.exclstr) &#125; .stab.index 0 : &#123; *(.stab.index) &#125; .stab.indexstr 0 : &#123; *(.stab.indexstr) &#125; .comment 0 : &#123; *(.comment) &#125; /* DWARF debug sections. * Symbols in the DWARF debugging sections are relative to the beginning * of the section so we begin them at 0. */ /* DWARF 1 */ .debug 0 : &#123; *(.debug) &#125; .line 0 : &#123; *(.line) &#125; /* GNU DWARF 1 extensions */ .debug_srcinfo 0 : &#123; *(.debug_srcinfo) &#125; .debug_sfnames 0 : &#123; *(.debug_sfnames) &#125; /* DWARF 1.1 and DWARF 2 */ .debug_aranges 0 : &#123; *(.debug_aranges) &#125; .debug_pubnames 0 : &#123; *(.debug_pubnames) &#125; /* DWARF 2 */ .debug_info 0 : &#123; *(.debug_info .gnu.linkonce.wi.*) &#125; .debug_abbrev 0 : &#123; *(.debug_abbrev) &#125; .debug_line 0 : &#123; *(.debug_line) &#125; .debug_frame 0 : &#123; *(.debug_frame) &#125; .debug_str 0 : &#123; *(.debug_str) &#125; .debug_loc 0 : &#123; *(.debug_loc) &#125; .debug_macinfo 0 : &#123; *(.debug_macinfo) &#125; /* SGI/MIPS DWARF 2 extensions */ .debug_weaknames 0 : &#123; *(.debug_weaknames) &#125; .debug_funcnames 0 : &#123; *(.debug_funcnames) &#125; .debug_typenames 0 : &#123; *(.debug_typenames) &#125; .debug_varnames 0 : &#123; *(.debug_varnames) &#125;&#125; board&#x2F;linker_scipts&#x2F;link.sct，这个是MDK的链接脚本文件，需要加上rti_fn保证RT-Thread组件的初始化 1234567891011121314; *************************************************************; *** Scatter-Loading Description File generated by uVision ***; *************************************************************LR_IROM1 0x08000000 0x00010000 &#123; ; load region size_region ER_IROM1 0x08000000 0x00010000 &#123; ; load address = execution address *.o (RESET, +First) *(InRoot$$Sections) .ANY (+RO) &#125; RW_IRAM1 0x20000000 0x00002000 &#123; ; RW data .ANY (+RW +ZI) &#125;&#125; board&#x2F;linker_scripts&#x2F;link.lds，这个是arm gcc的链接脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/* * linker script for STM32F10x with GNU ld *//* Program Entry, set to mark it as &quot;used&quot; and avoid gc */MEMORY&#123; ROM (rx) : ORIGIN = 0x08000000, LENGTH = 64k /* 128KB flash */ RAM (rw) : ORIGIN = 0x20000000, LENGTH = 8k /* 8K sram */&#125;ENTRY(Reset_Handler)_system_stack_size = 0x400;SECTIONS&#123; .text : &#123; . = ALIGN(4); _stext = .; KEEP(*(.isr_vector)) /* Startup code */ . = ALIGN(4); *(.text) /* remaining code */ *(.text.*) /* remaining code */ *(.rodata) /* read-only data (constants) */ *(.rodata*) *(.glue_7) *(.glue_7t) *(.gnu.linkonce.t*) /* section information for finsh shell */ . = ALIGN(4); __fsymtab_start = .; KEEP(*(FSymTab)) __fsymtab_end = .; . = ALIGN(4); __vsymtab_start = .; KEEP(*(VSymTab)) __vsymtab_end = .; /* section information for initial. */ . = ALIGN(4); __rt_init_start = .; KEEP(*(SORT(.rti_fn*))) __rt_init_end = .; . = ALIGN(4); PROVIDE(__ctors_start__ = .); KEEP (*(SORT(.init_array.*))) KEEP (*(.init_array)) PROVIDE(__ctors_end__ = .); . = ALIGN(4); _etext = .; &#125; &gt; ROM = 0 /* .ARM.exidx is sorted, so has to go in its own output section. */ __exidx_start = .; .ARM.exidx : &#123; *(.ARM.exidx* .gnu.linkonce.armexidx.*) /* This is used by the startup in order to initialize the .data secion */ _sidata = .; &#125; &gt; ROM __exidx_end = .; /* .data section which is used for initialized data */ .data : AT (_sidata) &#123; . = ALIGN(4); /* This is used by the startup in order to initialize the .data secion */ _sdata = . ; *(.data) *(.data.*) *(.gnu.linkonce.d*) PROVIDE(__dtors_start__ = .); KEEP(*(SORT(.dtors.*))) KEEP(*(.dtors)) PROVIDE(__dtors_end__ = .); . = ALIGN(4); /* This is used by the startup in order to initialize the .data secion */ _edata = . ; &#125; &gt;RAM .stack : &#123; . = ALIGN(4); _sstack = .; . = . + _system_stack_size; . = ALIGN(4); _estack = .; &#125; &gt;RAM __bss_start = .; .bss : &#123; . = ALIGN(4); /* This is used by the startup in order to initialize the .bss secion */ _sbss = .; *(.bss) *(.bss.*) *(COMMON) . = ALIGN(4); /* This is used by the startup in order to initialize the .bss secion */ _ebss = . ; *(.bss.init) &#125; &gt; RAM __bss_end = .; _end = .; /* Stabs debugging sections. */ .stab 0 : &#123; *(.stab) &#125; .stabstr 0 : &#123; *(.stabstr) &#125; .stab.excl 0 : &#123; *(.stab.excl) &#125; .stab.exclstr 0 : &#123; *(.stab.exclstr) &#125; .stab.index 0 : &#123; *(.stab.index) &#125; .stab.indexstr 0 : &#123; *(.stab.indexstr) &#125; .comment 0 : &#123; *(.comment) &#125; /* DWARF debug sections. * Symbols in the DWARF debugging sections are relative to the beginning * of the section so we begin them at 0. */ /* DWARF 1 */ .debug 0 : &#123; *(.debug) &#125; .line 0 : &#123; *(.line) &#125; /* GNU DWARF 1 extensions */ .debug_srcinfo 0 : &#123; *(.debug_srcinfo) &#125; .debug_sfnames 0 : &#123; *(.debug_sfnames) &#125; /* DWARF 1.1 and DWARF 2 */ .debug_aranges 0 : &#123; *(.debug_aranges) &#125; .debug_pubnames 0 : &#123; *(.debug_pubnames) &#125; /* DWARF 2 */ .debug_info 0 : &#123; *(.debug_info .gnu.linkonce.wi.*) &#125; .debug_abbrev 0 : &#123; *(.debug_abbrev) &#125; .debug_line 0 : &#123; *(.debug_line) &#125; .debug_frame 0 : &#123; *(.debug_frame) &#125; .debug_str 0 : &#123; *(.debug_str) &#125; .debug_loc 0 : &#123; *(.debug_loc) &#125; .debug_macinfo 0 : &#123; *(.debug_macinfo) &#125; /* SGI/MIPS DWARF 2 extensions */ .debug_weaknames 0 : &#123; *(.debug_weaknames) &#125; .debug_funcnames 0 : &#123; *(.debug_funcnames) &#125; .debug_typenames 0 : &#123; *(.debug_typenames) &#125; .debug_varnames 0 : &#123; *(.debug_varnames) &#125;&#125; main.c，最小例程里边带了LED闪烁功能 123456789101112131415161718192021222324252627282930313233343536/* * Copyright (c) 2006-2025 RT-Thread Development Team * * SPDX-License-Identifier: Apache-2.0 * * Change Logs: * Date Author Notes * 2025-3-17 hywing first version */#include &lt;board.h&gt;#include &lt;rtthread.h&gt;#ifndef RT_USING_NANO#include &lt;rtdevice.h&gt;#endif /* RT_USING_NANO *//* defined the LED0 pin: PB4 */#define LED0_PIN GET_PIN(B, 4)int main(void)&#123; /* set LED0 pin mode to output */ rt_pin_mode(LED0_PIN, PIN_MODE_OUTPUT); rt_kprintf(&quot;Welcome to the world of IoT Stuff!\\r &quot;); while (1) &#123; rt_pin_write(LED0_PIN, PIN_HIGH); rt_thread_mdelay(500); rt_pin_write(LED0_PIN, PIN_LOW); rt_thread_mdelay(500); &#125; return RT_EOK;&#125; 工程模板我们先把Template工程配置好，然后后面就可以通过scons自动生成想要的工程配置，打开Template工程模板选择STM32G030C8TX 时钟配置为16MHz，检查IROM1和IRAM1的起始地址以及大小是否正确 下载器配置为ST-Link Debugger ST-Link Debug配置，Clock Req设为10MHz Flash Download配置 Include Paths调整：拷贝过来的例程有些是不对的，需要修正过来 导出MDK Keil5工程 1scons --target=mdk5 导出的rtconfig.h文件配置如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391#ifndef RT_CONFIG_H__#define RT_CONFIG_H__#define SOC_STM32G030RB#define BOARD_STM32G030_TINY_BOARD/* RT-Thread Kernel *//* klibc options *//* rt_vsnprintf options */#define RT_KLIBC_USING_LIBC_VSNPRINTF/* end of rt_vsnprintf options *//* rt_vsscanf options */#define RT_KLIBC_USING_LIBC_VSSCANF/* end of rt_vsscanf options *//* rt_memset options *//* end of rt_memset options *//* rt_memcpy options *//* end of rt_memcpy options *//* rt_memmove options *//* end of rt_memmove options *//* rt_memcmp options *//* end of rt_memcmp options *//* rt_strstr options *//* end of rt_strstr options *//* rt_strcasecmp options *//* end of rt_strcasecmp options *//* rt_strncpy options *//* end of rt_strncpy options *//* rt_strcpy options *//* end of rt_strcpy options *//* rt_strncmp options *//* end of rt_strncmp options *//* rt_strcmp options *//* end of rt_strcmp options *//* rt_strlen options *//* end of rt_strlen options *//* rt_strnlen options *//* end of rt_strnlen options *//* end of klibc options */#define RT_NAME_MAX 8#define RT_CPUS_NR 1#define RT_ALIGN_SIZE 8#define RT_THREAD_PRIORITY_32#define RT_THREAD_PRIORITY_MAX 32#define RT_TICK_PER_SECOND 1000#define RT_USING_OVERFLOW_CHECK#define RT_USING_HOOK#define RT_HOOK_USING_FUNC_PTR#define RT_USING_IDLE_HOOK#define RT_IDLE_HOOK_LIST_SIZE 4#define IDLE_THREAD_STACK_SIZE 256/* kservice options *//* end of kservice options */#define RT_USING_DEBUG#define RT_DEBUGING_ASSERT#define RT_DEBUGING_COLOR#define RT_DEBUGING_CONTEXT/* Inter-Thread communication */#define RT_USING_SEMAPHORE#define RT_USING_MUTEX#define RT_USING_EVENT#define RT_USING_MAILBOX#define RT_USING_MESSAGEQUEUE/* end of Inter-Thread communication *//* Memory Management */#define RT_USING_MEMPOOL#define RT_USING_SMALL_MEM#define RT_USING_SMALL_MEM_AS_HEAP#define RT_USING_HEAP/* end of Memory Management */#define RT_USING_DEVICE#define RT_USING_CONSOLE#define RT_CONSOLEBUF_SIZE 128#define RT_CONSOLE_DEVICE_NAME &quot;uart1&quot;#define RT_VER_NUM 0x50200#define RT_BACKTRACE_LEVEL_MAX_NR 32/* end of RT-Thread Kernel */#define ARCH_ARM#define ARCH_ARM_CORTEX_M#define ARCH_ARM_CORTEX_M0/* RT-Thread Components */#define RT_USING_COMPONENTS_INIT#define RT_USING_USER_MAIN#define RT_MAIN_THREAD_STACK_SIZE 1024#define RT_MAIN_THREAD_PRIORITY 10#define RT_USING_MSH#define RT_USING_FINSH#define FINSH_USING_MSH#define FINSH_THREAD_NAME &quot;tshell&quot;#define FINSH_THREAD_PRIORITY 20#define FINSH_THREAD_STACK_SIZE 768#define FINSH_USING_HISTORY#define FINSH_HISTORY_LINES 5#define FINSH_USING_SYMTAB#define FINSH_CMD_SIZE 80#define MSH_USING_BUILT_IN_COMMANDS#define FINSH_USING_DESCRIPTION#define FINSH_ARG_MAX 10#define FINSH_USING_OPTION_COMPLETION/* DFS: device virtual file system *//* end of DFS: device virtual file system *//* Device Drivers */#define RT_USING_DEVICE_IPC#define RT_UNAMED_PIPE_NUMBER 64#define RT_USING_SERIAL#define RT_USING_SERIAL_V1#define RT_SERIAL_USING_DMA#define RT_SERIAL_RB_BUFSZ 64#define RT_USING_PIN/* end of Device Drivers *//* C/C++ and POSIX layer *//* ISO-ANSI C layer *//* Timezone and Daylight Saving Time */#define RT_LIBC_USING_LIGHT_TZ_DST#define RT_LIBC_TZ_DEFAULT_HOUR 8#define RT_LIBC_TZ_DEFAULT_MIN 0#define RT_LIBC_TZ_DEFAULT_SEC 0/* end of Timezone and Daylight Saving Time *//* end of ISO-ANSI C layer *//* POSIX (Portable Operating System Interface) layer *//* Interprocess Communication (IPC) *//* Socket is in the &#x27;Network&#x27; category *//* end of Interprocess Communication (IPC) *//* end of POSIX (Portable Operating System Interface) layer *//* end of C/C++ and POSIX layer *//* Network *//* end of Network *//* Memory protection *//* end of Memory protection *//* Utilities *//* end of Utilities *//* Using USB legacy version *//* end of Using USB legacy version *//* end of RT-Thread Components *//* RT-Thread Utestcases *//* end of RT-Thread Utestcases *//* RT-Thread online packages *//* IoT - internet of things *//* Wi-Fi *//* Marvell WiFi *//* end of Marvell WiFi *//* Wiced WiFi *//* end of Wiced WiFi *//* CYW43012 WiFi *//* end of CYW43012 WiFi *//* BL808 WiFi *//* end of BL808 WiFi *//* CYW43439 WiFi *//* end of CYW43439 WiFi *//* end of Wi-Fi *//* IoT Cloud *//* end of IoT Cloud *//* end of IoT - internet of things *//* security packages *//* end of security packages *//* language packages *//* JSON: JavaScript Object Notation, a lightweight data-interchange format *//* end of JSON: JavaScript Object Notation, a lightweight data-interchange format *//* XML: Extensible Markup Language *//* end of XML: Extensible Markup Language *//* end of language packages *//* multimedia packages *//* LVGL: powerful and easy-to-use embedded GUI library *//* end of LVGL: powerful and easy-to-use embedded GUI library *//* u8g2: a monochrome graphic library *//* end of u8g2: a monochrome graphic library *//* end of multimedia packages *//* tools packages *//* end of tools packages *//* system packages *//* enhanced kernel services *//* end of enhanced kernel services *//* acceleration: Assembly language or algorithmic acceleration packages *//* end of acceleration: Assembly language or algorithmic acceleration packages *//* CMSIS: ARM Cortex-M Microcontroller Software Interface Standard *//* end of CMSIS: ARM Cortex-M Microcontroller Software Interface Standard *//* Micrium: Micrium software products porting for RT-Thread *//* end of Micrium: Micrium software products porting for RT-Thread *//* end of system packages *//* peripheral libraries and drivers *//* HAL &amp; SDK Drivers *//* STM32 HAL &amp; SDK Drivers *//* end of STM32 HAL &amp; SDK Drivers *//* Infineon HAL Packages *//* end of Infineon HAL Packages *//* Kendryte SDK *//* end of Kendryte SDK *//* end of HAL &amp; SDK Drivers *//* sensors drivers *//* end of sensors drivers *//* touch drivers *//* end of touch drivers *//* end of peripheral libraries and drivers *//* AI packages *//* end of AI packages *//* Signal Processing and Control Algorithm Packages *//* end of Signal Processing and Control Algorithm Packages *//* miscellaneous packages *//* project laboratory *//* end of project laboratory *//* samples: kernel and components samples *//* end of samples: kernel and components samples *//* entertainment: terminal games and other interesting software packages *//* end of entertainment: terminal games and other interesting software packages *//* end of miscellaneous packages *//* Arduino libraries *//* Projects and Demos *//* end of Projects and Demos *//* Sensors *//* end of Sensors *//* Display *//* end of Display *//* Timing *//* end of Timing *//* Data Processing *//* end of Data Processing *//* Data Storage *//* Communication *//* end of Communication *//* Device Control *//* end of Device Control *//* Other *//* end of Other *//* Signal IO *//* end of Signal IO *//* Uncategorized *//* end of Arduino libraries *//* end of RT-Thread online packages */#define SOC_FAMILY_STM32#define SOC_SERIES_STM32G0#define BOARD_SERIES_STM32_NUCLEO_64/* Hardware Drivers Config *//* Onboard Peripheral Drivers *//* On-chip Peripheral Drivers */#define BSP_USING_GPIO#define BSP_USING_UART#define BSP_STM32_UART_V1_TX_TIMEOUT 2000#define BSP_USING_UART1/* end of On-chip Peripheral Drivers *//* Board extended module Drivers *//* end of Hardware Drivers Config */#endif 遇到的问题 断点失效：尽量不用Browse Information就OK 没有msh提示符输出：把msh线程的栈空间大小FINSH_THREAD_STACK_SIZE调小一点就OK，512也是可以的但ps命令会卡死 1#define FINSH_THREAD_STACK_SIZE 768 资源紧张，SRAM比较有限，任务的堆栈尽量小一些 开源移植的工程已经push到RT-Thread GitHub仓库：rt-thread&#x2F;bsp&#x2F;stm32&#x2F;stm32g030-tiny-board at master · RT-Thread&#x2F;rt-thread","tags":["stm32","RT-Thread"],"categories":["嵌入式"]},{"title":"如何撤销缓冲区的提交","path":"//git-reset-command.html","content":"介绍一次误操作发现commit的时候漏提交一些文件，但是还没有push到远端仓库，缓冲区可以看到提交记录 解决git-bash用reset命令将commit撤销掉（最近一次提交记录会没有），然后修改的文件保存到当前工作区，用户可以再次提交 1git reset --soft HEAD^ tortoiseGit在仓库所在文件夹右键菜单打开Show log列表，然后选中某条提交记录右键再弹出菜单，点击Reset xxx to this ...就可以回退了","tags":["git"],"categories":["开发工具"]},{"title":"倍福官方ADS组件使用","path":"//beckhoff-ads-usage.html","content":"介绍倍福官方把ADS通信组件做成了跨平台（Windows、Linux、BSD），而且还开源，这下在Unix开发工控机上位机软件就问题不大了，这是官方的编译器配置要求： Currently (2024-12-13) tested with: host os host target compiler Alpine 3.21 amd64 amd64 gcc 14.2.0 Arch Linux amd64 amd64 clang 18.1.8 Arch Linux amd64 amd64 gcc 14.2.1 Debian 12 amd64 amd64 clang 14.0.6 Debian 12 amd64 amd64 gcc 12.2.0-14 Debian 12 amd64 i686 gcc 12.2.0-14 Debian 12 amd64 mips gcc 12.2.0-14 Debian 12 amd64 win32 gcc 10.2.1-6 Debian 12 amd64 riscv64 gcc 12.2.0-13 Debian 12 arm64 arm64 gcc 12.2.0-14 TC&#x2F;BSD 14 amd64 amd64 clang 18.1.5 Windows 10 amd64 win64 msvc 19.36.33134 编译开源工程是用cmake构建的，在Windows下可以直接用QtCreator打开 配置编译的类型、构建路径、安装目录 用MSVC2017编译需要在顶层cmake加入一行代码 构建工程的过程中会遇到Link错误，明显这个是个静态库lib 在AdsLib里边改一下库的配置类型，你也可以把前面那个BUILD_SHARED_LIBS的选项去掉 然后点击重新构建就好 测试ADS组件里边自带的example例程也很简单，跟以太网通信那一套类似，都是对指定IP地址和端口发起连接，TC3的端口为851 1234567891011121314151617static void runExample(std::ostream&amp; out)&#123; static const AmsNetId remoteNetId &#123; 192, 168, 0, 231, 1, 1 &#125;; static const char remoteIpV4[] = &quot;ads-server&quot;; // uncomment and adjust if automatic AmsNetId deduction is not working as expected //bhf::ads::SetLocalAddress(&#123;192, 168, 0, 1, 1, 1&#125;); AdsDevice route &#123;remoteIpV4, remoteNetId, AMSPORT_R0_PLC_TC3&#125;; notificationExample(out, route); notificationByNameExample(out, route); readExample(out, route); readByNameExample(out, route); readWriteExample(out, route); readWriteArrayExample(out, route); readStateExample(out, route);&#125; AdsDevice类型，需要配置AdsDevice的地址、端口等信息后读取指定地址或名称的寄存器值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct AdsDevice &#123; AdsDevice(const std::string&amp; ipV4, AmsNetId netId, uint16_t port); DeviceInfo GetDeviceInfo() const; /** Get handle to access AdsVariable by indexGroup/Offset */ AdsHandle GetHandle(uint32_t offset) const; /** Get handle for access by symbol name */ AdsHandle GetHandle(const std::string&amp; symbolName) const; /** Get notification handle */ AdsHandle GetHandle(uint32_t indexGroup, uint32_t indexOffset, const AdsNotificationAttrib&amp; notificationAttributes, PAdsNotificationFuncEx callback, uint32_t hUser) const; /** Get handle to access files */ AdsHandle OpenFile(const std::string&amp; filename, uint32_t flags) const; long GetLocalPort() const; AdsDeviceState GetState() const; void SetState(const ADSSTATE AdsState, const ADSSTATE DeviceState) const; uint32_t GetTimeout() const; void SetTimeout(const uint32_t timeout) const; long ReadReqEx2(uint32_t group, uint32_t offset, size_t length, void* buffer, uint32_t* bytesRead) const; long ReadWriteReqEx2(uint32_t indexGroup, uint32_t indexOffset, size_t readLength, void* readData, size_t writeLength, const void* writeData, uint32_t* bytesRead) const; long WriteReqEx(uint32_t group, uint32_t offset, size_t length, const void* buffer) const; AdsResource&lt;const AmsNetId&gt; m_NetId; const AmsAddr m_Addr;private: AdsResource&lt;const long&gt; m_LocalPort; long CloseFile(uint32_t handle) const; long DeleteNotificationHandle(uint32_t handle) const; long DeleteSymbolHandle(uint32_t handle) const;&#125;; AdsVariable是一个模板类型，封装了各种各样的寄存器类型的数据访问（IndexGroup、group、offset或者symbolName） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566template&lt;typename T&gt;struct AdsVariable &#123; AdsVariable(const AdsDevice&amp; route, const std::string&amp; symbolName) : m_Route(route), m_IndexGroup(ADSIGRP_SYM_VALBYHND), m_Handle(route.GetHandle(symbolName)) &#123;&#125; AdsVariable(const AdsDevice&amp; route, const uint32_t group, const uint32_t offset) : m_Route(route), m_IndexGroup(group), m_Handle(route.GetHandle(offset)) &#123;&#125; operator T() const &#123; T buffer; Read(sizeof(buffer), &amp;buffer); return buffer; &#125; void operator=(const T&amp; value) const &#123; Write(sizeof(T), &amp;value); &#125; template&lt;typename U, size_t N&gt; operator std::array&lt;U, N&gt;() const &#123; std::array&lt;U, N&gt; buffer; Read(sizeof(U) * N, buffer.data()); return buffer; &#125; template&lt;typename U, size_t N&gt; void operator=(const std::array&lt;U, N&gt;&amp; value) const &#123; Write(sizeof(U) * N, value.data()); &#125; void Read(const size_t size, void* data) const &#123; uint32_t bytesRead = 0; auto error = m_Route.ReadReqEx2(m_IndexGroup, *m_Handle, size, data, &amp;bytesRead); if (error || (size != bytesRead)) &#123; throw AdsException(error); &#125; &#125; void Write(const size_t size, const void* data) const &#123; auto error = m_Route.WriteReqEx(m_IndexGroup, *m_Handle, size, data); if (error) &#123; throw AdsException(error); &#125; &#125;private: const AdsDevice&amp; m_Route; const uint32_t m_IndexGroup; const AdsHandle m_Handle;&#125;; 根据group和offset读取寄存器值 123456789static void readExample(std::ostream&amp; out, const AdsDevice&amp; route)&#123; AdsVariable&lt;uint8_t&gt; readVar &#123;route, 0x4020, 0&#125;; out &lt;&lt; __FUNCTION__ &lt;&lt; &quot;(): &quot;; for (size_t i = 0; i &lt; 8; ++i) &#123; out &lt;&lt; &quot;ADS read &quot; &lt;&lt; std::hex &lt;&lt; (uint32_t)readVar &lt;&lt; &#x27; &#x27;; &#125;&#125; 根据name读取寄存器值 123456789static void readByNameExample(std::ostream&amp; out, const AdsDevice&amp; route)&#123; AdsVariable&lt;uint8_t&gt; readVar &#123;route, &quot;MAIN.byByte[4]&quot;&#125;; out &lt;&lt; __FUNCTION__ &lt;&lt; &quot;(): &quot;; for (size_t i = 0; i &lt; 8; ++i) &#123; out &lt;&lt; &quot;ADS read &quot; &lt;&lt; std::hex &lt;&lt; (uint32_t)readVar &lt;&lt; &#x27; &#x27;; &#125;&#125; 读写示例 1234567891011static void readWriteExample(std::ostream&amp; out, const AdsDevice&amp; route)&#123; AdsVariable&lt;uint8_t&gt; simpleVar &#123;route, &quot;MAIN.byByte[0]&quot;&#125;; AdsVariable&lt;uint8_t&gt; validation &#123;route, &quot;MAIN.byByte[0]&quot;&#125;; out &lt;&lt; __FUNCTION__ &lt;&lt; &quot;(): &quot;; simpleVar = 0xA5; out &lt;&lt; &quot;Wrote &quot; &lt;&lt; 0xA5 &lt;&lt; &quot; to MAIN.byByte and read &quot; &lt;&lt; (uint32_t)validation &lt;&lt; &quot; back &quot;; simpleVar = 0x5A; out &lt;&lt; &quot;Wrote &quot; &lt;&lt; (uint32_t)simpleVar &lt;&lt; &quot; to MAIN.byByte and read &quot; &lt;&lt; (uint32_t)validation &lt;&lt; &quot; back &quot;;&#125; 应用构建好之后在install目录下会生成相关的库文件、头文件，方便我们拿到自己的项目使用 在cmake里边包含和链接ads组件 123include_directories($&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/ads)target_link_libraries(demoApp PUBLIC ads)","tags":["ADS","自动化"],"categories":["程序设计"]},{"title":"开发板硬件测试","path":"//board-test.html","content":"前言作为一名电子工程师，你可以不懂嵌入式，但你绝对不能不懂示波器！ 介绍嵌入式工程师拿到开发板第一时间需要检查开发板功能是否正常，示波器用来做硬件测试最好不过了，这里以数字电路为例列举一些常见的测试方法 电源电源失稳有可能导致芯片无法正常工作，电源测试主要是针对USB电源、三端稳压器（线性电源）、GPIO电平、LED电源指示灯等 时钟晶振不起振可能会导致芯片无法工作，不过像stm32这样的芯片都内置晶振，这个可以帮忙判断检查外置晶振或RTC是否起振，但不能作为芯片不能工作的唯一依据 按键主要是复位按键以及用户按键的工作状况（是否能稳定输出脉冲） 外设比如i2c主从设备通信是否正常（如硬件忘了给SDA、SCL上拉电阻），国产示波器通常自带协议解码的功能，推荐用国产示波器来测试 PWM波形也不例外","tags":["开发板","示波器"],"categories":["嵌入式"]},{"title":"上位机数据可视化：使用QtCharts绘制波形图","path":"//qt-charts-design.html","content":"工程配置CMake文件 123find_package(Qt5 COMPONENTS Charts REQUIRED)target_link_libraries(zhd-desktop PRIVATE Qt5::Charts) 包含头文件以及名称空间（这个很重要，没有包含名称空间编译器会提示找不到相关的类型） 123#include &lt;QtCharts&gt;using namespace QtCharts; 初始化初始化Chart 1234567891011121314// 创建图表QChart *chart = new QChart();chart-&gt;setTitle(&quot;Valve Data&quot;);// 隐藏图例chart-&gt;legend()-&gt;setVisible(false);// 创建图表视图QChartView *chartView = new QChartView(chart);chartView-&gt;setRenderHint(QPainter::Antialiasing);QHBoxLayout *hLayout = new QHBoxLayout(ui-&gt;view);hLayout-&gt;addWidget(chartView);hLayout-&gt;setContentsMargins(0, 0, 0, 0); 波形每一道波形就是一个QLineSeries，每个QLineSeries都要和X轴和Y轴进行绑定 123456789101112131415m_temperature = new QLineSeries();m_temperature-&gt;setColor(Qt::red);m_temperature-&gt;setPointsVisible(true);m_pressure = new QLineSeries();m_pressure-&gt;setColor(Qt::blue);m_pressure-&gt;setPointsVisible(true);m_position = new QLineSeries();m_position-&gt;setColor(Qt::black);m_position-&gt;setPointsVisible(true);m_pressureSetpt = new QLineSeries();m_pressureSetpt-&gt;setColor(Qt::darkYellow);m_pressureSetpt-&gt;setPointsVisible(true); 为了使波形更有区分度，需要配置不同的颜色，建议跟Y轴刻度的颜色保持一致，特别是轴比较多的情况下 1234567void setAxisColor(QAbstractAxis *axis, const QColor &amp;color)&#123; axis-&gt;setGridLineColor(color); axis-&gt;setLinePenColor(color); axis-&gt;setLabelsColor(color); axis-&gt;setTitleBrush(color);&#125; X轴X轴一般是时间轴，时分秒格式：hh:mm:ss 123456QDateTimeAxis *timeAxis = new QDateTimeAxis();timeAxis-&gt;setTitleText(&quot;Time&quot;);timeAxis-&gt;setFormat(&quot;hh:mm:ss&quot;);chart-&gt;addAxis(timeAxis, Qt::AlignBottom);series1-&gt;attachAxis(timeAxis);series2-&gt;attachAxis(timeAxis); Y轴Y轴：左侧和右侧都可以添加刻度尺 12345678910111213141516171819202122232425// 左侧刻度尺QValueAxis *pressureSetpt = new QValueAxis();pressureSetpt-&gt;setTitleText(&quot;Pressure Setpt (Torr)&quot;);pressureSetpt-&gt;setRange(0, 25);chart-&gt;addAxis(pressureSetpt, Qt::AlignLeft);series1-&gt;attachAxis(pressureSetpt);QValueAxis *pressure = new QValueAxis();pressure-&gt;setTitleText(&quot;Pressure (Torr)&quot;);pressure-&gt;setRange(0, 25);chart-&gt;addAxis(pressure, Qt::AlignLeft);series1-&gt;attachAxis(pressure);// 右侧刻度尺QValueAxis *driverTemperature = new QValueAxis();driverTemperature-&gt;setTitleText(&quot;Driver temperature&quot;);driverTemperature-&gt;setRange(0, 100);chart-&gt;addAxis(driverTemperature, Qt::AlignRight);series2-&gt;attachAxis(driverTemperature);QValueAxis *positionAxis = new QValueAxis();positionAxis-&gt;setTitleText(&quot;Position (%)&quot;);positionAxis-&gt;setRange(0, 100);chart-&gt;addAxis(positionAxis, Qt::AlignRight);series2-&gt;attachAxis(positionAxis); 绘图实时绘制波形点：往QLineSeries里边添加数据，用append接口 1234567891011121314151617181920212223242526272829303132QDateTime currentTime = QDateTime::currentDateTime();if(m_resumePause) &#123; m_timeAxis-&gt;setRange(currentTime.addSecs(-10), currentTime);&#125;if(m_channels[0]) &#123; m_pressure-&gt;append(currentTime.toMSecsSinceEpoch(), pressure); if (m_pressure-&gt;count() &gt; m_max) &#123; m_pressure-&gt;remove(0); &#125;&#125;if(m_channels[1]) &#123; m_position-&gt;append(currentTime.toMSecsSinceEpoch(), position); if (m_position-&gt;count() &gt; m_max) &#123; m_position-&gt;remove(0); &#125;&#125;if(m_channels[2]) &#123; m_pressureSetpt-&gt;append(currentTime.toMSecsSinceEpoch(), pressureSetpt); if (m_pressureSetpt-&gt;count() &gt; m_max) &#123; m_pressureSetpt-&gt;remove(0); &#125;&#125;if(m_channels[3]) &#123; m_temperature-&gt;append(currentTime.toMSecsSinceEpoch(), valveTemperature); if (m_temperature-&gt;count() &gt; m_max) &#123; m_temperature-&gt;remove(0); &#125;&#125; 注意事项： 1.时间轴要实时移动到正确的时间窗口范围 2.QLineSeries波形点之后到达一定的数据量需要删除一些点以确保buffer不会写爆（频繁申请内存导致卡顿） 进阶QtCharts自带的时间轴比较丑陋，如果想要定制的话，可以参考以下方法进行样式修改 自定义QValueAxis作为X轴 捕获QValueAxis::rangeChanged信号，获取QChartView里边的scene，同时也可以获取到刻度的左右边界min和max 删除scene（QGraphicsScene）里边的所有items，即原有的刻度不要了 在QGraphicsScene即基础上画刻度，每一个刻度就是一个QGraphicsLineItem 代码参考 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 动态修改 X 轴标签为时间格式，并绘制刻度线QObject::connect(axisX, &amp;QValueAxis::rangeChanged, [axisX, chartView](qreal min, qreal max) &#123; QGraphicsScene *scene = chartView-&gt;scene(); // 检查 min 和 max 是否有效 if (qIsNaN(min) || qIsNaN(max) || qIsInf(min) || qIsInf(max)) &#123; // qWarning() &lt;&lt; &quot;Invalid min or max value:&quot; &lt;&lt; min &lt;&lt; max; return; &#125; // 检查 plotArea 是否有效 if (chartView-&gt;chart()-&gt;plotArea().width() &lt;= 0 || chartView-&gt;chart()-&gt;plotArea().height() &lt;= 0) &#123; // qWarning() &lt;&lt; &quot;Invalid plot area size&quot;; return; &#125; // 清除旧的标签和刻度线 for (QGraphicsItem *item : scene-&gt;items()) &#123; if (item-&gt;data(0).toString() == &quot;custom_label&quot; || item-&gt;data(0).toString() == &quot;custom_line&quot;) &#123; scene-&gt;removeItem(item); delete item; &#125; &#125; // 生成 10 个刻度 int tickCount = 10; // 总共 10 个刻度 qreal tickInterval = (max - min) / (tickCount - 1); // 计算刻度间隔 for (int i = 0; i &lt; tickCount; ++i) &#123; qreal value = min + i * tickInterval; // 检查 value 是否有效 if (qIsNaN(value) || qIsInf(value)) &#123; // qWarning() &lt;&lt; &quot;Invalid value:&quot; &lt;&lt; value; continue; &#125; QDateTime dateTime = QDateTime::fromSecsSinceEpoch(value); // 计算刻度线的位置 qreal x = chartView-&gt;chart()-&gt;plotArea().left() + (value - min) / (max - min) * chartView-&gt;chart()-&gt;plotArea().width(); // 检查 x 是否有效 if (qIsNaN(x) || qIsInf(x)) &#123; // qWarning() &lt;&lt; &quot;Invalid x coordinate:&quot; &lt;&lt; x; continue; &#125; // 只在偶数刻度绘制时间标签和黑线 if (i % 2 == 0) &#123; // 绘制时间标签 QString label = dateTime.toString(&quot;hh:mm:ss&quot;); QGraphicsTextItem *textItem = scene-&gt;addText(label); qreal textWidth = textItem-&gt;boundingRect().width(); // 获取标签宽度 qreal textHeight = textItem-&gt;boundingRect().height(); // 获取标签高度 // 调整标签位置，使其居中对齐刻度线 textItem-&gt;setPos(x - textWidth / 2, chartView-&gt;chart()-&gt;plotArea().bottom() + 10); textItem-&gt;setData(0, &quot;custom_label&quot;); // 标记为自定义标签 // 绘制黑线 qreal lineLength = 10; // 刻度线长度 QGraphicsLineItem *lineItem = scene-&gt;addLine(x, chartView-&gt;chart()-&gt;plotArea().bottom(), x, chartView-&gt;chart()-&gt;plotArea().bottom() + lineLength, QPen(Qt::black)); lineItem-&gt;setData(0, &quot;custom_line&quot;); // 标记为自定义刻度线 &#125; &#125;&#125;); 打包软件打包，需要添加Qt5Charts这个dll 1Qt5Charts.dll 版权版权问题：据说是LGPL授权，商用的话可能会被Qt请喝茶","tags":["Qt","上位机","Charts"],"categories":["程序设计"]},{"title":"上位机数据可视化：Qt表格美化","path":"//qt-table-design.html","content":"介绍表格是一种常见的数据管理界面形式，在大批量的数据交互情形下使用的比较多 表格可以通过样式表设置线条以及边框的颜色 12345QTableWidget&#123; gridline-color : rgb(55, 60, 62); border: 1px solid rgb(62,112,181); &#125; 表头如果表头和第一行的分割线显示，请设置一下表头的样式表 1234QHeaderView::section &#123; border: 1px solid gray; &#125; 表头不是必须的，可以设置horizontalHeaderVisiable属性把它隐藏掉 列列的数目：columnCount 列序号，比较不美观，最好隐藏掉：verticalHeaderVisible -&gt; false 列宽控制 1234for (int i = 0; i &lt; ui-&gt;tableWidget-&gt;columnCount(); ++i) &#123; ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;setSectionResizeMode(i, QHeaderView::Fixed); ui-&gt;tableWidget-&gt;setColumnWidth(i, width);&#125; 行行的数目：rowCount 行高控制 123for (int i = 0; i &lt; tableWidget-&gt;rowCount(); ++i) &#123; ui-&gt;tableWidget-&gt;setRowHeight(i, 30); &#125; 单元格样式表修改，只要指定item项，便可以修改相关的文字颜色、背景色、字体大小、文字对齐等样式 1234567QTableWidget::item&#123; color: red; background-color: blue; font-size: 14px; text-align: center;&#125; 设置只读状态 123item = new QTableWidgetItem;item-&gt;setText(QString::number(p-&gt;suggestedFlow, &#x27;f&#x27;, 2));item-&gt;setFlags(item-&gt;flags() &amp; ~Qt::ItemIsEditable); 插入自定义控件 12345auto itemWidget = new QComboBox;itemWidget-&gt;addItem(&quot;OFF&quot;);itemWidget-&gt;addItem(&quot;ON&quot;);itemWidget-&gt;setCurrentIndex(p-&gt;speedup);ui-&gt;tableWidget-&gt;setCellWidget(5, 1, itemWidget); 获取单元格数据：1.自带item；2.自定义控件item 1234// 如果是一个text itemm_pid.gamma = ui-&gt;tableWidget-&gt;item(row, 1)-&gt;text().toFloat();// 如果是一个widget itemm_pid.type = qobject_cast&lt;QComboBox *&gt;(ui-&gt;tableWidget-&gt;cellWidget(row, 1))-&gt;currentIndex(); 单元格改变 123connect(ui-&gt;tableWidget, &amp;QTableWidget::cellChanged, this, [=](int row, int column) &#123; this-&gt;onCellChanged(row, column);&#125;); 禁止单元格多选 1ui-&gt;tableWidget-&gt;setSelectionMode(QAbstractItemView::SingleSelection); 滚动条水平滚动条：一般都是设置为关闭，开启的话比较丑陋 垂直滚动条：自带的比较丑，如果开启的话需要自定义一下样式表 滚动条样式参考 1234567// 水平滚动条ui-&gt;tableWidget-&gt;horizontalScrollBar()-&gt;setStyleSheet(&quot;QScrollBar&#123;background:rgb(43, 44, 49);height:20px;border: 1px solid rgb(43, 44, 49);&#125;\\QScrollBar::handle&#123;border: 1px solid rgb(62 ,73 ,84);&#125;&quot;);// 垂直滚动条ui-&gt;tableWidget-&gt;verticalScrollBar()-&gt;setStyleSheet(&quot;QScrollBar&#123;background:rgb(43, 44, 49);width:20px;border: 1px solid rgb(43, 44, 49);&#125;\\QScrollBar::handle&#123;border: 1px solid rgb(62 ,73 ,84);&#125;&quot;); 问题问题一点击单元格的时候，整个表格可能会有左右偏移的现象 这是整个滑动区域的宽度（所有的列宽和）大于表格的宽度导致的漂移，需要：1.指定列宽；2.固定表头列宽 12345678910int width = ui-&gt;tableWidget1-&gt;width() / 2 - 1;for (int i = 0; i &lt; ui-&gt;tableWidget1-&gt;columnCount(); ++i) &#123; ui-&gt;tableWidget1-&gt;horizontalHeader()-&gt;setSectionResizeMode(i, QHeaderView::Fixed); ui-&gt;tableWidget1-&gt;setColumnWidth(i, width);&#125;for (int i = 0; i &lt; ui-&gt;tableWidget2-&gt;columnCount(); ++i) &#123; ui-&gt;tableWidget2-&gt;horizontalHeader()-&gt;setSectionResizeMode(i, QHeaderView::Fixed); ui-&gt;tableWidget2-&gt;setColumnWidth(i, width);&#125; 上下偏移也与此同理，只要不超过表格控件的高度就行 问题二编辑动作的捕获：有cellChanged和closeEditor两个信号，前者是单元格内容发生变化时触发，但这个当控件新建时也会触发；如果想要单纯的捕获编辑动作本身，建议用后者 12345connect(ui-&gt;tableWidget-&gt;itemDelegate(), &amp;QAbstractItemDelegate::closeEditor, this, [=]() &#123; int row = ui-&gt;tableWidget-&gt;currentRow(); int column = ui-&gt;tableWidget-&gt;currentColumn(); this-&gt;onCellChanged(row, column);&#125;); 如果单元格插入了一些自定义的控件，例如QComboBox，需要统一一个专门处理单元格的函数，将row和column的参数传到同一的接口处理 123456789itemWidget = new QComboBox;itemWidget-&gt;addItem(&quot;禁用&quot;);itemWidget-&gt;addItem(&quot;固定时间&quot;);itemWidget-&gt;addItem(&quot;固定坡度&quot;);itemWidget-&gt;setCurrentIndex(p-&gt;rampMode);ui-&gt;tableWidget-&gt;setCellWidget(6, 1, itemWidget);connect(itemWidget, QOverload&lt;int&gt;::of(&amp;QComboBox::currentIndexChanged), this, [=](int) &#123; this-&gt;onCellChanged(6, 1);&#125;);","tags":["Qt","上位机","表格"],"categories":["程序设计"]},{"title":"开发板LED电路问题定位","path":"//board-led-problem.html","content":"背景淘宝买的RK3399开发板的电源LED1突然不亮了，刚开始被吓到以为烧坏了，但是开发板上电没有问题，在给客服投诉之前秉持着专业的精神给它做了个分析 电路图LED1串联了一个10kΩ的电阻，这个电路图贼简单，电阻主要是分压限流的作用，这个LED是红色的 LED的正常工作电压电流参考（电流大小无非是亮度强弱的问题，实际只要偏置电压给够就行） 颜色 电压 电流 红色 1.8-2.2V 20mA 绿色 2.0-2.4V 20mA 蓝色 3-4V 20mA 白色 3-3.4V 20mA 万用表旁边的红光LED2正常点亮，量了一下电压，大概在1.8V左右，这个正好可以作为对比 再量一下LED1的电压，测量值为5V，说明分压的电阻根本没有电流通过，LED1内部已经开路了 解决办法手动更换、焊接一个红光LED，只能自己掏钱买一个LED灯了","tags":["LED","硬件","RK3399"],"categories":["嵌入式"]},{"title":"关于千年虫问题的思考","path":"//y2k-problem-thinking.html","content":"背景千年虫问题（Y2K Problem），又称“2000年问题”或“Y2K漏洞”，是指在20世纪的计算机系统中，年份通常只用两位数字表示（例如“98”代表1998年），当时间从1999年12月31日跨入2000年1月1日时，系统可能会将“00”错误地识别为1900年，从而导致计算机程序出现逻辑错误或崩溃。 介绍最近在做嵌入式自动化设备开发遇到一个时间戳的问题，要用这个时间戳保存一些设备信息、运行状态信息、波形数据、文件信息，时间精度要求1ms，下位机是没有RTC的！因为单片机是32位的，所以自然而然地想到用uint32_t来表示这个时间戳，但认真想想这个时间戳其实是有一些漏洞在里边的，好比如上面介绍的千年虫问题 uint32_t我们计算一下uint32_t变量保存的毫秒最大能存储多少天 uint64_t我们计算一下uint64_t变量保存的毫秒最大能存储多少天 总结综上，我最后选择了uint64_t作为时间戳的存储变量类型，因为自动化设备是一年365天不停机的，如果用uint32_t，设备隔了50天就复位时间戳了，这个肯定不能满足要求！","tags":["时间戳","千年虫"],"categories":["程序设计"]},{"title":"QtCreator快捷键合集","path":"//qtcreator-shortcuts.html","content":"前言QtCreator是一款跨平台的IDE，专为Qt开发设计，支持C/C++/JS/Python编程，支持设备远程调试，支持代码高亮，集成帮助文档，原生支持cmake和git，确实是一款朴实而又强大的集成开发环境，让人有种爱不释手的感觉 快捷键 功能 按键组合 打开文件 Ctrl + O 关闭文件 Ctrl + W 关闭所有文件 Ctrl + Shift + W 保存所有文件 Ctrl + Shift + S 编译所有工程 Ctrl + Shift + B 编译当前工程 Ctrl + B 运行 Ctrl + R 切换构建模式 Ctrl + T 开始调试 F5 中断运行 F5 单步跳过 F10 单步进入 F11 单步跳出 Shift + F11 切换断点 F9 接口帮助 F1 + F1（两次F1） 注释代码 &#x2F; 解除注释 Ctrl + &#x2F; 查看粘贴板 Ctrl + Shift + V 复制 Ctrl + C 粘贴 Ctrl + V 剪切 Ctrl + X 切换书签 Ctrl + M 自动缩进 Ctrl + Shift + I 打开左侧栏 Alt + 0 打开右侧栏 Alt + Shift + 0 上下分割窗口 Ctrl + E + 2 左右分割窗口 Ctrl + E + 3 窗口复原 Ctrl + E + 1 退出软件 Ctrl + Q 字符转大写 Alt + Shift + U 字符转小写 Alt + U 迅速格式化 Ctrl + I 定位到某一行代码 Ctrl + L 在代码文件中检索（支持c、f、m等指令） Ctrl + K 帮助文档定位到索引器 Alt + L 切换编辑模式 Ctrl + 1，2，3，4，5 切换控制台功能 Alt + 1，2，3，4，5，6，7，8 快速检索文件引用出处 Ctrl + Shift + U 快速修改同一作用域内所有的相同命名的变量 Ctrl + Shift + R 切换源文件、头文件 F4","tags":["Qt","快捷键","QtCreator","IDE"],"categories":["开发工具"]},{"title":"按钮Tab分栏功能实现","path":"//exclusive-tab-buttons.html","content":"前言我想实现一个左侧的上下的Tab分栏功能，看了Qt官方的文档好像没有合适的解决方案，于是自己自定义了一个 介绍在上位机开发中，如果想要做一个侧边栏点击切换分页的功能，大家都想到用一组QPushButton和自定义的QWidget来做 然后我们用样式表修饰QPushButton，同时用QWidget自定一些Pages 123456789101112131415QPushButton &#123; font-size: 18px; / color: white; background-color: rgb(10,88,163); border: 2px solid rgb(114,188,51); text-align: left; padding-left: 10px; font-weight: bold;&#125;QPushButton:focus &#123; background-color: rgb(41,51,57);\tcolor: rgb(114,188,51);\tborder-width: 4px;&#125; 用信号和槽把Buttons和Pages绑定起来，很快，一个切换分栏的用户界面就大功告成了 123456789101112131415connect(ui-&gt;button1, &amp;QPushButton::clicked, this, [=]() &#123; page1-&gt;setVisible(true);&#125;);connect(ui-&gt;button2, &amp;QPushButton::clicked, this, [=]() &#123; page2-&gt;setVisible(true);&#125;);connect(ui-&gt;button3, &amp;QPushButton::clicked, this, [=]() &#123; page3-&gt;setVisible(true);&#125;);connect(ui-&gt;button4, &amp;QPushButton::clicked, this, [=]() &#123; page4-&gt;setVisible(true);&#125;); 问题这样做的思路并没有错，但是会遇到一些问题，就是Pages里边如果有一些强焦点属性的控件，很容易把左侧栏的Buttons焦点拿走，导致focus样式失效！问题的关键在于侧边栏和分页是在同一个界面下的，Buttons的焦点是很容易丧失的 解决引入QButtonGroup功能，确保每个Button都是exclusive的 12345678m_group = new QButtonGroup(this);m_group-&gt;setExclusive(true);m_group-&gt;addButton(ui-&gt;alarm);m_group-&gt;addButton(ui-&gt;operate);m_group-&gt;addButton(ui-&gt;communication);m_group-&gt;addButton(ui-&gt;systemLearn);m_group-&gt;addButton(ui-&gt;conductanceCurves);m_group-&gt;addButton(ui-&gt;about); 在Button切换焦点的时候变更样式，捕获QButtonGroup的buttonClicked信号 12345678910111213141516171819202122connect(m_group, QOverload&lt;QAbstractButton *&gt;::of(&amp;QButtonGroup::buttonClicked), [=](QAbstractButton *button)&#123; for(auto &amp;but : m_group-&gt;buttons()) &#123; if(button != but) &#123; but-&gt;setStyleSheet(&quot;QPushButton &#123; font-size: 18px;\\ color: white;\\ background-color: rgb(10,88,163);\\ border: 2px solid rgb(114,188,51);\\ text-align: left;\\ padding-left: 10px;\\ font-weight: bold;&#125;&quot;); &#125; else &#123; but-&gt;setStyleSheet(&quot;QPushButton &#123; font-size: 18px;\\ color: rgb(114,188,51);\\ background-color: rgb(41,51,57);\\ border: 4px solid rgb(114,188,51);\\ text-align: left;\\ padding-left: 10px;\\ font-weight: bold;&#125;&quot;); &#125; &#125;&#125;); 直接不要样式表里边的focus属性了，大致的实现效果如下 当然，要记得默认一个最开始的Button 12345678ui-&gt;operate-&gt;setFocus();ui-&gt;operate-&gt;setStyleSheet(&quot;QPushButton &#123; font-size: 18px;\\ color: rgb(114,188,51);\\ background-color: rgb(41,51,57);\\ border: 4px solid rgb(114,188,51);\\ text-align: left;\\ padding-left: 10px;\\ font-weight: bold;&#125;&quot;); 总结样式表能解决大部分问题，但是一些边边角角的东西需要自己琢磨（写C++代码）实现","tags":["Qt","GUI","按键"],"categories":["程序设计"]},{"title":"开源软件推荐指南","path":"//open-software-guide.html","content":"介绍开源，极大促进了软件行业的繁荣；知识共享、技术迭代、协同工作成了信息时代的主流；开源不是免费，用户仍可以选择为技术服务买单 视频播放VLC Media Player，一款开源、强大的音视频播放软件，支持网络播放源 图像编辑GIMP是Photoshop的绝佳替代品，支持多个操作系统平台，开源、小巧、免费，日常修图需求都可以满足 文本编辑器VSCode是一款功能堪比IDE的文本编辑器，它能无缝切换嵌入式、Web、PC、移动端的开发环境，而且还开源和跨平台，支持多种开发插件，像常见的cmake、git、gdb、stlink都能集成 nodepad++，推荐它的原因是因为小巧玲珑，界面干净整洁，而且它从不卡顿 开源的IDEQtCreator是Qt官方出品的集成开发环境，支持嵌入式、移动端、PC开发，甚至写驱动代码也没有问题，对cmake的支持堪称一流！代码高亮、文档查看也相当不错，支持多个操作系统平台，比VS更轻量级 文档系统MrDoc是基于Python开发的在线文档系统，适合作为个人和中小型团队的私有云文档、云笔记和知识管理工具，致力于成为优秀的私有化在线文档部署方案 开源云盘openmediavault，这个本质是一个NAS方案，可以用来存储私人的数据，通过安装个性化的app和插件实现各种数据存储服务 项目管理Overview - Redmine是一款工作在web端的项目管理软件，支持进度查看、工时登记等功能 缺陷管理Bugzilla的界面简单，但是功能齐全，支持Bug的追溯查看，缺陷评论、邮件服务也不错 办公套件LibreOffice，如果厌倦了WPS和MS office的广告和雍总，这个软件也是一个不错的选择！正真自由免费的全能办公套件，以前安装Ubuntu都会自带这个办公套件 网络调试wireshark是一款强大的网络数据可视化工具，能抓取多种网络接口（以太网、WLAN、CAN）的数据包并将数据可视化，帮助我们更好地调试和分析网络通信的过程以及异常情况 高效调试SavvyCAN是一款小巧强大的CAN分析诊断工具，支持CAN&#x2F;CANFD数据表格可视化、支持DBC协议解析、支持数据过滤、UDS协议扫描与解码、支持脚本接口扩展功能，是汽车电子工作者的必备神器！","tags":["开源"],"categories":["方法论"]},{"title":"RT-Thread拉新工程编译报错","path":"//rt-thread-new-project-compile-problem.html","content":"问题一拉新RT-Thread开源代码后发现编译出错，rt_vsnprintf库编译有问题 1.\\build\\keil\\Obj\\rt-thread.axf: Error: L6218E: Undefined symbol rt_vsnprintf (referred from kstdio.o). 打开menuconfig ：RT-Thread Kernel → klibc options → rt_vsnprintf options，开启以下选项 问题二rt_vsscanf库编译问题 1.\\build\\keil\\Obj\\rt-thread.axf: Error: L6218E: Undefined symbol rt_vsscanf (referred from kstdio.o). 打开menuconfig ：RT-Thread Kernel → klibc options → rt_vsscanf options，开启以下选项 总结这两个问题是因为RT-Thread改了rt_vsnprintf和rt_vsscanf两个库的链接方式：做成了开关的配置形式","tags":["RT-Thread"],"categories":["嵌入式"]},{"title":"cmake自定义软件信息","path":"//cmake-define-software-info.html","content":"用法版本号 1add_definitions(-DSOFTWARE_VERSION=&quot;1.0.2&quot;) 编译类型 1add_definitions(-DBUILD_TYPE=&quot;Debug&quot;) 作者信息 1add_definitions(-DAUTHOR=&quot;hywing&quot;) 公司 1add_definitions(-DCOMPANY=&quot;iotstuff&quot;) 编译生成时间 12string(TIMESTAMP CURRENT_TIME &quot;%Y-%m-%d %H:%M:%S&quot;)add_definitions(-DBUILD_DATE=&quot;$&#123;CURRENT_TIME&#125;&quot;) 以上信息在cmake中通过add_definitions关键字生成相应的宏定义，在代码中只要直接使用这些宏就可以了 12ui-&gt;version-&gt;setText(SOFTWARE_VERSION);ui-&gt;buildDate-&gt;setText(BUILD_DATE); 如果你在一个工程代码中点击找不到宏定义的出处，那么它大概率在工程文件中被定义了！ 注意如果你要发布版本，这种做法需要每次编译打包前执行一下cmake，否则你的时间信息有可能不是最新的！","tags":["cmake"],"categories":["程序设计"]},{"title":"stm32移植LCD2002驱动","path":"//stm32-lcd2002-driver.html","content":"介绍LCD2002支持20X2个字符串显示，引脚功能和读写时序跟LCD1602都很像 LCD类型：字符点阵 点 阵 数：20×2 外形尺寸：116.0mm×37.0mm（长宽） 视域尺寸：83.0mm×18.6mm 点 距 离：0.05mm×0.05mm 点 大 小：0.65mm×0.6mm 控 制 器：SPLC780 玻璃类型：FSTN或STN 显示内容：20（例）×2（行） 背光类型：LED白光（白底黑字，蓝底白字） 数据传输：并口 工作电压：5V LCD2002的应用场景有： 物联网数据采集端显示：展示传感器数值 工业自动化：电机控制展示信息 嵌入式场景：智能家居终端设备 引脚LCD2002有16Pin引脚，每个引脚功能如下 管脚号 符号 功能 1 Vss 电源地（ GND） 2 Vdd 电源电压(+5V) 3 V0 LCD 驱动电压(可调) 4 RS 寄存器选择输入端，输入 MPU 选择模块内部寄存器类型信号：RS&#x3D;0，当 MPU 进行写模块操作，指向指令寄存器；当 MPU 进行读模块操作，指向地址计数器；RS&#x3D;1，无论 MPU 读操作还是写操作，均指向数据寄存器 5 R&#x2F;W 读写控制输入端，输入 MPU 选择读&#x2F;写模块操作信号：R&#x2F;W&#x3D;0 读操作； R&#x2F;W&#x3D;1 写操作 6 E 使能信号输入端，输入 MPU 读&#x2F;写模块操作使能信号：读操作时，高电平有效；写操作时，下降沿有效 7 DB0 数据输入&#x2F;输出口， MPU 与模块之间的数据传送通道 8 DB1 数据输入&#x2F;输出口， MPU 与模块之间的数据传送通道 9 DB2 数据输入&#x2F;输出口， MPU 与模块之间的数据传送通道 10 DB3 数据输入&#x2F;输出口， MPU 与模块之间的数据传送通道 11 DB4 数据输入&#x2F;输出口， MPU 与模块之间的数据传送通道 12 DB5 数据输入&#x2F;输出口， MPU 与模块之间的数据传送通道 13 DB6 数据输入&#x2F;输出口， MPU 与模块之间的数据传送通道 14 DB7 数据输入&#x2F;输出口， MPU 与模块之间的数据传送通道 15 A 背光的正端+5V 16 K 背光的负端 0V 原装的LCD并没有焊接排针，需要自己手动焊接 移植引脚定义，一般只需要用到以下13个Pin 12345678910111213#define LCD_RS_PIN GET_PIN(A, 4)#define LCD_RW_PIN GET_PIN(A, 5)#define LCD_E_PIN GET_PIN(A, 6)#define LCD_D0_PIN GET_PIN(A, 7)#define LCD_D1_PIN GET_PIN(B, 0)#define LCD_D2_PIN GET_PIN(B, 1)#define LCD_D3_PIN GET_PIN(B, 2)#define LCD_D4_PIN GET_PIN(B, 10)#define LCD_D5_PIN GET_PIN(B, 11)#define LCD_D6_PIN GET_PIN(B, 12)#define LCD_D7_PIN GET_PIN(B, 13)#define LCD_V0 GET_PIN(B, 4)#define LCD_BL GET_PIN(B, 5) 初始化LCD2002引脚 12345678910111213141516void LCD_GPIO_Init() &#123; rt_pin_mode(LCD_V0, PIN_MODE_OUTPUT); rt_pin_mode(LCD_BL, PIN_MODE_OUTPUT); rt_pin_mode(LCD_RS_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LCD_RW_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LCD_E_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LCD_D0_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LCD_D1_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LCD_D2_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LCD_D3_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LCD_D4_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LCD_D5_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LCD_D6_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LCD_D7_PIN, PIN_MODE_OUTPUT);&#125; 写数据 1234567891011121314151617void LCD_WriteData(uint8_t data) &#123; rt_pin_write(LCD_RS_PIN, PIN_HIGH); rt_pin_write(LCD_RW_PIN, PIN_LOW); rt_pin_write(LCD_E_PIN, PIN_LOW); rt_pin_write(LCD_D0_PIN, (data &amp; 0x01) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D1_PIN, (data &amp; 0x02) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D2_PIN, (data &amp; 0x04) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D3_PIN, (data &amp; 0x08) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D4_PIN, (data &amp; 0x10) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D5_PIN, (data &amp; 0x20) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D6_PIN, (data &amp; 0x40) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D7_PIN, (data &amp; 0x80) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_E_PIN, PIN_HIGH); rt_thread_mdelay(5); rt_pin_write(LCD_E_PIN, PIN_LOW); &#125; 写命令 1234567891011121314151617void LCD_WriteCommand(uint8_t command) &#123; rt_pin_write(LCD_RS_PIN, PIN_LOW); rt_pin_write(LCD_RW_PIN, PIN_LOW); rt_pin_write(LCD_E_PIN, PIN_LOW); rt_pin_write(LCD_D0_PIN, (command &amp; 0x01) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D1_PIN, (command &amp; 0x02) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D2_PIN, (command &amp; 0x04) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D3_PIN, (command &amp; 0x08) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D4_PIN, (command &amp; 0x10) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D5_PIN, (command &amp; 0x20) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D6_PIN, (command &amp; 0x40) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_D7_PIN, (command &amp; 0x80) ? PIN_HIGH : PIN_LOW); rt_pin_write(LCD_E_PIN, PIN_HIGH); rt_thread_mdelay(5); rt_pin_write(LCD_E_PIN, PIN_LOW); &#125; 设置光标位置 12345678void LCD_SetCursor(uint8_t col, uint8_t row) &#123; uint8_t address = col; if (row == 1) &#123; address += 0x40; &#125; LCD_WriteCommand(0x80 | address); &#125; 绘制字符，需要配合LCD_SetCursor接口使用 123456void LCD_Print(char* str) &#123; while (*str) &#123; LCD_WriteData(*str++); &#125;&#125; LCD初始化，设置清屏、光标位置自动累加等 12345678910111213void LCD_Init() &#123; rt_pin_write(LCD_V0, PIN_HIGH); rt_pin_write(LCD_BL, PIN_HIGH); rt_thread_mdelay(15); LCD_WriteCommand(0x38); rt_thread_mdelay(5); LCD_WriteCommand(0x0c); rt_thread_mdelay(5); LCD_WriteCommand(0x06); rt_thread_mdelay(5); LCD_WriteCommand(0x01); rt_thread_mdelay(5);&#125; 测试用例，在屏幕第一行显示Levitation字样 123456789101112131415161718192021222324252627282930static void lcd2002_entry(void* parameter) &#123;\tLCD_GPIO_Init(); LCD_Init();\tLCD_WriteCommand( 0x80 ); LCD_SetCursor(5, 0); LCD_Print(&quot;Levitation&quot;); while(1) &#123; rt_thread_mdelay(500); &#125;&#125;int main()&#123;\t// lcd2002 rt_thread_t lcd2002_thread = rt_thread_create(&quot;lcd2002&quot;, lcd2002_entry, RT_NULL, 512, 21, 20); if (lcd2002_thread != RT_NULL) &#123; rt_thread_startup(lcd2002_thread); &#125; while (1) &#123; rt_pin_write(LED0_PIN, PIN_HIGH); rt_thread_mdelay(10); rt_pin_write(LED0_PIN, PIN_LOW); rt_thread_mdelay(10); &#125; return RT_EOK;&#125; 显示效果 总结买的是5V供电的LCD2002，但它的数据引脚是可以兼容3.3V的GPIO的，详细可参考数据手册关于芯片引脚电气特性的说明 立创上面汉昇的LCD2002背光引脚BLK、BLA的说明是错误的 延申BLA背光和V0对比度通过使用1KHz方波改变占空比可以实现背光和对比度的调节，可以节约硬件Bom成本，减少电位器的使用 对比度调节效果 亮度调节效果","tags":["stm32","LCD2002"],"categories":["嵌入式"]},{"title":"下位机没有RTC模块如何做时间同步","path":"//lower-device-time-sync.html","content":"如题：开发环境下，如果stm32没有板载RTC模块，怎么跟上位机做时间同步呢？ 如果有以太网，可以考虑移植NTP协议，借用网络中比较可靠的时钟源作为时间参考 如果有串口，可以考虑使用GNSS模块，获取NMEA-0183卫星时间作为时间参考，GNSS也带有PPS做时间校准 如果跟上位机建立通信连接，可以采用上位机时刻+定期心跳机制获取一个大致的时间参考 如果跟PLC建立EtherCAT通信，也可以用PLC的时间做参考","tags":["下位机","RTC","时间同步"],"categories":["嵌入式"]},{"title":"msvc与g++编译器字符编码问题","path":"//msvc-g++-coder-problem.html","content":"介绍同一份代码，都是用utf-8保存的文件，用g++编译中文是不会乱码的，换成msvc2017编译就乱码了 解决在包含中文的源文件头部添加以下代码，设置字符编码为utf-8 123#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1600)# pragma execution_character_set(&quot;utf-8&quot;)#endif","tags":["msvc","g++","编译器","字符编码"],"categories":["程序设计"]},{"title":"git仓库重定向","path":"//git-repository.html","content":"前言在开发过程，如果想把代码从某一个仓库转移到另外一个仓库，比如，你现在在gitee上面有一个zhd-desktop的仓库，后面你不想要了，你想把它放到GitHub上面，怎么办才能保留原来的提交信息和分支呢？ 解决命令行 在原来的仓库里边添加远端仓库链接 1git remote add upstream https://github.com/hywing/zhd-desktop.git 往upstream推送develop分支 1git push upstream develop -f tortoiseGit 先添加远程仓库 选择远程仓库后push","tags":["git","upstream"],"categories":["开发工具"]},{"title":"信号和槽函数重载写法参考","path":"//qt-signal-slot-overload.html","content":"信号重载最常见的重载信号就是QComboBox::currentIndexChanged，它有int和const QString &amp;两种重载参数 12345678910111213connect(ui-&gt;algorithm, QOverload&lt;int&gt;::of(&amp;QComboBox::currentIndexChanged), this, [=](int index) &#123; if(index == 0) &#123; this-&gt;initTable(PID); &#125; else &#123; this-&gt;initTable(Model); &#125; emit this-&gt;changeAlgorithm(index);&#125;);connect(ui-&gt;algorithm, QOverload&lt;const QString &amp;&gt;::of(&amp;QComboBox::currentIndexChanged), this, [=](const QString &amp;text) &#123; qDebug() &lt;&lt; text;&#125;); 槽函数重载以传递自定义参数类型为例，自定义结构体需要注册成Qt的元数据类型 123456789101112131415#pragma pack (4)typedef struct &#123; ...&#125; TAlgorithmModel;#pragma pack ()Q_DECLARE_METATYPE(TAlgorithmModel *)#pragma pack (4)typedef struct &#123;\t...&#125; TAlgorithmPid;#pragma pack ()Q_DECLARE_METATYPE(TAlgorithmPid *) 发送方信号 123// 原始信号void NetworkManager::updateModel(const TAlgorithmModel *);void NetworkManager::updatePid(const TAlgorithmPid *); 接收方槽函数重载 123// 重载槽函数void OperatePage::onUpdateTable(const TAlgorithmModel *p);void OperatePage::onUpdateTable(const TAlgorithmPid *p); 信号和槽写法参考 12connect(NetworkManager::getInstance(), &amp;NetworkManager::updateModel, operate, QOverload&lt;const TAlgorithmModel *&gt;::of(&amp;OperatePage::onUpdateTable));connect(NetworkManager::getInstance(), &amp;NetworkManager::updatePid, operate, QOverload&lt;const TAlgorithmPid *&gt;::of(&amp;OperatePage::onUpdateTable));","tags":["Qt","信号","槽","重载"],"categories":["程序设计"]},{"title":"long数据类型跨平台问题","path":"//long-data-size.html","content":"示例代码以下代码用于打印long类型数据的大小 1234567#include &lt;iostream&gt;int main()&#123;\tstd::cout &lt;&lt; &quot;size of long : &quot; &lt;&lt; sizeof(long) &lt;&lt; std::endl;\treturn 0;&#125; WindowsQt5.12.9 MSVC2017 64bit编译器：long -&gt; 32位 LinuxQt5.12.9 g++9.4.0编译器：long -&gt; 64位 建议跨平台程序尽量采用跨平台库，如Boost 123456789101112131415161718192021222324252627282930313233343536373839namespace boost&#123; using ::int8_t; using ::int_least8_t; using ::int_fast8_t; using ::uint8_t; using ::uint_least8_t; using ::uint_fast8_t; using ::int16_t; using ::int_least16_t; using ::int_fast16_t; using ::uint16_t; using ::uint_least16_t; using ::uint_fast16_t; using ::int32_t; using ::int_least32_t; using ::int_fast32_t; using ::uint32_t; using ::uint_least32_t; using ::uint_fast32_t;# ifndef BOOST_NO_INT64_T using ::int64_t; using ::int_least64_t; using ::int_fast64_t; using ::uint64_t; using ::uint_least64_t; using ::uint_fast64_t;# endif using ::intmax_t; using ::uintmax_t;&#125; 或者stdint.h 1234567891011121314151617181920212223242526272829typedef signed char int8_t;typedef short int16_t;typedef int int32_t;typedef long long int64_t;typedef unsigned char uint8_t;typedef unsigned short uint16_t;typedef unsigned int uint32_t;typedef unsigned long long uint64_t;typedef signed char int_least8_t;typedef short int_least16_t;typedef int int_least32_t;typedef long long int_least64_t;typedef unsigned char uint_least8_t;typedef unsigned short uint_least16_t;typedef unsigned int uint_least32_t;typedef unsigned long long uint_least64_t;typedef signed char int_fast8_t;typedef int int_fast16_t;typedef int int_fast32_t;typedef long long int_fast64_t;typedef unsigned char uint_fast8_t;typedef unsigned int uint_fast16_t;typedef unsigned int uint_fast32_t;typedef unsigned long long uint_fast64_t;typedef long long intmax_t;typedef unsigned long long uintmax_t;","tags":["linux","Windows","long","跨平台"],"categories":["程序设计"]},{"title":"Windows平台git clone文件路径太长报错","path":"//git-clone-url-too-long.html","content":"问题描述在Windows下拉取一些比较大的开源项目经常会提示文件路径太长（filename too long），然后死活都不成功 解决办法1.配置git 1git config --system core.longpaths true 2.修改文件C:\\Program Files\\Git\\etc\\gitconfig（需要以管理员身份打开） 12345[core]\tautocrlf = true\tfscache = true\tsymlinks = false\tlongpaths = true longpaths = true表示允许路径字符串超过260 3.输入命令查看 1git config --system core.longpaths 显示结果为true表示已经成功设置","tags":["git","Windows"],"categories":["程序设计"]},{"title":"ros2 foxy订阅话题问题","path":"//ros2-foxy-subscribe-problem.html","content":"代码片段这部分代码在galactic版本编译是OK的，可在foxy下编译就出了问题 123456789101112131415161718192021222324252627TeleopPanel::TeleopPanel(QWidget* parent) : rviz_common::Panel(parent), playRate_(1.0)&#123; signalPub_ = nh_-&gt;create_publisher&lt;std_msgs::msg::Int16&gt;(&quot;/pixel/lv/run_signal&quot;, 5); beginPub_ = nh_-&gt;create_publisher&lt;std_msgs::msg::Float32&gt;(&quot;/pixel/lv/begin_signal&quot;, 5); ratePub_ = nh_-&gt;create_publisher&lt;std_msgs::msg::Float32&gt;(&quot;/pixel/lv/rate_signal&quot;, 5); currTimeSub_ = nh_-&gt;create_subscription&lt;std_msgs::msg::String&gt;(&quot;/pixel/lv/current_time&quot;, 10, std::bind(&amp;TeleopPanel::CurrTimeSub, this, std::placeholders::_1)); selectPtSub_ = nh_-&gt;create_subscription&lt;sensor_msgs::msg::PointCloud2&gt;(&quot;/rviz_selected_points&quot;, 10, std::bind(&amp;TeleopPanel::SelectPtSub, this, std::placeholders::_1)); std::thread t(&amp;TeleopPanel::StartSpin, this); t.detach(); SetPanelLayout();&#125;void TeleopPanel::CurrTimeSub(const std_msgs::msg::String&amp; msg)&#123; QString currTime = QString::fromStdString(msg.data); currentTimeEditor_-&gt;setText(currTime);&#125;void TeleopPanel::SelectPtSub(const sensor_msgs::msg::PointCloud2&amp; msg)&#123; const auto ptsNum = msg.width; QString ptsNumQStr = QString::fromStdString(std::to_string(ptsNum)); selectPtsEditor_-&gt;setText(ptsNumQStr);&#125; 出错部分两个create_subscription调用出错 12currTimeSub_ = nh_-&gt;create_subscription&lt;std_msgs::msg::String&gt;(&quot;/pixel/lv/current_time&quot;, 10, std::bind(&amp;TeleopPanel::CurrTimeSub, this, std::placeholders::_1));selectPtSub_ = nh_-&gt;create_subscription&lt;sensor_msgs::msg::PointCloud2&gt;(&quot;/rviz_selected_points&quot;, 10, std::bind(&amp;TeleopPanel::SelectPtSub, this, std::placeholders::_1)); create_subscription函数原型 1234567891011std::shared_ptr&lt;SubscriptionT&gt; create_subscription( const std::string &amp; topic_name, const rclcpp::QoS &amp; qos, CallbackT &amp;&amp; callback, const SubscriptionOptionsWithAllocator&lt;AllocatorT&gt; &amp; options = SubscriptionOptionsWithAllocator&lt;AllocatorT&gt;(), typename MessageMemoryStrategyT::SharedPtr msg_mem_strat = ( MessageMemoryStrategyT::create_default() ) ); 出错内容 下面是其中一部分报错内容 12345678910111213141516// 报错一play_panel.cpp:26: error: no match for ‘operator=’ (operand types are ‘rclcpp::Subscription&lt;sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt; &gt;::SharedPtr’ &#123;aka ‘std::shared_ptr&lt;rclcpp::Subscription&lt;sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt; &gt; &gt;’&#125; and ‘std::shared_ptr&lt;rclcpp::Subscription&lt;const sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt;&amp;, std::allocator&lt;void&gt;, rclcpp::message_memory_strategy::MessageMemoryStrategy&lt;const sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt;&amp;, std::allocator&lt;void&gt; &gt; &gt; &gt;’) 26 | selectPtSub_ = nh_-&gt;create_subscription&lt;sensor_msgs::msg::PointCloud2&gt;(&quot;/rviz_selected_points&quot;, 10, std::bind(&amp;TeleopPanel::SelectPtSub, this, std::placeholders::_1)); | ^// 报错二play_panel.cpp:26:25: error: no matching member function for call to &#x27;create_subscription&#x27;node_impl.hpp:91:7: note: candidate template ignored: substitution failure [with MessageT = sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt;, CallbackT = std::_Bind&lt;void (LidarViewRos2::RvizPlugin::TeleopPanel::*(LidarViewRos2::RvizPlugin::TeleopPanel *, std::_Placeholder&lt;1&gt;))(const sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt; &amp;)&gt;, AllocatorT = std::allocator&lt;void&gt;, CallbackMessageT = const sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt; &amp;, SubscriptionT = rclcpp::Subscription&lt;const sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt; &amp;, std::allocator&lt;void&gt;, rclcpp::message_memory_strategy::MessageMemoryStrategy&lt;const sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt; &amp;, std::allocator&lt;void&gt; &gt; &gt;, MessageMemoryStrategyT = rclcpp::message_memory_strategy::MessageMemoryStrategy&lt;const sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt; &amp;, std::allocator&lt;void&gt; &gt;]// 报错三/opt/ros/foxy/include/rclcpp/subscription_factory.hpp:97: error: no matching function for call to ‘rclcpp::AnySubscriptionCallback&lt;const sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt;&amp;, std::allocator&lt;void&gt; &gt;::set(std::_Bind&lt;void (LidarViewRos2::RvizPlugin::TeleopPanel::*(LidarViewRos2::RvizPlugin::TeleopPanel*, std::_Placeholder&lt;1&gt;))(const sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt;&amp;)&gt;)’ 97 | any_subscription_callback.set(std::forward&lt;CallbackT&gt;(callback)); | ^~~~~~~~~~~~~~~~~~~~~~~~~ // 报错四/usr/include/c++/9/ext/new_allocator.h:64: error: forming pointer to reference type ‘const sensor_msgs::msg::PointCloud2_&lt;std::allocator&lt;void&gt; &gt;&amp;’typedef const _Tp* const_pointer; 其实就是模板函数的原型不匹配导致的，CallbackT的模板参数需要传入指针类型才能正确解参数类型，传入引用类型是不对的 正确写法 只要把CurrTimeSub和SelectPtSub两个函数的原型修改一下（入参改成指针）就OK了 123456789101112void TeleopPanel::CurrTimeSub(const std_msgs::msg::String::SharedPtr msg)&#123; QString currTime = QString::fromStdString(msg-&gt;data); currentTimeEditor_-&gt;setText(currTime);&#125;void TeleopPanel::SelectPtSub(const sensor_msgs::msg::PointCloud2::SharedPtr msg)&#123; const auto ptsNum = msg-&gt;width; QString ptsNumQStr = QString::fromStdString(std::to_string(ptsNum)); selectPtsEditor_-&gt;setText(ptsNumQStr);&#125; 总结foxy和galactic及后续版本在create_subscription模板函数的实现有区别，移植的时候要注意兼容性，参考issue ros2 add arguments to callback - ROS Answers: Open Source Q&amp;A Forum","tags":["编译","ros2","foxy"],"categories":["程序设计"]},{"title":"各种编译模式的区别","path":"//complile-mode.html","content":"debug调试版本，带有完整的调试信息（函数、变量符号表、文件路径、行号），加载速度慢，体积大，比较适合在开发阶段使用 release发布版本，几乎没有调试信息，加载速度快（通常带有代码优化），体积小，一般在发布阶段使用 release with debug informationVisual Studio特有的编译模式，会带有一点点调试符号，但并不是所有函数行的断点都可以命中，而且调试信息也不完善，程序体积比release略大","tags":["编译"],"categories":["程序设计"]},{"title":"Windows应用发布时禁止cmd窗口弹出","path":"//windows-forbid-cmd.html","content":"解决很简单，就是在Release模式下告诉编译器：这是一个win32的app就行了 1234567if(CMAKE_BUILD_TYPE AND (CMAKE_BUILD_TYPE STREQUAL &quot;Release&quot;)) set(FLAG &quot;WIN32&quot;)else() set(FLAG &quot;&quot;)endif()add_executable(zhd-desktop $&#123;FLAG&#125; main.cpp)","tags":["上位机","Windows","cmake","cmd","release"],"categories":["程序设计"]},{"title":"C++ string与QString中文字符转换关系","path":"//cpp-string-to-qstring.html","content":"1.从QString到std::string12std::string oldString = &quot;你好，hello world&quot;;QString newString = QString::fromLocal8Bit(oldString.c_str()) 2.从std::string到QString12QString oldString = &quot;你好，hello world&quot;;std::string newString = std::string((const char *)oldString.toLocal8Bit().constData()); 3.从std::string到char *12345678910111213141516171819202122char *wchar2char(const wchar_t* source)&#123; char * data; int len= WideCharToMultiByte( CP_ACP ,0,source ,wcslen( source ), nullptr,0, nullptr ,nullptr); data= new char[len+1]; WideCharToMultiByte( CP_ACP ,0,source ,wcslen( source ),data,len, nullptr ,nullptr); data[len]= &#x27;\\0&#x27;; return data;&#125;const char *stringToChar(const std::string&amp; str)&#123; std::wstring wstr = L&quot;&quot;; int len = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), str.size(), nullptr, 0); wchar_t* wchar = new wchar_t[len + 1]; MultiByteToWideChar(CP_UTF8, 0, str.c_str(), str.size(), wchar, len); wchar[len] = &#x27;\\0&#x27;; wstr.append(wchar); const char *data = wchar2char(wchar); delete[] wchar; return data;&#125;","tags":["C++","string","QString","中文字符"],"categories":["程序设计"]},{"title":"n阶行列式求解","path":"//n-det-calculation.html","content":"前言笔者最近在学习线性代数，写了一个求解n阶行列式的程序，拿出来给大家分享借鉴一下。 实现用递归的方法求解n阶行列式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126/*\t1.名字：\tdeterminant.c 2.功能：\t求解n阶行列式值 3.编者：\tHeavenMo &lt;1621326181@qq.com&gt; 4.时间：\t2015-10-2 22:42 5.叙述：\t递归法实现n阶行列式的求解 6.申明：\tWin 8.1 pro / GCC 4.8.1编译器亲测通过 7.结构： a)main函数部分完成行列式的输入操作 b)det函数完成行列式的值的返回 c)det函数中，将原来的n阶行列式不断的递归分解， 如，n阶矩阵分解为n个(n-1)阶余子矩阵，(n-1)阶分解成(n-1)个(n-2)阶余子矩阵， ...，以此类推 d)递归至2阶时，计算2阶行列式的值，并返回给上一层，...， 以此类推*///有关头文件的包含，因为要用到动态内存的分配，所以包含stdlib.h# include &lt;stdio.h&gt;# include &lt;stdlib.h&gt;//定制数据类型，方便修改typedef int data_type;typedef unsigned int uint;//计算n阶行列式的函数声明data_type det(data_type *p, uint n);int main(void)&#123;\t//n为行列式的阶数，i，n，m为非负值，所以定义为uint\tuint i, n, m;\t//提示输入行列式的阶数\tprintf(&quot;请输入行列式的阶数: &quot;);\tscanf(&quot;%u&quot;, &amp;n);\tm = n * n;\t//程序的关键所在，将n阶行列式看成是一个长度是n*n的一维数组，m为数组的长度\tdata_type *p = (data_type *)calloc(m, sizeof(data_type));\tprintf(&quot;请输入行列式的元素值: &quot;);\tfor(i = 0; i &lt; m; i++)\t&#123; scanf(&quot;%d&quot;, p + i);\t&#125;\tprintf(&quot; 所求行列式的值 = %d &quot;, det(p, n)); //释放相应的内存\tfree(p);\treturn 0;&#125;//p指向长度为n*n的数组，n为行列式的阶数data_type det(data_type *p, uint n)&#123;\t//n = 1时的情况\tif(n == 1)\t&#123; return *p;\t&#125;\t//递归基准\tif(n == 2)\t&#123; return ((*p) * (*(p + 3)) - (*(p + 1)) * (*(p + 2)));\t&#125;\t//m1:当前行列式的元素个数，m2：分解后的行列式的元素个数\tuint i, j, k, m1, m2;\tm1 = n * n;\tm2 = (n - 1) * (n - 1); //为分配后的n个n-1阶的行列式分配内存的基址\tdata_type *p_list[n];\tfor(i = 0; i &lt; n; i++)\t&#123; p_list[i] = (data_type *)calloc(m2, sizeof(data_type));\t&#125;\t//关键一步，筛选出代数余子矩阵，i(0 - n-1)：原矩阵可以分解为n个n-1阶代数余子矩阵\tfor(i = 0; i &lt; n; i++)\t&#123; //j = n意为筛选元素要从第二行开始，k变量统计代数余子矩阵的元素个数 for(j = n, k = 0; j &lt; m1; j++) &#123; //考察原矩阵与余子矩阵的关系，构造余子矩阵 if(j % n != i) &#123; *(p_list[i] + k) = *(p + j); k++; &#125; &#125;\t&#125; //根据递推公式求和，sign为代数余子式的符号，与行数(其实是第一行)，列数有关\tint sign = -1;\tdata_type sum = 0;\tfor(i = 0; i &lt; n; i++)\t&#123; sign *= -1; //调用函数，通过对第一行的各元素与相应的代数余子矩阵的行列式值之积求和，实现递归求值 sum += sign * (*(p + i)) * det(p_list[i], n - 1);\t&#125; //返回函数值\treturn sum;&#125; 运行附上cmd运行结果：","tags":["n阶行列式","线性代数","算法"],"categories":["学科"]},{"title":"cmake生成应用程序logo","path":"//cmake-app-logo.html","content":"logo.ico去专门的ico图标网站下载，也可以通过普通的图片转换：png-to-ico resource.rc这个用于指定要到的图片文件 1IDI_ICON1 ICON &quot;logo.ico&quot; CMakeLists.txt在cmake文件里边加上rc文件 1add_executable($&#123;PROJECT_NAME&#125; main.cpp resource.rc)","tags":["上位机","cmake","logo"],"categories":["开发工具"]},{"title":"cmake之find_library问题","path":"//cmake-find-library.html","content":"附上工程源码库文件工程PS：这个工程用于导出库 CMakeLists.txt 1234567891011121314cmake_minimum_required(VERSION 3.5)project(demo LANGUAGES CXX)set(CMAKE_INCLUDE_CURRENT_DIR ON)set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED ON)add_library(demo SHARED demo.cpp demo.h)target_compile_definitions(demo PRIVATE DEMO_LIBRARY) demo.h 123456789101112#ifndef DEMO_H#define DEMO_Hclass Demo&#123;public: Demo(); void Print();&#125;;#endif // DEMO_H demo.cpp 1234567891011#include &quot;demo.h&quot;#include &lt;iostream&gt;Demo::Demo()&#123;&#125;void Demo::Print()&#123; std::cout &lt;&lt; &quot;this is a demo&quot; &lt;&lt; std::endl;&#125; 主程序工程PS：这个工程用于链接demo库 CMakeLists.txt 1234567891011121314cmake_minimum_required(VERSION 3.5)project(find-library LANGUAGES CXX)set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED ON)include_directories($&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/inc)find_library(LIB_DEMO demo $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/lib)add_executable($&#123;PROJECT_NAME&#125; main.cpp)target_link_libraries($&#123;PROJECT_NAME&#125; $&#123;LIB_DEMO&#125;) main.cpp 1234567891011#include &lt;iostream&gt;#include &quot;demo.h&quot;using namespace std;int main()&#123; Demo d; d.Print(); return 0;&#125; 问题情形首先这两个工程在Linux下使用没有问题的，find-library工程编译正常，可以正确链接demo库；但是在Windows平台就死活不行了，find-library工程CMakeLists.txt第10行老是报错提示demo库找不到 12LIB_DEMO linked by target &quot;find-library&quot; in directory E:/workspace/daily-project/cpp/find-library 但明明是把demo工程生成的库拷贝到find-library工程的lib目录下了，为啥就是死活会报错？Windows难道对库文件的格式有要求？ 解决办法尝试把demo工程的CMakeLists.txt第9行SHARED改成STATIC，重新编译demo，再把生成的静态库文件demo.lib拷贝到find-library工程的lib目录下，重新编译该工程却出乎意料的成功了！但参考官网find_library的用法却没有得到解析 总结下次写跨平台编译的代码的时候记得在cmake上面配置生成不同类型的库（Windows平台生成两种库准没错）","tags":["Windows","cmake"],"categories":["开发工具"]},{"title":"cJson数据格式问题","path":"//cjson-file-format-problem.html","content":"问题描述Linux的换行符是 ，Windows的换行符是\\r ，在Linux系统下使用cJson库解析本地json文件没有问题，但如果把Windows的json文件拷贝到Linux下需要把\\r 给过滤掉，否则传入文件buffer就解析不出cJson对象！ 解决办法 一个简单的办法通过vim设置set ff=unix将文件改为Unix文件格式 通过c&#x2F;c++实现trim或者trimmed接口过滤掉首尾两端空白符","tags":["linux","Windows","cJson"],"categories":["程序设计"]},{"title":"QNX移植mongoose","path":"//qnx-port-mongoose.html","content":"移植方法MG_ARCH表示Unix架构，SSL可以开启，也可以不开启，需要链接m，c，socket几个库 12source ~/qnx700/qnxsdp-env.sh # 使用前先source一下工具链aarch64-unknown-nto-qnx7.0.0-gcc -D MG_ARCH=1 -D MG_ENABLE_SSL=1 main.c ../../mongoose.* -l../../ -lm -lc -lsocket -o example","tags":["服务器","QNX","mongoose","开源库"],"categories":["程序设计"]},{"title":"电气自动化专业英语词汇","path":"//professional-english.html","content":"前言电子信息、电气工程、自动化、半导体、计算机专业英语词汇汇总，不定期更新 常用 Asynchronous：异步 synchronous：同步 notification：通知 blade：平面 shaft：轴 magnetic：磁场的 bearing：轴承 valve：阀 heat sink：散热片 separated：分离的 excitation amp：激励放大器 Axial：轴的，轴向的 Supervisor：管理员 front：前面的 rear：后面的 sheet metal：钣金 constraints：约束 Radial sensor：径向传感器 Axial sensor：轴向传感器 Magnetic bearing ：磁悬浮轴承 Thermal：热的 earth terminals：接地端子 Electromagnetic Interference，EMI：电磁干扰 reentrant：可重入的 simultaneously：同时 specifications：产品规格、约束 anticipate：预料 consequences：后果 hazards：危害 warranty：保证 herein：请进 Outlet：出口 series：产品系列 outer：外面的 bending：弯曲 obstacles：障碍 rack：架子 screw：螺钉 Levitation：悬浮 电子电气 circuit：电路 Impedance：阻抗 inductance：电感 resistor：电阻 capacitance：电容 thermistor：热敏电阻 braker Resistor：制动电阻 cable：线缆 Leakage current：漏电流 Fuse：保险丝 Insulation：绝缘 reflection：反射率 threshold：阈值 acquisition：采集 resistance：电阻 capacitance：电容 inductance：电感 diode：二极管 LED：light-emitting diode，发光二极管 Bipolar Junction Transistor：三极管 Field Effect Transistor：场效应管 beam：光线，波束 magnet：磁体 Radio Frequency：RF，射频，表示可以辐射到空间的电磁频率，频率范围从300kHz～300GHz之间 Metal-Oxide-Semiconductor Field-Effect Transistor：MOSFET，金氧半场效晶体管 interlock：联锁，为人身安全和设备安全设计的安全联锁装置 laser：激光 自动化 motor：电机 pump：泵 BEMF (back electromotive force）：反电动势 GPIO：General-Purpose Input&#x2F;Output，通用输入输出 pwm：Pulse Width Modulation，脉冲宽度调制效应 adc：analog-to-digital converter，模数转换器 dac：Digital to Analog Converter，数字模拟转换器 SCI：Serial Communications Interface，串行通信接口 can：Controller Area Network，近场通信协议 fan：风扇 braker：制动器、刹车 OPC UA：open platform communication unified architecture，开放平台统一架构 IPC：industrial PC，工控机 PLC：Programmable Logic Controller，可编程逻辑控制器 displacement：位移 malfunction：故障 PoE：power over ethernet，以太网供电技术 计算机 computer：计算机 design pattern：设计模式 data structure：数据结构 algorithm：算法 operating system：操作系统： compiler principle：编译原理 database：数据库 milliseconds：毫秒 loop back：回环，数据回环 protocol：协议 MQTT：Message Queuing Telemetry Transport 算法和数据结构 array：数组 linked list：链表 stack：栈 queue：队列 binary tree：二叉树 hash：哈希 graph：图 string：字符串 set：集合 map：映射 generic programming：泛型编程 sort：排序 图形学 pipeline：管线 shader：着色器 texture：纹理 VBO：Vertex Buffer Object，顶点缓冲对象 VAO：Vertex Array Object，顶点数组对象 EBO：Element Buffer Object，元素索引对象 viewport：视口 vector：向量 matrix：矩阵 NDC：Normalized Device Coordinates，标准化设备坐标 local space：局部空间 world space：世界空间 view space：观察空间 clip space：裁剪空间 screen space：屏幕空间 euler angles：欧拉角，偏航角、俯仰角、滚转角 yaw：偏航角 pitch：俯仰角 roll：滚转角 Phong Lighting Model：冯氏光照模型 Ambient Lighting：环境光 Diffuse Lighting：漫反射光 Specular Lighting：镜面光 Normal Vector：法向量 Material：材质 机器人 trajectory：轨迹 local path planning：局部路径规划 global path planning：全局路径规划 costmap：代价地图 acml：adaptive Monte Carlo localization，自适应蒙特卡洛定位 自动驾驶 RTK：Real-time kinematic，实时动态测量 longitude：经度 latitude：纬度 altitude：高程、海拔高度 GNSS：Global Navigation Satellite System，全球导航卫星系统 Antenna：天线 LiDAR：Light Detection And Ranging，激光雷达 camera：相机 IMU：Inertial Measurement Unit，惯性测量单元 accelerometer：加速度计，缩写accel gyroscope：陀螺仪，缩写gyro Magnetometer：磁力计，缩写mag 半导体 wafer：晶圆 PVD：物理气相沉积 CVD：化学气相沉积 etch：刻蚀 Ion implantation：离子注入 vacuum：真空 Miscellaneous：掺杂 butterfly valve：蝶阀 Pneumatic valves：气动阀 molecular pump：分子泵 Vacuum Gauge：真空规、真空计 flowmeter：流量计 Special Gas：特气 Gas cabinet：特气柜 Radio Frequency power supply：射频电源 Vacuum manipulator：真空机械手 Wafer alignment：晶圆对准 Reactor：反应炉","tags":["English","电气自动化","专业英语"],"categories":["学科"]},{"title":"cmake获取指定目录下的所有文件","path":"//cmake-recurse-files.html","content":"需求编写跨平台的工程时，因为项目比较大，文件很多，开发人员很多，不想一一列举add_executable里边的文件 解决用FILE宏获取某个指定目录下的同一类型的所有文件，用DIAGNOSTIC和SERIALIZE两个变量来分别存储所有符合条件的文件名，include_directories也可以自动包含目录下的所有头文件 12345FILE(GLOB_RECURSE DIAGNOSTIC $&#123;CMAKE_SOURCE_DIR&#125;/diagnostic/*.c)include_directories($&#123;CMAKE_SOURCE_DIR&#125;/diagnostic)FILE(GLOB_RECURSE SERIALIZE $&#123;CMAKE_SOURCE_DIR&#125;/serialize/*.c)include_directories($&#123;CMAKE_SOURCE_DIR&#125;/serialize) 再在add_executable里边添加DIAGNOSTIC和SERIALIZE两个变量，这样新增文件只要执行一下cmake就可以了 1234567add_executable(zhd-desktop main.c $&#123;DIAGNOSTIC&#125; $&#123;SERIALIZE&#125; logo.rc res.qrc) 示例以下是一个动态添加源文件（SRC）、头文件（HEADERS）、资源文件（RES）的工程示例，cmake脚本一下子清爽了好多 1234567891011121314151617181920212223242526272829303132333435363738cmake_minimum_required(VERSION 3.5)project(tractor LANGUAGES CXX)set(CMAKE_INCLUDE_CURRENT_DIR ON)set(CMAKE_AUTOUIC ON)set(CMAKE_AUTOMOC ON)set(CMAKE_AUTORCC ON)set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED ON)find_package(Qt5 COMPONENTS Widgets REQUIRED)include_directories($&#123;CMAKE_SOURCE_DIR&#125;)set(SRC_DIR $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;)file(GLOB SRC &quot;$&#123;SRC_DIR&#125;/*.cpp&quot; &quot;$&#123;SRC_DIR&#125;/*.cxx&quot; &quot;$&#123;SRC_DIR&#125;/*.cc&quot; &quot;$&#123;SRC_DIR&#125;/*.c&quot;)file(GLOB HEADERS &quot;$&#123;SRC_DIR&#125;/*.h&quot; &quot;$&#123;SRC_DIR&#125;/*.hpp&quot; &quot;$&#123;SRC_DIR&#125;/*.hxx&quot;)file(GLOB RES &quot;$&#123;SRC_DIR&#125;/*.ui&quot; &quot;$&#123;SRC_DIR&#125;/*.qrc&quot;)add_executable($&#123;PROJECT_NAME&#125; $&#123;SRC&#125; $&#123;HEADERS&#125; $&#123;RES&#125;)target_link_libraries($&#123;PROJECT_NAME&#125; PRIVATE Qt5::Widgets) 需要递归检索用GLOB_RECURSE，只需要当前目录用GLOB 总结 需要约定俗成的编码规范：比如源文件放哪里、头文件放哪里、资源文件放哪里 每次删减文件都需要执行一下cmake file函数可以实现递归式检索，但一般一级目录就够了","tags":["cmake"],"categories":["开发工具"]},{"title":"与NXP的一点缘分","path":"//nxp-stuff.html","content":"介绍NXP是老牌的芯片巨头，做汽车电子的人尤为熟悉，比如它的LPC系列、S32K系列、imx系列；我的老东家周立功就是靠NXP的代理权发家致富的；去年接触（白嫖）NXP的MCU方案比较多，特别是FRDM这个开发板系列，给RT-Thread贡献了开源文档、教程以及多个PR 开发板MCXN947这个板子的资源比较丰富，最大亮点是集成了神经处理单元 MCXA153资源比947稍微少一些，没有CAN和ETH，是中规中矩的MCU MCXW71专为无线连接设计的板子，支持Matter、Thread、Zigbee和BLE的多协议无线子系统，我已经给它移植了RT-Thread系统 礼品参与NXP相关的活动，收到的一些礼物 机械键盘参加947的测评活动送的一份沉甸甸的礼物：RT-Thread定制版机械键盘 发光鼠标垫这个可以发光，颜色会变化，超大的垫子 充电宝这个是新年收到的礼物，20000mAh的充电宝，以后户外调试开发板就不愁没有电源了！","tags":["NXP","blog"],"categories":["嵌入式"]},{"title":"网络数据Hex格式转换","path":"//qt-string-to-hex.html","content":"前言Qt中TCP通信一般用QByteArray作为数据传输对象，使用Hex格式的情形要考虑一下变换，否则服务器和客户端的数据长度对不上 发送字符串本身就是hex格式，需要转成QByteArray格式进行传输 123QString hex = &quot;03000010560155aa010023000000d750&quot;;QByteArray data = QByteArray::fromHex(hex.toLatin1());m_socket-&gt;write(data); 接收QByteArray转为hex格式 12QString hex = m_socket-&gt;readAll().toHex();qDebug() &lt;&lt; hex;","tags":["Qt","hex"],"categories":["程序设计"]},{"title":"一个简单的Windows TCP服务器实现","path":"//winsock2-server.html","content":"包含头文件 12#include &lt;winsock2.h&gt;#include &lt;stdio.h&gt; 需要链接的库文件 1ws2_32.lib winsocket初始化 123456789WSADATA wsaData;SOCKET serverSocket, clientSocket;struct sockaddr_in serverAddr = &#123; 0x00 &#125;;struct sockaddr_in clientAddr = &#123; 0x00 &#125;;int clientAddrLen = sizeof(clientAddr);if (WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0) &#123; printf(&quot;WSAStartup failed. &quot;);&#125; 创建winsocket 1234if ((serverSocket = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET) &#123; printf(&quot;Socket failed. &quot;); WSACleanup();&#125; IP及端口号配置 123456789serverAddr.sin_family = AF_INET;serverAddr.sin_addr.s_addr = INADDR_ANY;serverAddr.sin_port = htons(9988);if (bind(serverSocket, (struct sockaddr*)&amp;serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) &#123; printf(&quot;Bind failed. &quot;) closesocket(serverSocket); WSACleanup();&#125; 监听客户端连接 12345if (listen(serverSocket, 5) == SOCKET_ERROR) &#123; printf(&quot;Listen failed. &quot;); closesocket(serverSocket); WSACleanup();&#125; 接受客户端连接 12345if ((clientSocket = accept(serverSocket, (struct sockaddr*)&amp;clientAddr, &amp;clientAddrLen)) == INVALID_SOCKET) &#123; printf(&quot;Accept failed. &quot;); closesocket(serverSocket); WSACleanup();&#125; 接收数据 1int bytesReceived = recv(clientSocket, (char*)(_sRxBuffer + _sRxLenght), BUFFER_SIZE, 0); 发送数据 1int txPacketlenght = send(socket, (const char*)_sTxBuffer, txPacketlenght, 0); 回收winsocket资源 123closesocket(clientSocket);closesocket(serverSocket);WSACleanup(); 检查连接断开情形 1234567891011int bytesReceived = recv(clientSocket, buffer, bufferSize, 0);if (bytesReceived == 0) &#123; printf(&quot;Client socket disconnected gracefully. &quot;);&#125; else if (bytesReceived == SOCKET_ERROR) &#123; int error = WSAGetLastError(); if (error == WSAECONNRESET) &#123; printf(&quot;Client socket disconnected unexpectedly. &quot;); &#125; else &#123; printf(&quot;Recv failed with error: %d &quot;, error); &#125;&#125;","tags":["服务器","Windows","tcp"],"categories":["程序设计"]},{"title":"Windows常用快捷键集合","path":"//windows-common-shortcuts.html","content":"介绍工欲善其事必先利其器，用对工具往往事半功倍 快捷键 打开运行对话框：win + R 打开Windows粘贴板：win + V 打开Home菜单：win + X 打开搜索对话框：win + S 截图：win + Shift + S 打开控制面板：win + I 在某个文件路径迅速打开cmd命令行：Ctrl + L，输入cmd即可 拓展屏幕配置：win + P 光标聚焦任务栏：win + T 光标聚焦状态栏：win + B 所有窗口最小化：win + M 锁屏：win + L Windows防火墙：win + R后输入filewall.cpl 运行任务栏的程序：win + 1，2，3，4对应从左到右的程序序号 打开Windows通知面板：win + A 唤醒画画及截屏功能：win + W","tags":["快捷键","Windows"],"categories":["开发工具"]},{"title":"Qt Enter和HoverEnter事件","path":"//qt-enter-hoverenter.html","content":"介绍做PC开发的过程中或多或少都会接触到鼠标的悬停事件，Qt中处理鼠标悬停有Enter和HoverEnter两种事件 相同点 QEvent::Enter对应QEnterEvent，描述的是鼠标进入控件坐标范围之内的行为，QEnterEvent可以抓取鼠标的位置 QEvent::HoverEnter对应QHoverEvent，控件开启Qt::WA_Hover属性可以达到Enter事件一样的效果，QHoverEvent同样可以抓取鼠标的位置 不同点QHoverEvent附带有QEvent::Paint重绘行为，QEnterEvent没有触发控件本身的重绘的能力，请按照具体的场景区别使用","tags":["Qt","鼠标事件"],"categories":["程序设计"]},{"title":"Qt TCP通信案例","path":"//qt-tcp-communication-example.html","content":"服务器使用前要在cmake工程文件里边添加network模块 123find_package(Qt5 COMPONENTS core network REQUIRED)target_link_libraries($&#123;PROJECT_NAME&#125; Qt5::Core Qt5::Network) TCP通信服务器的核心类是QTcpServer，头文件同名 1#include &lt;QTcpServer&gt; 使用也特别简单，先绑定IP地址和端口号，listen的返回结果如果是false则端口号有可能被占用，Windows上建议用netstat -aon | findstr &quot;9090&quot;事先看一下端口占用情况，Linux下则是用netstat -tlp | grep 9090 12QTcpServer server;bool ret = server.listen(QHostAddress(&quot;127.0.0.1&quot;), 9090); 编写newConnection信号对应的槽函数，服务器通过nextPendingConnection接口获取已建立的socket，然后对socket进行读写 1234567891011QObject::connect(&amp;server, &amp;QTcpServer::newConnection, [&amp;]() &#123; auto &amp;&amp;socket = server.nextPendingConnection(); auto timer = new QTimer(); QObject::connect(timer, &amp;QTimer::timeout, [&amp;, socket]() &#123; socket-&gt;write(QByteArray(&quot;hello world&quot;)); &#125;); timer-&gt;start(1000); QObject::connect(socket, &amp;QTcpSocket::readyRead, [&amp;, socket]() &#123; qDebug() &lt;&lt; &quot;Server : &quot; &lt;&lt; socket-&gt;readAll(); &#125;);&#125;); 客户端客户端同理，使用前也要在cmake工程文件里边添加network模块 123find_package(Qt5 COMPONENTS core network REQUIRED)target_link_libraries($&#123;PROJECT_NAME&#125; Qt5::Core Qt5::Network) 客户端使用QTcpSocket进行TCP通信 1#include &lt;QTcpSocket&gt; 调用connectToHost接口建立服务器通信连接 12QTcpSocket socket;socket.connectToHost(QHostAddress(&quot;127.0.0.1&quot;), 9090); 需要处理几个跟连接相关的信号：connected、disconnected、readyRead 12345678910111213// connected表示连接已建立QObject::connect(&amp;socket, &amp;QTcpSocket::connected, [&amp;]() &#123; timer-&gt;start(1000); qDebug() &lt;&lt; &quot;Client connected server&quot;;&#125;);// disconnected表示连接已断开QObject::connect(&amp;socket, &amp;QTcpSocket::disconnected, [&amp;]() &#123; qDebug() &lt;&lt; &quot;Client disconnected server&quot;;&#125;);// readyRead表示缓冲区有数据可读QObject::connect(&amp;socket, &amp;QTcpSocket::readyRead, [&amp;]() &#123; qDebug() &lt;&lt; &quot;Client : &quot; &lt;&lt; socket.readAll();&#125;); 基类QIODevice的读写接口 12345678910qint64 read(char *data, qint64 maxlen);QByteArray read(qint64 maxlen);QByteArray readAll();qint64 readLine(char *data, qint64 maxlen);QByteArray readLine(qint64 maxlen = 0);qint64 write(const char *data, qint64 len);qint64 write(const char *data);inline qint64 write(const QByteArray &amp;data)&#123; return write(data.constData(), data.size()); &#125; 结果 以上的服务器和客户端在互相给对方发hello world数据 QTcpServer那里巧妙抽象了QTcpSocket的操作方式，客户端和服务器都是对QTcpSocket读写","tags":["Qt","TCP","服务器","客户端"],"categories":["程序设计"]},{"title":"uboot剖析之命令行延时","path":"//uboot-bootdelay.html","content":"在configs/rk3506_defconfig文件中可以配置启动延时选项 1CONFIG_BOOTDELAY=3 common&#x2F;main.c –&gt; main_loop：bootdelay_process处理delay延时值解析，按键捕获由autoboot_command负责 123456789101112131415161718192021222324252627void main_loop(void)&#123; const char *s; bootstage_mark_name(BOOTSTAGE_ID_MAIN_LOOP, &quot;main_loop&quot;);#ifdef CONFIG_VERSION_VARIABLE env_set(&quot;ver&quot;, version_string); /* set version variable */#endif /* CONFIG_VERSION_VARIABLE */ cli_init(); run_preboot_environment_command();#if defined(CONFIG_UPDATE_TFTP) update_tftp(0UL, NULL, NULL);#endif /* CONFIG_UPDATE_TFTP */ s = bootdelay_process(); if (cli_process_fdt(&amp;s)) cli_secure_boot_cmd(s); autoboot_command(s); cli_loop(); panic(&quot;No CLI available&quot;);&#125; common&#x2F;autoboot.c –&gt; bootdelay_process：要么从环境变量bootdelay里边获取，要么就从CONFIG_BOOTDELAY里边获取，最后更新stored_bootdelay 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const char *bootdelay_process(void)&#123; char *s; int bootdelay;#ifdef CONFIG_BOOTCOUNT_LIMIT unsigned long bootcount = 0; unsigned long bootlimit = 0;#endif /* CONFIG_BOOTCOUNT_LIMIT */#ifdef CONFIG_BOOTCOUNT_LIMIT bootcount = bootcount_load(); bootcount++; bootcount_store(bootcount); env_set_ulong(&quot;bootcount&quot;, bootcount); bootlimit = env_get_ulong(&quot;bootlimit&quot;, 10, 0);#endif /* CONFIG_BOOTCOUNT_LIMIT */ s = env_get(&quot;bootdelay&quot;); bootdelay = s ? (int)simple_strtol(s, NULL, 10) : CONFIG_BOOTDELAY;#ifdef CONFIG_OF_CONTROL bootdelay = fdtdec_get_config_int(gd-&gt;fdt_blob, &quot;bootdelay&quot;, bootdelay);#endif debug(&quot;### main_loop entered: bootdelay=%d &quot;, bootdelay);#if defined(CONFIG_MENU_SHOW) bootdelay = menu_show(bootdelay);#endif bootretry_init_cmd_timeout();#ifdef CONFIG_POST if (gd-&gt;flags &amp; GD_FLG_POSTFAIL) &#123; s = env_get(&quot;failbootcmd&quot;); &#125; else#endif /* CONFIG_POST */#ifdef CONFIG_BOOTCOUNT_LIMIT if (bootlimit &amp;&amp; (bootcount &gt; bootlimit)) &#123; printf(&quot;Warning: Bootlimit (%u) exceeded. Using altbootcmd. &quot;, (unsigned)bootlimit); s = env_get(&quot;altbootcmd&quot;); &#125; else#endif /* CONFIG_BOOTCOUNT_LIMIT */ s = env_get(&quot;bootcmd&quot;); process_fdt_options(gd-&gt;fdt_blob); stored_bootdelay = bootdelay; return s;&#125; common&#x2F;autoboot.c –&gt; autoboot_command：在执行启动命令run_command_list前先检查stored_bootdelay值 12345678910111213141516171819202122232425void autoboot_command(const char *s)&#123; debug(&quot;### main_loop: bootcmd=\\&quot;%s\\&quot; &quot;, s ? s : &quot;&lt;UNDEFINED&gt;&quot;); if (stored_bootdelay != -1 &amp;&amp; s &amp;&amp; !abortboot(stored_bootdelay)) &#123;#if defined(CONFIG_AUTOBOOT_KEYED) &amp;&amp; !defined(CONFIG_AUTOBOOT_KEYED_CTRLC) int prev = disable_ctrlc(1); /* disable Control C checking */#endif run_command_list(s, -1, 0); autoboot_command_fail_handle();#if defined(CONFIG_AUTOBOOT_KEYED) &amp;&amp; !defined(CONFIG_AUTOBOOT_KEYED_CTRLC) disable_ctrlc(prev); /* restore Control C checking */#endif &#125;#ifdef CONFIG_MENUKEY if (menukey == CONFIG_MENUKEY) &#123; s = env_get(&quot;menucmd&quot;); if (s) run_command_list(s, -1, 0); &#125;#endif /* CONFIG_MENUKEY */&#125; common&#x2F;autoboot.c –&gt; abortboot：真正的功能实现在__abortboot 1234567891011121314static int abortboot(int bootdelay)&#123; int abort = 0; if (bootdelay &gt;= 0) abort = __abortboot(bootdelay);#ifdef CONFIG_SILENT_CONSOLE if (abort) gd-&gt;flags &amp;= ~GD_FLG_SILENT;#endif return abort;&#125; common&#x2F;autoboot.c –&gt; __abortboot：bootdelay延时计数 + 等待按键ctrl+c输入 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static int __abortboot(int bootdelay)&#123; int abort = 0; unsigned long ts;#ifdef CONFIG_MENUPROMPT printf(CONFIG_MENUPROMPT);#else printf(&quot;Hit key to stop autoboot(&#x27;CTRL+C&#x27;): %2d &quot;, bootdelay);#endif#ifdef CONFIG_ARCH_ROCKCHIP if (!IS_ENABLED(CONFIG_CONSOLE_DISABLE_CLI) &amp;&amp; ctrlc()) &#123; /* we press ctrl+c ? */#else /* * Check if key already pressed */ if (tstc()) &#123; /* we got a key press */#endif (void) getc(); /* consume input */ puts(&quot;\\b\\b\\b 0&quot;); abort = 1; /* don&#x27;t auto boot */ &#125; while ((bootdelay &gt; 0) &amp;&amp; (!abort)) &#123; --bootdelay; /* delay 1000 ms */ ts = get_timer(0); do &#123; if (ctrlc()) &#123; /* we got a ctrl+c key press */ abort = 1; /* don&#x27;t auto boot */ bootdelay = 0; /* no more delay */# ifdef CONFIG_MENUKEY menukey = 0x03; /* ctrl+c key code */# endif break; &#125; udelay(10000); &#125; while (!abort &amp;&amp; get_timer(ts) &lt; 1000); printf(&quot;\\b\\b\\b%2d &quot;, bootdelay); &#125; putc(&#x27; &#x27;); return abort;&#125; 如果不小心把启动延时设置为0，需要手动设置bootdelay的值才可以进入uboot配置菜单","tags":["串口","uboot","rk3506","控制台"],"categories":["嵌入式"]},{"title":"Qt按钮美化教程","path":"//qt-button-design.html","content":"前言Qt按钮美化主要有三种方式：QSS、属性和自绘 QPushButtonQSS字体大小 1font-size: 18px; 文字颜色 1color: white; 背景颜色 1background-color: rgb(10,88,163); 按钮边框 1border: 2px solid rgb(114,188,51); 文字对齐 1text-align: left; 左侧内边距 1padding-left: 10px; 文字加粗 1font-weight: bold; 边框的大小 1border-width: 4px; 边框的半径 1border-radius: 3px; 整合样式 123456789101112131415QPushButton &#123; font-size: 18px; /* 设置字体大小 */ color: white; /* 设置字体颜色 */ background-color: rgb(10,88,163); /* 设置背景颜色 */ border: 2px solid rgb(114,188,51); /* 设置边框 */ text-align: left; /* 文字左对齐 */ padding-left: 10px; /* 左侧内边距 */ font-weight: bold;&#125;QPushButton:pressed &#123; background-color: rgb(41,51,57); color: rgb(114,188,51); /* 设置字体颜色 */ border-width: 4px;&#125; 属性添加hover tooltip 修改text 焦点策略，一般默认StrongFocus 坐标和大小 自绘重写paintEvent虚函数，这个一般用的不多 12345678CPushButton::paintEvent(QPaintEvent *event)&#123; /* 这里增加自绘的代码：文字、图片等等 */ QPainter p(this); p.drawText(10, 10, &quot;Clicked me&quot;); p.drawPixmap(20, 10, QIcon(&quot;:/res/button.png&quot;)); QPushButton::paintEvent(event);&#125; 效果附上QSS+属性美化后的button效果（自己写的，你嫌丑我还嫌丑哩） QToolButton有时候需要定制图片跟文字同时显示的按钮（在触摸屏用的比较多），QToolButton是一个不错的选择 QSS添加底图 1qproperty-icon: url(:/resource/home.png) center; 底图大小设置 1qproperty-iconSize: 32px 32px; 聚焦时显示激活效果 1234QToolButton::focus&#123;\tbackground-image: url(:/resource/menu-active.png);&#125; 属性改变图片和文字的相对位置 在平板上面操作的话焦点策略改为ClickFocus 自绘QToolButton如无意外，不需要自绘 效果显示效果","tags":["Qt","button"],"categories":["程序设计"]},{"title":"Qt6串口数据协议解析","path":"//qt6-serial-protocol.html","content":"介绍绑定QSerialPort对象的readyRead信号时，从串口接收缓冲区读取的数据大概率不是一次就能接收完成的，有可能分成n次接收；这是一种什么情况呢，它有可能多次readyRead：1次，2次，3次，4次……这样子！如果不对数据的边界进行有效识别，就很难分别出哪些是我们要的数据 定长协议比如接收够15个字节才算接收完成，可以用QSerialPort::bytesAvailable这个接口进行组包，理论上给出头部标记就能识别有效的一帧数据：$ 10 0123456789 CS 1234567891011121314151617181920212223242526#define MAX_SIZE 15QByteArray buffer;int size = 0;auto callback = [&amp;]() &#123; auto &amp;&amp;data = this-&gt;readData(); if(data.startsWith(&quot;$&quot;)) &#123; size = m_serial-&gt;bytesAvailable(); buffer.clear(); buffer += data; if(size == MAX_SIZE) &#123; size = 0; emit this-&gt;sendOneFrame(buffer); &#125; &#125; else &#123; size += m_serial-&gt;bytesAvailable(); buffer += data; if(size == MAX_SIZE) &#123; size = 0; emit this-&gt;sendOneFrame(buffer); &#125; &#125;&#125;;connect(m_serial, &amp;QSerialPort::readyRead, this, callback); 不定长协议这个需要识别数据的边界（头部跟尾部）在哪里，比如用$头部，@做尾部，我们把分段的数据依次拼接起来 12345678910111213141516171819202122232425QByteArray buffer;auto callback = [&amp;]() &#123; qDebug() &lt;&lt; m_serial-&gt;bytesAvailable(); auto &amp;&amp;data = this-&gt;readData(); if(data.startsWith(&quot;$&quot;)) &#123; buffer.clear(); buffer += data; if(data.endsWith(&quot;@&quot;)) &#123; emit this-&gt;sendOneFrame(buffer); &#125; qDebug() &lt;&lt; &quot;1 : &quot; &lt;&lt; buffer; &#125; else &#123; if(!data.endsWith(&quot;@&quot;)) &#123; buffer += data; qDebug() &lt;&lt; &quot;2 : &quot; &lt;&lt; buffer; &#125; else &#123; buffer += data; qDebug() &lt;&lt; &quot;3 : &quot; &lt;&lt; buffer; emit this-&gt;sendOneFrame(buffer); &#125; &#125;&#125;;connect(m_serial, &amp;QSerialPort::readyRead, this, callback); 总结串口数据解析本质是一个文本处理的过程，如果接收端用C语言写，简单的协议还好，复杂的协议简直要命（请用高级语言）！","tags":["Qt","serial","串口"],"categories":["程序设计"]},{"title":"vim轻度使用","path":"//vim-usage.html","content":"安装 1sudo apt install vim 卸载 1sudo apt remove --purge vim 配置文件 1~/.vimrc 配置 开启行号：set nu 高亮行：set cul 高亮列：set cuc 高亮搜索关键字：set hls 绑定Esc快捷键：inoremap jj &lt;Esc&gt; tab大小配置：set ts&#x3D;4 使用 命令行模式按i、I、a、A可以进入编辑模式 编辑模式下按Esc进入命令行模式 在命令行模式用/关键字向下搜索，?关键字向上搜索 命令行模式用vs垂直分割窗口、sp水平分割窗口 在分割窗口之间移动：先按CTRL + W再按H、L 替换：s/替换前字符/替换后字符/g 命令行模式保存：w 命令行模式退出：q 命令行模式保存并退出：wq 命令行模式强制退出：q! 光标移动 上：k 下：j 左：h 右：l 快捷键 退出编辑器：CTRL + W + Q","tags":["linux","vim"],"categories":["开发工具"]},{"title":"最小git提交","path":"//mini-git-commit.html","content":"先从远程仓库拉新代码 1git fetch 合并分支改动 1git merge origin develop --no-ff 在当前分支基础上新建一个分支 1git checkout -b qml 下载远程仓库的更新 1git pull 查看本地修改了哪些文件 1git status -s 添加文件到暂存区 1git add file1 file2 file3 删除不需要的文件 1git rm -r file dir/ 写入提交日志 1git commit -m &quot;这是一段日志&quot; -a 提交到远程仓库 1git push -f origin main 提交一个新的分支到远程仓库 1git push --set-upstream origin qml 缓存修改（工作区和暂存区） 1git stash push -u 将暂存修改同步回来 1git stash pop","tags":["git"],"categories":["开发工具"]},{"title":"MDK Keil5快捷键","path":"//mdk-keil5-shortcut.html","content":"常见快捷键合集 开始&#x2F;停止调试：CTRL + F5 运行：F5 单步进入：F11 单步跳出：CTRL + F11 单步：F10 执行到指定位置：CTRL + F10 检索：CTRL + F 插入或者移除断点：F9 移除所有断点：CTRL + Shift + F9 烧录程序：F8 编译当前文件：CTRL + F7 构建当前工程：F7 打开工程配置：Alt + F7 跳到指定行：CTRL + G 剪切当前行：CTRL + L 前进：CTRL + Shift + - 后退：CTRL + -","tags":["keil","快捷键"],"categories":["开发工具"]},{"title":"一个比较理想的嵌入式产品模型","path":"//ideal-embedded-product-model.html","content":"介绍示波器是一个比较典型、通用、明确的嵌入式产品案例，工作这么多年，很多产品业务模型或多或少都跟示波器的开发有点像！我敢说以下列举的软件、硬件、机械的部分在很多嵌入式产品中（不管是医疗、自动化还是汽车电子）普遍存在，所以我觉得自己经常在做示波器的类似物 软件嵌入式软件的复杂度大概在40-50w代码量左右 数据采集：电压、can、温度信号 数据可视化：主要是波形、报文的展示 文件存储：把数据文件录制下来，方便回读分析 HMI用户界面交互：按键、飞梭、旋钮、触摸屏 指令控制：SCPI指令控制设备，完成自动化测量功能 设备校准：一些标定校准的数据文件、抑制设备老化带来的参数漂移 设备驱动：按键板驱动、触摸屏驱动、usb驱动、pcie驱动、数据采集&#x2F;控制驱动 软件升级：自升级 + 外设升级 上位机上位机主要是解析波形文件、指令控制、校准维护、外设升级等功能 web设备调参、诊断使用、OTA升级 操作系统裸机、RTOS、Linux、Windows（配套上位机） 硬件硬件的组成按数字芯片分类有以下几个部分 fpgafpga主要负责前端数据的采集、预处理 armarm是嵌入式软件运行的载体 dsp集成波形处理的算法，这个是算法的载体 mcu按键板、采集卡里边的芯片、电源管理芯片 x64x64是终端软件运行的载体、软件升级工具 机械机械部件比较中规中矩，如探头、机箱外壳、显示屏部件、按键部件、采集卡的外壳 总结综上，示波器是一个终极的嵌入式产品案例，业务模型通常都具有相似性，只要深入了解一个，便可以举一反三","tags":["产品","嵌入式"],"categories":["方法论"]},{"title":"上位机和下位机的基本通信协议","path":"//upper-computer-lower-computer-communication-protocol.html","content":"介绍上位机和下位机的通信方式多种多样，一般有usart、can、usb、ethernet等，走什么通信方式视下位机的设备资源而定；以ethernet tcp通信为例，大部分情形下，下位机即嵌入式设备作为server端，PC端作为client端；嵌入式设备需要默认一个IP地址，比如192.168.137.22，还要有一个端口号，比如8738 帧格式帧格式的设计应包含四个部分：帧头 + 长度 + 数据段 + 校验 帧头：两个字节，例如固定为0xaa 0x55 长度：uint16，大端，整个包的长度，包含帧头、长度、数据段和校验四个部分的总长 度。单个包的最大长度为512 数据段：包荷载的内容，长度不固定 校验：两个字节，帧头、长度和数据段的CRC16计算值，当然也可以用异或校验 心跳包心跳包设计原则： 最好仅支持一个设备连接 客户端请求，服务器应答 约定一个心跳时间，如30秒进行一次心跳查询；还要一个超时时间，如300秒没有任何应答则视为连接已经断开 请求请求报文格式参考：协议码 + 消息类型 + 功能码 + 序号 + 功能数据 应答应答报文格式参考：协议码 + 消息类型 + 功能码 + 序号 + 错误码 + 功能数据 总结以上请求和应答设计范例其实是一种web服务的思想","tags":["通信协议","上位机","下位机"],"categories":["程序设计"]},{"title":"tar命令","path":"//tar-common-usage.html","content":"查看压缩包比如想看看rootfs.tar里边有什么东西，避免解压有坑 12tar -tf rootfs.tartar tf rootfs.tar.xz 解压默认全部解压，当然参数部分也可以带压缩包类型：J表示xz、j表示bz2、z表示gz 1tar xf demo.tar.xx tar创建默认tar包 1tar -cf archive.tar foo bar xzxz文件压缩 1tar cJf rootfs.tar.xz rootfs/ bz2bz2文件压缩 1tar cjf rootfs.tar.bz2 rootfs/ gzgz文件压缩 1tar czf rootfs.tar.gz rootfs/","tags":["linux","tar"],"categories":["开发工具"]},{"title":"编程中的同步和异步概念","path":"//program-synchronization-asynchronous.html","content":"普通理解同步，即同时进行、一起做，比如：一边开会，一边做笔记，这两件事就是同步进行的 异步，跟同步相反，做事的时间顺序不一致，比如：常见的电影声音和字幕不一致 编程概念同步一个函数如果在调用的时候随即能拿到结果并返回，这就是同步，比如：调用一个LedOn()函数，Led灯就会马上亮起来、函数退出；一般，单线程的环境应用比较多，因为只有一条时间线，干不了很多的活，这是比较好理解的 异步异步调用一般出现在多线程或者中断情景下，有一些事情需要分给不同的任务做，而你又无法准确把握别的任务什么时候完成（它可能不知道干嘛去了），你不想等它，所以只能设置一个回调接口callback来让它告知你，这跟现实世界很像，你打电话给外卖小哥，外卖小哥说他没有空在送别的外卖，让你留个电话号码，等出单或者到了再告诉你，而你又可以不用一直等这个外卖了（忙别的事情），明显你和外卖小哥是活在不同时间线的，双方都很自由；大部分事件处理都是异步调用来的，像按键中断，只有按键值输入的时候你才需要做按键事件处理；还有倍福ADS接口：客户端注册一个回调函数，当事件发生时，ADS库会自动调用该函数，当目标变量（如PLC中的某个变量）的值发生变化时，ADS服务器会主动通知客户端 总结 编程其实是对现实生活的抽象 业务模型也具有普适性，不管物联网、自动化、还是汽车电子","tags":["反思","同步","异步"],"categories":["程序设计"]},{"title":"vscode支持ros2程序debug","path":"//vscode-ros2-debug.html","content":"安装下载 1wget https://az764295.vo.msecnd.net/stable/1a5daa3a0231a0fbba4f14db7ec463cf99d7768e/code_1.84.2-1699528352_amd64.deb 安装 1sudo dpkg -i code_1.84.2-1699528352_amd64.deb 打开 1code . 插件在打开ros2工程前需要安装几个插件 CMake CMake Tools Python Ros XML Tools 配置c_cpp_properties.json这个文件用于配置编译条件，我这里用的是foxy版本的ros2，其他版本可以参考着改 1234567891011121314151617&#123; &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Linux&quot;, &quot;includePath&quot;: [ &quot;$&#123;workspaceFolder&#125;/**&quot;, &quot;/opt/ros/foxy/include/**&quot; ], &quot;defines&quot;: [], &quot;compilerPath&quot;: &quot;/usr/bin/gcc&quot;, &quot;cStandard&quot;: &quot;c99&quot;, &quot;cppStandard&quot;: &quot;c++14&quot;, &quot;intelliSenseMode&quot;: &quot;clang-x64&quot; &#125; ], &quot;version&quot;: 4&#125; launch.json这个文件用于启动ros2 package，target选项用于配置package运行脚本，一般用相对位置比较合适 123456789101112131415&#123; // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;ROS: Launch&quot;, &quot;type&quot;: &quot;ros&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;target&quot;: &quot;./install/aglidar_sdk/share/aglidar_sdk/launch/start.py&quot; &#125; ]&#125; settings.jsonvscode的基本配置，关联一些cpp的库、其它文件类型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&#123; &quot;editor.tabSize&quot;: 8, &quot;editor.rulers&quot;: [ 100 ], &quot;files.associations&quot;: &#123; &quot;*.repos&quot;: &quot;yaml&quot;, &quot;*.world&quot;: &quot;xml&quot;, &quot;*.xacro&quot;: &quot;xml&quot;, &quot;chrono&quot;: &quot;cpp&quot;, &quot;cctype&quot;: &quot;cpp&quot;, &quot;clocale&quot;: &quot;cpp&quot;, &quot;cmath&quot;: &quot;cpp&quot;, &quot;csignal&quot;: &quot;cpp&quot;, &quot;cstdarg&quot;: &quot;cpp&quot;, &quot;cstddef&quot;: &quot;cpp&quot;, &quot;cstdio&quot;: &quot;cpp&quot;, &quot;cstdlib&quot;: &quot;cpp&quot;, &quot;cstring&quot;: &quot;cpp&quot;, &quot;ctime&quot;: &quot;cpp&quot;, &quot;cwchar&quot;: &quot;cpp&quot;, &quot;cwctype&quot;: &quot;cpp&quot;, &quot;any&quot;: &quot;cpp&quot;, &quot;array&quot;: &quot;cpp&quot;, &quot;atomic&quot;: &quot;cpp&quot;, &quot;strstream&quot;: &quot;cpp&quot;, &quot;bit&quot;: &quot;cpp&quot;, &quot;*.tcc&quot;: &quot;cpp&quot;, &quot;bitset&quot;: &quot;cpp&quot;, &quot;codecvt&quot;: &quot;cpp&quot;, &quot;complex&quot;: &quot;cpp&quot;, &quot;condition_variable&quot;: &quot;cpp&quot;, &quot;cstdint&quot;: &quot;cpp&quot;, &quot;deque&quot;: &quot;cpp&quot;, &quot;forward_list&quot;: &quot;cpp&quot;, &quot;list&quot;: &quot;cpp&quot;, &quot;map&quot;: &quot;cpp&quot;, &quot;set&quot;: &quot;cpp&quot;, &quot;unordered_map&quot;: &quot;cpp&quot;, &quot;vector&quot;: &quot;cpp&quot;, &quot;exception&quot;: &quot;cpp&quot;, &quot;algorithm&quot;: &quot;cpp&quot;, &quot;functional&quot;: &quot;cpp&quot;, &quot;iterator&quot;: &quot;cpp&quot;, &quot;memory&quot;: &quot;cpp&quot;, &quot;memory_resource&quot;: &quot;cpp&quot;, &quot;numeric&quot;: &quot;cpp&quot;, &quot;optional&quot;: &quot;cpp&quot;, &quot;random&quot;: &quot;cpp&quot;, &quot;ratio&quot;: &quot;cpp&quot;, &quot;string&quot;: &quot;cpp&quot;, &quot;string_view&quot;: &quot;cpp&quot;, &quot;system_error&quot;: &quot;cpp&quot;, &quot;tuple&quot;: &quot;cpp&quot;, &quot;type_traits&quot;: &quot;cpp&quot;, &quot;utility&quot;: &quot;cpp&quot;, &quot;fstream&quot;: &quot;cpp&quot;, &quot;future&quot;: &quot;cpp&quot;, &quot;initializer_list&quot;: &quot;cpp&quot;, &quot;iomanip&quot;: &quot;cpp&quot;, &quot;iosfwd&quot;: &quot;cpp&quot;, &quot;iostream&quot;: &quot;cpp&quot;, &quot;istream&quot;: &quot;cpp&quot;, &quot;limits&quot;: &quot;cpp&quot;, &quot;mutex&quot;: &quot;cpp&quot;, &quot;new&quot;: &quot;cpp&quot;, &quot;ostream&quot;: &quot;cpp&quot;, &quot;shared_mutex&quot;: &quot;cpp&quot;, &quot;sstream&quot;: &quot;cpp&quot;, &quot;stdexcept&quot;: &quot;cpp&quot;, &quot;streambuf&quot;: &quot;cpp&quot;, &quot;thread&quot;: &quot;cpp&quot;, &quot;cfenv&quot;: &quot;cpp&quot;, &quot;cinttypes&quot;: &quot;cpp&quot;, &quot;typeindex&quot;: &quot;cpp&quot;, &quot;typeinfo&quot;: &quot;cpp&quot;, &quot;valarray&quot;: &quot;cpp&quot;, &quot;variant&quot;: &quot;cpp&quot; &#125;, // Autocomplete from ros python packages &quot;python.autoComplete.extraPaths&quot;: [ &quot;/opt/ros/foxy/lib/python3.8/site-packages/&quot; ], // Environment file lets vscode find python files within workspace &quot;python.envFile&quot;: &quot;$&#123;workspaceFolder&#125;/.env&quot;, // Use the system installed version of autopep8 &quot;python.formatting.autopep8Path&quot;: &quot;/usr/bin/autopep8&quot;, &quot;python.formatting.autopep8Args&quot;: [ &quot;--max-line-length=100&quot; ], &quot;C_Cpp.default.intelliSenseMode&quot;: &quot;clang-x64&quot;, &quot;C_Cpp.formatting&quot;: &quot;Disabled&quot;, &quot;uncrustify.useReplaceOption&quot;: true, &quot;uncrustify.configPath.linux&quot;: &quot;/opt/ros/foxy/lib/python3.8/site-packages/ament_uncrustify/configuration/ament_code_style.cfg&quot;, &quot;cSpell.words&quot;: [ &quot;RTPS&quot;, &quot;athackst&quot;, &quot;autopep&quot;, &quot;cmake&quot;, &quot;cppcheck&quot;, &quot;cpplint&quot;, &quot;deque&quot;, &quot;devcontainer&quot;, &quot;ints&quot;, &quot;noqa&quot;, &quot;pytest&quot;, &quot;rclcpp&quot;, &quot;rclpy&quot;, &quot;repos&quot;, &quot;rosdistro&quot;, &quot;rosidl&quot;, &quot;uncrustify&quot;, &quot;xmllint&quot; ], &quot;search.exclude&quot;: &#123; &quot;**/node_modules&quot;: true, &quot;**/bower_components&quot;: true, &quot;**/*.code-search&quot;: true, &quot;**/build&quot;: true, &quot;**/install&quot;: true, &quot;**/log&quot;: true &#125;, &quot;python.analysis.extraPaths&quot;: [ &quot;/opt/ros/foxy/lib/python3.8/site-packages/&quot; ], &quot;cSpell.allowCompoundWords&quot;: true, &quot;cSpell.ignorePaths&quot;: [ &quot;**/package-lock.json&quot;, &quot;**/node_modules/**&quot;, &quot;**/vscode-extension/**&quot;, &quot;**/.git/objects/**&quot;, &quot;.vscode&quot;, &quot;.vscode-insiders&quot;, &quot;.devcontainer/devcontainer.json&quot; ], &quot;ros.distro&quot;: &quot;foxy&quot;, &quot;cmake.sourceDirectory&quot;: &quot;/home/asensing/workspace/Asensing_LiDAR_ROS/aglidar_sdk&quot;&#125; tasks.json编译任务配置，debug需求的可以改成debug编译类型 123456789101112131415161718&#123; // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ &#123; &quot;label&quot;: &quot;build&quot;, &quot;detail&quot;: &quot;Build workspace (default)&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;colcon build --cmake-args &#x27;-DCMAKE_BUILD_TYPE=Debug&#x27; -Wall -Wextra -Wpendantic&quot;, &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true &#125;, &quot;problemMatcher&quot;: &quot;$gcc&quot; &#125; ]&#125; 调试调试快捷键列表，基本就是Visual Studio那一套 序号 功能 按键 1 单步 F10 2 单步进入 F11 3 单步跳出 Shift + F11 4 恢复 F5 5 暂停 F5 6 停止 Shift + F5 7 重新运行 Ctrl + Shift + F5 8 运行task编译工程 Ctrl + Shift + B 9 切换断点 F9 10 前进 Ctrl + Shift + - 11 后退 Ctrl + Alt + - 12 运行 Ctrl + Shift + D 调试界面效果","tags":["ROS2","vscode","debug"],"categories":["开发工具"]},{"title":"QMainWindow子窗口独立全屏","path":"//qmainwindow-subwindow-fullscreen.html","content":"事件过滤器QMainWindow的子类对象的构造函数中安装事件过滤器 1centralWidget()-&gt;installEventFilter(this); 信号和槽由QAction触发进入全屏 123456connect(this-&gt;Internals-&gt;actionFull_Screen, &amp;QAction::triggered, this, [=](bool flag) &#123; auto widget = centralWidget(); m_windowFlags = widget-&gt;windowFlags(); widget-&gt;setWindowFlag(Qt::Window); widget-&gt;showFullScreen();&#125;); 退出全屏重写QMainWindow子类对象的eventFilter虚函数，在里边添加以下代码 12345678910if(obj == centralWidget() &amp;&amp; ev-&gt;type() == QEvent::KeyPress) &#123; auto keyEvent = static_cast&lt;QKeyEvent *&gt;(ev); if(keyEvent-&gt;key() == Qt::Key_Escape) &#123; auto widget = centralWidget(); widget-&gt;setWindowFlags(m_windowFlags); widget-&gt;showNormal(); this-&gt;Internals-&gt;actionFull_Screen-&gt;setChecked(false); return true; &#125;&#125;","tags":["Qt","QMainWindow","全屏"],"categories":["嵌入式"]},{"title":"Qt工程远程调试","path":"//qt-project-remote-debug.html","content":"准备虚拟机既能ping通开发板，又能ping通外网，还要能ping通Windows主机（如果你有上位机通信的需求） VMware添加网络适配器2用作桥接网卡，原有的网络适配器保持为NAT模式 打开虚拟网络编辑器，配置VMnet0为桥接模式，外部连接设置为Realtek PCIe GbE Family Controller Ubuntu虚拟机配置ip 1sudo ifconfig ens37 192.168.137.33 netmask 255.255.255.0 其中ens33为NAT模式分配的网卡，它可以通过笔记本的无线网卡上网；ens37为桥接网卡，通过有线网卡跟开发板通信 Board开发板端配置IP 1ifconfig eth0 192.168.137.22 netmask 255.255.255.0 Windows手动配置IP 连接1）需要准备一些工具（交叉编译） ssh：openssh或者dropbear，开发板端部署sshd、宿主机端部署ssh sftp：一般跟ssh配套的，这个也放开发板端 arm-gdb：放在宿主机端 gdbserver：放在开发板端 2）在QtCreator添加Remote Device，保证ssh连接上 3）在Build &amp; Run里边配置Kits Device Sysroot Compiler Debugger Qt version rk3399-kit配置参考 远程部署cmakecmake需要写一个部署文件：QtCreatorDeployment.txt，写法参考如下： 12远程绝对路径宿主文件路径:远程相对路径 添加开发板所需要的文件到&#x2F;root目录（相对路径不填写就是放到默认的远程绝对路径下） 12/root/home/topeet/workspace/harvester/build/harvester: 添加文件到指定的目录下 123/root/home/topeet/workspace/harvester/build/harvester: /home/topeet/workspace/harvester/simulator.sh:/can qmakeqmake pro文件写法：local.path表示本地路径，target.path表示远程路径，通过addFiles的属性赋值添加要部署的目录或文件（file1、file2） 123456local.path = $$OUT_PWDlocal.path ~= s/builds.*/target.path = /rootaddFiles.path = $$target.pathaddFiles.files += file1addFiles.files += file2 示例：部署app放到&#x2F;root目录下 1234local.path = $$OUT_PWDlocal.path ~= s/builds.*/target.path = /rootINSTALLS += target 运行配置部署配置 运行配置 运行环境变量配置，以wayland-egl为例 可以通过Batch Edit方式批量配置 12QT_QPA_PLATFORM=wayland-eglXDG_RUNTIME_DIR=/tmp/.xdg","tags":["Qt","远程调试"],"categories":["嵌入式"]},{"title":"增量和存量市场","path":"//incremental-stock-market.html","content":"前言作为一名技术人，要对产品的市场动态时刻保持敏感，了解产品的昨天、今天、明天，才能有的放矢；不懂产品的程序员不是好程序员，我去过的公司，大部分也是程序员主导产品的研发流程，一部分人要承担项目前期的需求挖掘、客户拜访、可行性调研、产品文档编写、技术支持、产品运营等工作，可见市场敏感度对技术人来说很重要 增量市场定义 市场存在大量的需求，产品的潜力未有被充分挖掘，各种因素如政治、经济、疫情等导致需求的爆发，各方有百花齐放的趋势，巨头还没有出现，人称蓝海 特点 产品还没有充分被定义，存在着各种各样的发展方向和技术路线 需求量比较大，有引领时代潮流的趋势，堪称风口 时效性，产品也有它的生命周期，不会永远保持旺盛的产品力 与地缘政治、经济因素、社会动态强烈相关 识别 激光雷达：2022年激光雷达是增量市场，但2024年不是 半导体设备：如光刻机、CVD、PVD、Etch设备等 机器人：医护机器人、工业机器人等 核磁共振设备 存量市场定义 产品已经被定义、被市场接纳，行业的巨头有形成垄断的趋势，价格已经被打下来，利润空间很少了，称为红海，一般不建议加入存量市场 特点 需求已经明确，供应链稳定 行业垄断，头部竞争者占据优势地位（资本、技术、市场、人才） 利润空间不大 识别 2022年激光雷达是增量市场，但2024年不是，如今的汽车也不再是增量市场 2024年的新能源汽车是存量市场，价格战越演越烈，特斯拉、比亚迪等巨头体量优势特别明显，新势力则是赔本赚吆喝 公民教育，随着人口出生率下降，受教育的需求没有以前那么旺盛，教育市场已趋于饱和","tags":["产品","市场"],"categories":["方法论"]},{"title":"汽车零部件研发的各个阶段","path":"//auto-parts-stage.html","content":"A样原型机开发阶段，问题较多且功能有限，以功能原理验证为主，一般是人工制造为主，比如拼模块组装，简易打板或者直接购买demo板 B样积累了一定的解决问题的经验，基本结构已经成型（产品参数），也有了成型的PCB板，软硬件处于不断的磨合阶段，此阶段硬件、软件的改动比较频繁，产品研发的主要阶段，持续时间比较长，还是人工制造为主 C样已经能够在生产线小批量生产，快速部署，还需要进行各项测试，可以借助一些自动化软件、设备辅助生产，提高生产效率 D样已经能够批量交付用户使用，可用于相关部门的检查、认证，此时也有完整的用户手册，出现问题也有技术支持","tags":["产品","汽车电子"],"categories":["方法论"]},{"title":"项目概要设计说明书","path":"//project-overview-specification.html","content":"项目介绍xxx是一个什么样的项目，技术点、人力投入、工期 需求概述把客户的目标需求大致讲清楚 应用领域 运行环境 功能指标 性能指标 条件限制 技术可行性分析材料、结构、硬件、软件、测试角度分析 需要采购什么设备、走什么认证流程、用什么测试手段 系统架构 &#x2F; 总体设计软硬件系统组成结构 上位机 下位机 服务器 通信协议 人员职责需要的人员以及工种，每个人负责的工作点，大概估算多少人、多少工时 美工 软件 硬件 机械 测试 运维 产品 功能模块对系统架构里边的模块逐一拆解、分析，列出系统框图 模块1 模块2 模块3 每个模块工作流程图 流程1 流程2 流程3 接口设计模块的通信接口进行定义 接口1 接口2 接口3 通信协议硬件接口 软件协议 测试前置依赖：需要什么人、什么设备、什么条件 性能、参数指标测试 黑盒、白盒 维护客户现场出现问题怎么解决，材料、结构、硬件、软件的职责范围","tags":["管理","项目","说明书"],"categories":["方法论"]},{"title":"Ubuntu22.04搭建ROS2运行环境","path":"//ubuntu22.04-install-ros2.html","content":"区域语言设置设置区域语言为US 123456789sudo apt updatesudo apt install localessudo locale-gen en_US en_US.UTF-8sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8export LANG=en_US.UTF-8 必备软件组件如果已经安装，可以跳过这一步骤 1234567sudo apt updatesudo apt-get install -y libyaml-cpp-devsudo apt-get install -y libpcap-devsudo apt install -y curl gnupg lsb-release 更新远程仓库源更新/etc/hosts文件，防止raw.githubusercontent.com被墙，可以通过nslookup命令查看域名服务器地址 12345185.199.110.133\traw.githubusercontent.com185.199.110.133 user-images.githubusercontent.com185.199.110.133 avatars2.githubusercontent.com185.199.100.133 avatars1.githubusercontent.com20.205.243.166 github.com 如果已经添加过源，这一步也可以跳过 12345sudo curl -sSL http://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpgecho &quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(source /etc/os-release &amp;&amp; echo $UBUNTU_CODENAME) main&quot; | sudo tee /etc/apt/sources.list.d/ros2.list &gt; /dev/nullsudo apt update 安装humble桌面版和基础版二选一 12sudo apt install ros-humble-desktop # 桌面版sudo apt install ros-humble-ros-base\t# 基础版 安装软件包colcon和libbackward-ros都安装一下 12sudo apt-get install python3-colcon-common-extensionssudo apt-get install -y ros-humble-backward-ros 验证ROS2借用小乌龟来验证是否成功，humble版本如果没有预装turtlesim的话请事先安装 1sudo apt install ros-humble-turtlesim 运行turtlesim_node和turtle_teleop_key两个节点 123source /opt/ros/humble/setup.bashros2 run turtlesim turtlesim_noderos2 run turtlesim turtle_teleop_key 控制效果 完全卸载如果你不想用humble这个版本，请用以下命令卸载干净 1sudo apt-get autoremove --purge ros-humble-desktop","tags":["ROS2","ubuntu22.04"],"categories":["操作系统"]},{"title":"解决csv文件导出时间戳精度丢失的问题","path":"//csv-file-lose-precision.html","content":"丢失精度以圆周率数据输出为例，如果直接通过ostream输出到文件，则会丢失精度 123ostream stream;double value = 3.1415926;stream &lt;&lt; value; 保留精度需要通过std::setprecision函数来指定浮点数的精度 123ostream stream;double value = 3.1415926;stream &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; value;","tags":["C++","csv"],"categories":["程序设计"]},{"title":"Windows程序读取不了中文路径问题","path":"//windows-program-chinese-path-problem.html","content":"问题描述今天调试发现win32接口GetFileAttributesW居然不支持中文路径，于是寻找解决方案，找了半天，尝试用boost的fileystem库发现能解决问题，而且boost能跨平台！ 不支持中文win32接口获取文件属性，当传入参数带有中文字符时，它获取的属性就会异常 1DWORD GetFileAttributesW([in] LPCWSTR lpFileName); 支持中文boost判断是否为文件 123std::string realpath = &quot;D:\\\\新建文件夹\\\\a.txt&quot;;boost::filesystem::path p(realpath);boost::filesystem::is_regular_file(p); boost判断是否为文件夹 123std::string realpath = &quot;D:\\\\新建文件夹&quot;;boost::filesystem::path p(realpath);boost::filesystem::is_directory(p); 总结人生苦短，我用boost！","tags":["Windows","win32","中文路径"],"categories":["程序设计"]},{"title":"嵌入式代码优化技巧","path":"//embedded-code-optimization.html","content":"内存管理技巧1.C&#x2F;C++工程应尽量避免深拷贝，尽量用浅拷贝（指针或者引用），如果指针需要频繁拷贝，用智能指针是一种不错的选择 2.启用内存池管理线程的内存开销，事先在堆里边分配好，然后快速使用 避免复杂的浮点运算1.复杂的浮点运算尽量避免，有些芯片是不支持硬件双精度浮点数的，比如全志T3，实在是非用不可，可以用查表的方式加快速度 2.数据传输可以用整型数据压缩减少带宽，这个在can数据传输比较常见 空间换时间比如一个数据模型体积很大，加载起来很耗时，可以考虑把它编译到软件里边去，然后运行的时候提前加载到内存 算法复杂度优化1.时间复杂度，减少循环使用次数 2.空间复杂度的角度优化 并行框架openMP了解一下，在关键的代码段加上omp并行处理 字节对齐用好字节对齐功能可以优化cpu流水线的处理效率 内核态的利用可以把一些业务操作写进驱动，利用操作系统的调度优化，内核态和用户态哪一个更高效，这个是相对的，得看系统调用和库函数的颗粒度，可以值得尝试一下 线程调度尝试调整一些线程的优先级提高调度效率，另外Linux也允许绑核操作 防御性编程 申请一段buffer后总是习惯性的将其内容memset为0，当然这是针对plain类型的数据，防止在数据解析的时候解析到不合法的数据 总是习惯性的判断数组的边界 申请指针不应该悬空，应该给它一个值或者是nullptr，使用前判断它是否为空 巧用断言","tags":["调优","优化"],"categories":["嵌入式"]},{"title":"软件版本那些事","path":"//software-version.html","content":"软件版本跟测试阶段或者软件的生命周期所处的阶段有关，一般有以下几个版本 alpha内测版本，仅限团队内部测试使用，不对外公开。大多数软件产品在向公众发布之前都要经过多个步骤。alpha版本是该系统的一部分，用于开发高效、准确和无缺陷的软件程序。这一阶段软件会频繁改动。 项目处于不稳定状态。可能有许多未修复的错误，包括安全问题。API可能会更改，恕不另行通知。安装新的alpha版本需要卸载项目，从而丢失所有数据。只针对那些想要提前预览项目的人。尚不适合共享发展。不适合生产现场使用。目标受众是希望参与项目测试、调试和开发的开发人员。 beta通过内部测试之后的版本，开放给外部渠道使用。Beta版本通常在外观、感觉和功能上与最终产品相当接近；在这一阶段变更还是会经常发生。 所有重要的数据丢失和安全漏洞得到解决。如果模块提供了一个API，它应该被认为是冻结的，这样那些使用API的人就可以开始升级他们的项目了。如果是项目的升级或更新，则应提供升级&#x2F;更新路径，并且现有用户应该能够在不丢失数据的情况下升级&#x2F;更新到新版本。所有文档都应该是最新的。目标受众是想要参与项目的测试、调试和开发的开发人员，以及与项目对接的其他项目的开发人员。通常不适用于生产站点，但如果站点管理员非常了解项目，并且知道如何处理任何遗留问题，则可以在某些生产站点上使用。 rcrelease candidate，beta版本迭代之后比较成熟的版本，按照惯例，每当程序的更新几乎准备就绪时，测试版本就会被赋予rc号。如果发现了需要修复的关键错误，则更新程序并以更高的rc号重新发布。当没有严重错误存在，或者没有发现额外的严重错误时，rc名称将被删除。 release正式提供给客户使用的版本 stablerelease版本中的稳定版本，一般比较少使用","tags":["版本"],"categories":["方法论"]},{"title":"程序员健康指南","path":"//programmer-health-guide.html","content":"前言前不久，IT界的大佬左耳朵耗子陈皓心梗逝世，享年仅47岁，真是天妒英才，据说他是一名工作狂…… 感慨好的身体是革命的本钱，年纪越大，就会发现编程并不是脑力活，其实更偏向体力活！长时间工作吃的是人的体力和精力，开会、写文档、编码、测试样样工作都需要有充沛和持续的精力投入；在中国这种996工作制遍地开花的国度，如果你没有铁一样的身体素质，你基本很难熬35岁这道坎，这也是为什么很多公司喜欢招小年轻的原因；并且，久坐在办公室容易引发很多疾病：眼疲劳、关节疼痛、头晕眼花、颈椎病……新闻经常能听到这样的剧本：某某大厂员工在加班的时候突然猝死，留下背负房贷的妻儿老小……说了这么多，想必大家已经知道拥有一个好身体对程序员来说是多么的重要，下面将从几个方面介绍一些程序员健康指南，希望能对广大程序员有所帮助 作息篇 早点睡 多睡点 睡好点 尽量午睡 饮食篇 少吃甜食 少盐 少油 多喝水 荤素搭配 运动篇 慢跑 &#x2F; 散步，Linus就是在家里买了一台跑步机，边跑步边编码 伸腿、弯腰 到户外去，city walk或者到公园散散心都可以 工作篇 番茄工作法，将一个任务分解一个个工作包，以一个工作包为单位执行 学会坦然，现实生活中技术问题往往不是最重要的问题，大多数问题也跟编程无关 向上管理，遇到问题学会及时反馈，而不是一个人扛着 提高工作效率，要做的事情排一个优先级 生活篇 多遵循内心的意愿 学会拒绝 有什么喜欢的事情要趁着年轻去追寻，尝试一些爱好，如学学钢琴、听听音乐会 张弛有道，切勿绷得像机械钟的发条一样紧 社交篇 尊重他人的想法 尊重自己的内心 语录《活着》 没有什么比时间更具有说服力了，因为时间无需通知我们就可以改变一切 人是为活着本身而活着，而不是为了活着之外的任何事物所活着 一个人命再大，要是自己想死，那就怎么也活不了 《百年孤独》 我们终究会死。所以我们的人生目标不该是长命百岁，而应该做点自己想做的","tags":["健康","职业"],"categories":["学科"]},{"title":"gdb8.3交叉编译","path":"//gdb8.3-porting.html","content":"下载去gdb官网下载gdb8.3 1wget https://ftp.gnu.org/gnu/gdb/gdb-8.3.tar.xz 下载完成后解压xz文件 12tar xf gdb-8.3.tar.xzcd gdb-8.3 配置环境变量 1export PATH=$PATH:/home/topeet/rk3399/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin 编译gdb 12./configure --target=aarch64-linux-gnu --prefix=$PWD/buildmake -j8 编译gdbserver 123cd gdb./configure --target=aarch64-linux-gnu --host=aarch64-linux-gnu --prefix=$PWD/build CXXFLAGS=&#x27;-fPIC -static&#x27;make -j8 测试将gdbserver部署到开发板文件系统，并运行gdbserver 1gdbserver --multi :10000 demo 宿主机端运行aarch64-linux-gnu-gdb 1target remote 192.168.137.22:10000","tags":["gdb","交叉编译"],"categories":["嵌入式"]},{"title":"RT-Thread技术沙龙","path":"//rt-thread-tech-salon.html","content":"主题会议由RT-Thread &amp;&amp; Infineon共同主持，PSoc62开发板现场演示从0到1搭建智能数据网关 RT-ThreadRT-Thread社区负责人郭占鑫郭工介绍RT-Thread生态 合作伙伴英飞凌产品负责人介绍英飞凌的产品动态、分享未来的一些嵌入式技术发展方向以及应用案例 技术分享技术人员介绍有关钩子函数在开源项目、日常项目的用法 idle线程 uart接收 IoT项目案例 实验环节现场撸了英飞凌开发板的点灯代码（万物基于点灯），这个必须记录下来！ 1234567891011121314151617181920212223242526272829303132#include &lt;rtthread.h&gt;#include &lt;rtdevice.h&gt;#include &quot;drv_gpio.h&quot;#define LED0_PIN GET_PIN(0, 1)#define USER_KEY GET_PIN(6, 2)void irq_callback()&#123; static int flag = 0; rt_kprintf(&quot;Key Pressed!\\r &quot;); if(flag == 0) &#123; rt_pin_write(LED0_PIN, PIN_HIGH); flag = 1; &#125; else &#123; rt_pin_write(LED0_PIN, PIN_LOW); flag = 0; &#125;&#125;int main(void)&#123; rt_pin_mode(LED0_PIN, PIN_MODE_OUTPUT); rt_pin_mode(USER_KEY, PIN_MODE_INPUT_PULLUP); rt_pin_attach_irq(USER_KEY, PIN_IRQ_MODE_RISING, irq_callback, RT_NULL); rt_pin_irq_enable(USER_KEY, PIN_IRQ_ENABLE); return 0;&#125; 实验点灯效果 抽奖环节开发板免费送 抽奖环节我居然也是幸运观众，RT-Thread抱枕一个 合影RT-Thread社区人员、Infineon、现场开发者人员集体合影 致谢 感谢RT-Thread社区为这次技术分享所作的努力，祝愿RT-Thread开源事业越来越红火 感谢英飞凌合作伙伴的大力支持，祝英飞凌芯片大卖","tags":["RT-Thread","开源"],"categories":["开源社区"]},{"title":"创客峰会杂感","path":"//maker-summit.html","content":"前言一年一度的大湾区国际创客峰会11月11日至12日在深圳南山万科云设计公社举行 见闻在阶梯会议室看到了树莓派基金会的创始人和Seeed Studio的创始人 很有意思的机器人音乐项目 每日积点功德之电子木鱼，真的是脑洞大开！ 外国友人的温室大棚项目，思考😀 络绎不绝的NVIDIA、seeed studio、树莓派展厅 日本友人的生化项目，没点专业知识真的看不懂！ 合影和两位伙伴们的留影（两位开源界的巨擘） 感慨如果你问我，中国的maker和外国的maker有啥不一样？我会回答，一个不纯粹，一个纯粹，没有可比性，中国人通常都带着某种目的去玩创客（我逼自己一把），外国人明显没有这种心理包袱，在现场我甚至看到了大学生毕业设计玩烂的温室大棚环境监控系统，可见他们只是just for fun，有个日本人展示了他的电子乐器，甚至还有一个电子木鱼，兴致勃勃的给路人讲解他的发明，他的那种passion是大多数中国人不能理解的","tags":["开源","创客"],"categories":["开源社区"]},{"title":"about","path":"/about/index.html","content":"hywing’s blog作者全栈开发者，从事物联网、自动化、汽车电子开发工作，具有丰富的调试和设计经验 内容分享一些工作中的问题、想法，与技术、管理、产品相关的记录、思考、沉淀，希望对读者有帮助 原则 尽量简短 尽量少图片 尽量准确 免责这个是我的个人博客，如果对你有帮助是我莫大的荣幸，自行更改请恕不另行通知！"},{"title":"ros2介绍","path":"/wiki/ros2/index.html","content":"介绍"},{"title":"51单片机介绍","path":"/wiki/mcs51/index.html","content":"介绍"},{"title":"启动流程","path":"/wiki/kernel/index.html","content":"介绍"},{"title":"PWM驱动","path":"/wiki/stm32/PWM驱动.html","content":"介绍生成1KHz的方波"},{"title":"ADC使用","path":"/wiki/stm32/ADC使用.html","content":"介绍ADC读取电阻分压"},{"title":"GPIO使用","path":"/wiki/stm32/GPIO使用.html","content":"介绍虽说使用stm32CubeMX配置GPIO是一件很轻松的事情，但还是有必要从代码的角度理解GPIO的配置过程 初始化GPIO初始化流程： 初始化GPIO_InitTypeDef结构体 使能GPIO端口时钟 设置Pin口状态 GPIO_InitTypeDef结构体，一般需要设置Pin、Model、Pull、Speed几项参数 1234567891011121314151617typedef struct&#123; uint32_t Pin; /*!&lt; Specifies the GPIO pins to be configured. This parameter can be any value of @ref GPIO_pins */ uint32_t Mode; /*!&lt; Specifies the operating mode for the selected pins. This parameter can be a value of @ref GPIO_mode */ uint32_t Pull; /*!&lt; Specifies the Pull-up or Pull-Down activation for the selected pins. This parameter can be a value of @ref GPIO_pull */ uint32_t Speed; /*!&lt; Specifies the speed for the selected pins. This parameter can be a value of @ref GPIO_speed */ uint32_t Alternate; /*!&lt; Peripheral to be connected to the selected pins This parameter can be a value of @ref GPIOEx_Alternate_function_selection */&#125; GPIO_InitTypeDef; HAL_GPIO_Init 1void HAL_GPIO_Init(GPIO_TypeDef *GPIOx, GPIO_InitTypeDef *GPIO_Init) GPIO读 1GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin) GPIO写 1void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState) RCC配置 123/* GPIO Ports Clock Enable */__HAL_RCC_GPIOA_CLK_ENABLE();__HAL_RCC_GPIOB_CLK_ENABLE(); 初始化示例 1234567891011121314151617181920void MX_GPIO_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStruct = &#123;0&#125;; /* GPIO Ports Clock Enable */ __HAL_RCC_GPIOA_CLK_ENABLE(); __HAL_RCC_GPIOB_CLK_ENABLE(); /*Configure GPIO pin Output Level */ HAL_GPIO_WritePin(GPIOB, GPIO_PIN_4, GPIO_PIN_RESET); /*Configure GPIO pin : PB4 */ GPIO_InitStruct.Pin = GPIO_PIN_4; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);&#125; 使用示例 12345678HAL_Init();SystemClock_Config();MX_GPIO_Init();while (1)&#123; HAL_GPIO_TogglePin(GPIOB,GPIO_PIN_4); HAL_Delay(100);&#125;"},{"title":"LCD驱动","path":"/wiki/stm32/LCD驱动.html","content":"介绍LCD2002驱动教程"},{"title":"Bootloader实现","path":"/wiki/stm32/Bootloader实现.html","content":"介绍bootloader 应用程序"},{"title":"KEY驱动","path":"/wiki/stm32/KEY驱动.html","content":"介绍GPIONVIC中断处理"},{"title":"RTC使用","path":"/wiki/stm32/RTC使用.html","content":"介绍获取准确的时钟源"},{"title":"Sensor驱动","path":"/wiki/stm32/Sensor驱动.html","content":"介绍读取内部温度传感器的值"},{"title":"USART使用","path":"/wiki/stm32/USART使用.html","content":"配置GPIO USART 中断发送接收printf1234567#include &lt;stdio.h&gt;#include &lt;stm32g0xx_hal.h&gt;int fputc(int ch, FILE *f) &#123; HAL_UART_Transmit(&amp;huart2, (uint8_t *)&amp;ch, 1, HAL_MAX_DELAY); return ch;&#125;"},{"title":"启动流程","path":"/wiki/uboot/index.html","content":"介绍"},{"title":"stm32g030c8t6介绍","path":"/wiki/stm32/index.html","content":"介绍STM32G030x6/x8 系列主流微控制器基于高性能的 Arm® Cortex®-M0+ 32 位 RISC 内核，最高工作频率可达 64 MHz；stm32g030c8t6这款芯片集成了丰富的片上资源，适用于消费、工业和家电领域的广泛应用 MCU：主频最高可达64MHz SRAM：8K FLASH：64K GPIO：44路多用途IO TIMER：1路高级定时器、2路通用定时器、一路systick、2路看门狗 I2C：2路 USART：2路 SPI：2路 RTC：一个 ADC：1路，支持多大19个通道 c8系列芯片采用LQFP48封装，管脚分布如下： 开发进行stm32的开发需要准备以下软件或者工具 MDK Keil keil的安装比较简单，现在最新版本是免费的了，避免了盗版的问题 STM32CubeMX 这个工具是用来配置芯片资源的，软硬件工程师都可以用，ST官网可以免费下载安装 另外还需要准备：ST-LINK V2和CH340 USB转串口作作为调试工具 工程新建CubeMX工程 选择芯片型号stm32g030c8t6，然后双击进去 配置外设资源，常见的有GPIO、NVIC、RCC、USART等 修改时钟：RTC为32.768KHz，HCLK为16MHz 导出工程配置，然后点击右上角GENERATE CODE就可以导出MDK KEIL工程到指定目录下了 正常用Keil5打开编译是没有什么问题的，到Debug栏配置ST-Link Debugger就可以烧录了 电气关于stm32g030c8t6这款芯片的一些电气特性，搭配外设使用的时候要注意： 电源：3.3V供电，2.0 V to 3.6 V 最大输出电流：80mA 最大输入电流：100mA 工作温度：-40 - 85℃ 这款芯片在嘉立创商城的价格也就3-5RMB左右，如果用来替代51这样的单片机问题不大，各方面性能都很优越 说明这里使用stm32CubeMX是为了导出SDK，当然也可以使用CubeMX图形化的方式进行编程，但初学者建议把HAL的代码亲手撸一遍"}]